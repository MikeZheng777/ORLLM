{"task_id": "B088", "description": "A company produces product A and product B. Each unit of product A sold generates a profit of £30, while each unit of product B sold generates a profit of £10. The company can allocate a maximum of 40 hours per week for production. Producing one unit of product A requires 6 hours, while producing one unit of product B requires 3 hours. Market demand requires that the quantity of product B produced must be at least three times the quantity of product A. The storage space occupied by product A is four times that of product B, and a maximum of four units of product A can be stored per week.\n\nFormulate a model for this problem.", "ground_truth": 150.0, "formulation": null, "correct_program": "def optimize_production(profit_A=30,\n                        profit_B=10,\n                        hours_per_A=6,\n                        hours_per_B=3,\n                        max_hours=40,\n                        min_B_ratio=3,\n                        max_A_storage=4):\n    import gurobipy as gp\n    from gurobipy import GRB\n\n    # Create a new model\n    model = gp.Model(\"Production_Optimization\")\n\n    # Decision variables: number of units of A and B\n    x_A = model.addVar(vtype=GRB.INTEGER, name=\"x_A\", lb=0)\n    x_B = model.addVar(vtype=GRB.INTEGER, name=\"x_B\", lb=0)\n\n    # Set objective: maximize profit\n    model.setObjective(profit_A * x_A + profit_B * x_B, GRB.MAXIMIZE)\n\n    # Add constraints\n    # Production time constraint\n    model.addConstr(hours_per_A * x_A + hours_per_B * x_B <= max_hours,\n                    \"TimeLimit\")\n    # Market demand constraint for B\n    model.addConstr(x_B >= min_B_ratio * x_A, \"DemandB\")\n    # Storage space constraint for A\n    model.addConstr(x_A <= max_A_storage, \"StorageA\")\n\n    # Optimize the model\n    model.optimize()\n\n    # Check if a feasible solution was found\n    if model.status == GRB.OPTIMAL:\n        return model.objVal\n    else:\n        return None\nif __name__ == \"__main__\":  # pragma: no cover\n    result = optimize_production()\n    if result is not None:\n        print(f\"Optimal profit: {result}\")\n    else:\n        print(\"No feasible solution found.\")", "output_status": [], "success_count": 0, "success_confidence": 0, "fail_to_diagnose": 0, "fail_to_verify": 0, "retrieved_insights": [], "tag": [{"problem_domain": "Production Planning", "modeling_type": "IP", "industry_sector": "Manufacturing", "reason": "The problem involves determining optimal production quantities for two products to maximize profit under resource, demand, and storage constraints, which is a classic production planning scenario. The decision variables are integers (number of units), and the objective and constraints are linear, making it an Integer Program."}], "cluster": null, "prompt": "Below is an operations research question. First formulate the problem as an optimization problem. Then according to the formulated problem, write python code that uses 'gurobipy' to solve the optimization problem. You should write a complete python code that can be executed to solve the optimization problem.\n\nIMPORTANT: Your code should follow these requirements:\n1. Create a Gurobi model variable named 'model' (not 'm' or other names)\n2. Include all necessary imports and data setup\n3. Write the complete optimization code that can run independently\n4. Do NOT wrap everything in a function - write the code directly\n5. Make sure the model is created and optimized in the main execution flow\n6. The code should print the optimal objective value when solved successfully\n\nExample format:\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Data setup\ndata = {...}\n\n# Create model\nmodel = gp.Model(\"ProblemName\")\n\n# Decision variables\nx = model.addVars(...)\n\n# Objective\nmodel.setObjective(...)\n\n# Constraints\nmodel.addConstr(...)\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\nelse:\n    print(\"No optimal solution found\")\n```\n\n# Question:\nA company produces product A and product B. Each unit of product A sold generates a profit of £30, while each unit of product B sold generates a profit of £10. The company can allocate a maximum of 40 hours per week for production. Producing one unit of product A requires 6 hours, while producing one unit of product B requires 3 hours. Market demand requires that the quantity of product B produced must be at least three times the quantity of product A. The storage space occupied by product A is four times that of product B, and a maximum of four units of product A can be stored per week.\n\nFormulate a model for this problem.\n\n# Response:", "generated_output": "**Mathematical formulation**\n\nDecision variables  \n- \\(x_A \\ge 0\\): number of units of product A produced per week  \n- \\(x_B \\ge 0\\): number of units of product B produced per week  \n\nObjective (maximize profit)  \n\\[\n\\max \\; Z = 30x_A + 10x_B\n\\]\n\nSubject to:\n\n1. **Production time constraint (max 40 hours):**\n\\[\n6x_A + 3x_B \\le 40\n\\]\n\n2. **Market demand constraint (B at least 3 times A):**\n\\[\nx_B \\ge 3x_A\n\\]\n\n3. **Storage constraint for A (max 4 units):**\n\\[\nx_A \\le 4\n\\]\n\n4. **Non-negativity:**\n\\[\nx_A \\ge 0,\\quad x_B \\ge 0\n\\]\n\n---\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Create model\nmodel = gp.Model(\"ProductionPlanning\")\n\n# Decision variables\n# xA: units of product A\n# xB: units of product B\nxA = model.addVar(name=\"xA\", lb=0, vtype=GRB.CONTINUOUS)\nxB = model.addVar(name=\"xB\", lb=0, vtype=GRB.CONTINUOUS)\n\n# Objective: maximize profit = 30*xA + 10*xB\nmodel.setObjective(30 * xA + 10 * xB, GRB.MAXIMIZE)\n\n# Constraints\n\n# 1) Production time: 6*xA + 3*xB <= 40\nmodel.addConstr(6 * xA + 3 * xB <= 40, name=\"TimeConstraint\")\n\n# 2) Market demand: xB >= 3*xA\nmodel.addConstr(xB >= 3 * xA, name=\"DemandConstraint\")\n\n# 3) Storage for A: xA <= 4\nmodel.addConstr(xA <= 4, name=\"StorageConstraintA\")\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\n    print(f\"Optimal production of A (xA): {xA.X}\")\n    print(f\"Optimal production of B (xB): {xB.X}\")\nelse:\n    print(\"No optimal solution found\")\n```", "extracted_code": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create model\nmodel = gp.Model(\"ProductionPlanning\")\n\n# Decision variables\n# xA: units of product A\n# xB: units of product B\nxA = model.addVar(name=\"xA\", lb=0, vtype=GRB.CONTINUOUS)\nxB = model.addVar(name=\"xB\", lb=0, vtype=GRB.CONTINUOUS)\n\n# Objective: maximize profit = 30*xA + 10*xB\nmodel.setObjective(30 * xA + 10 * xB, GRB.MAXIMIZE)\n\n# Constraints\n\n# 1) Production time: 6*xA + 3*xB <= 40\nmodel.addConstr(6 * xA + 3 * xB <= 40, name=\"TimeConstraint\")\n\n# 2) Market demand: xB >= 3*xA\nmodel.addConstr(xB >= 3 * xA, name=\"DemandConstraint\")\n\n# 3) Storage for A: xA <= 4\nmodel.addConstr(xA <= 4, name=\"StorageConstraintA\")\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\n    print(f\"Optimal production of A (xA): {xA.X}\")\n    print(f\"Optimal production of B (xB): {xB.X}\")\nelse:\n    print(\"No optimal solution found\")", "execution_success": true, "mathematical_accuracy": false, "execution_result": "Execution Successful", "execution_best_solution": 160.0, "execution_state": "Execution Successful"}
{"task_id": "B042", "description": "A production base needs to extract raw materials from warehouses A and B every day for production. The required raw materials are: at least 240 pieces of raw material A, at least 80 kg of raw material B, and at least 120 tons of raw material C. It is known that: Each truck from warehouse A can transport back to the production base 4 pieces of raw material A, 2 kg of raw material B, 6 tons of raw material C, with a freight cost of 200 yuan per truck; each truck from warehouse B can transport back to the production base 7 pieces of raw material A, 2 kg of raw material B, 2 tons of raw material C per day, with a freight cost of 160 yuan per truck. Question: In order to meet production needs, how many trucks should be dispatched daily from warehouse A and warehouse B to minimize the total freight cost?", "ground_truth": 6800.0, "formulation": null, "correct_program": "def optimize_truck_dispatch(\n        cost_A=200,  # freight cost per truck from warehouse A\n        cost_B=160,  # freight cost per truck from warehouse B\n        min_A=240,  # minimum raw material A pieces\n        min_B=80,  # minimum raw material B kg\n        min_C=120  # minimum raw material C tons\n):\n    import gurobipy as gp\n    from gurobipy import GRB\n\n    # Create a new model\n    model = gp.Model(\"Truck_Dispatch_Optimization\")\n\n    # Decision variables: number of trucks from warehouses A and B\n    x_A = model.addVar(vtype=GRB.INTEGER, lb=0, name=\"x_A\")\n    x_B = model.addVar(vtype=GRB.INTEGER, lb=0, name=\"x_B\")\n\n    # Set objective: minimize total freight cost\n    model.setObjective(cost_A * x_A + cost_B * x_B, GRB.MINIMIZE)\n\n    # Add constraints for raw materials\n    # Raw material A\n    model.addConstr(4 * x_A + 7 * x_B >= min_A, \"Raw_A\")\n    # Raw material B\n    model.addConstr(2 * x_A + 2 * x_B >= min_B, \"Raw_B\")\n    # Raw material C\n    model.addConstr(6 * x_A + 2 * x_B >= min_C, \"Raw_C\")\n\n    # Optimize the model\n    model.optimize()\n\n    # Check if a feasible solution was found\n    if model.status == GRB.OPTIMAL:\n        # Return the optimal total freight cost\n        return model.objVal\n    else:\n        # No feasible solution found\n        return None\nif __name__ == \"__main__\":\n    result = optimize_truck_dispatch()\n    if result is not None:\n        print(f\"Optimal total freight cost: {result}\")\n    else:\n        print(\"No feasible solution found.\")", "output_status": [], "success_count": 0, "success_confidence": 0, "fail_to_diagnose": 0, "fail_to_verify": 0, "retrieved_insights": [], "tag": [{"problem_domain": "Resource Allocation", "modeling_type": "IP", "industry_sector": "Manufacturing", "reason": "The problem involves allocating trucks from different warehouses to meet minimum raw material requirements at a production base while minimizing transportation costs. The decision variables are integers (number of trucks), and the objective and constraints are linear, classifying it as an Integer Program within the manufacturing sector."}], "cluster": null, "prompt": "Below is an operations research question. First formulate the problem as an optimization problem. Then according to the formulated problem, write python code that uses 'gurobipy' to solve the optimization problem. You should write a complete python code that can be executed to solve the optimization problem.\n\nIMPORTANT: Your code should follow these requirements:\n1. Create a Gurobi model variable named 'model' (not 'm' or other names)\n2. Include all necessary imports and data setup\n3. Write the complete optimization code that can run independently\n4. Do NOT wrap everything in a function - write the code directly\n5. Make sure the model is created and optimized in the main execution flow\n6. The code should print the optimal objective value when solved successfully\n\nExample format:\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Data setup\ndata = {...}\n\n# Create model\nmodel = gp.Model(\"ProblemName\")\n\n# Decision variables\nx = model.addVars(...)\n\n# Objective\nmodel.setObjective(...)\n\n# Constraints\nmodel.addConstr(...)\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\nelse:\n    print(\"No optimal solution found\")\n```\n\n# Question:\nA production base needs to extract raw materials from warehouses A and B every day for production. The required raw materials are: at least 240 pieces of raw material A, at least 80 kg of raw material B, and at least 120 tons of raw material C. It is known that: Each truck from warehouse A can transport back to the production base 4 pieces of raw material A, 2 kg of raw material B, 6 tons of raw material C, with a freight cost of 200 yuan per truck; each truck from warehouse B can transport back to the production base 7 pieces of raw material A, 2 kg of raw material B, 2 tons of raw material C per day, with a freight cost of 160 yuan per truck. Question: In order to meet production needs, how many trucks should be dispatched daily from warehouse A and warehouse B to minimize the total freight cost?\n\n# Response:", "generated_output": "**Mathematical formulation**\n\nDecision variables  \n- \\(x_A \\ge 0\\): number of trucks dispatched from warehouse A per day  \n- \\(x_B \\ge 0\\): number of trucks dispatched from warehouse B per day  \n\nObjective (minimize total freight cost)  \n\\[\n\\min Z = 200 x_A + 160 x_B\n\\]\n\nConstraints (meet minimum material requirements):\n\nRaw material A (pieces):  \n\\[\n4 x_A + 7 x_B \\ge 240\n\\]\n\nRaw material B (kg):  \n\\[\n2 x_A + 2 x_B \\ge 80\n\\]\n\nRaw material C (tons):  \n\\[\n6 x_A + 2 x_B \\ge 120\n\\]\n\nNon-negativity:  \n\\[\nx_A \\ge 0,\\quad x_B \\ge 0\n\\]\n\n(If trucks must be integer, add \\(x_A, x_B \\in \\mathbb{Z}_+\\). Below I will model them as integers.)\n\n---\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Create model\nmodel = gp.Model(\"Truck_Dispatch_Problem\")\n\n# Decision variables: number of trucks from A and B (integer, nonnegative)\nxA = model.addVar(vtype=GRB.INTEGER, name=\"xA\")  # trucks from warehouse A\nxB = model.addVar(vtype=GRB.INTEGER, name=\"xB\")  # trucks from warehouse B\n\n# Update model to integrate new variables\nmodel.update()\n\n# Objective: minimize total freight cost\n# Cost: 200 per truck from A, 160 per truck from B\nmodel.setObjective(200 * xA + 160 * xB, GRB.MINIMIZE)\n\n# Constraints\n\n# Raw material A (pieces): 4*xA + 7*xB >= 240\nmodel.addConstr(4 * xA + 7 * xB >= 240, name=\"Material_A_requirement\")\n\n# Raw material B (kg): 2*xA + 2*xB >= 80\nmodel.addConstr(2 * xA + 2 * xB >= 80, name=\"Material_B_requirement\")\n\n# Raw material C (tons): 6*xA + 2*xB >= 120\nmodel.addConstr(6 * xA + 2 * xB >= 120, name=\"Material_C_requirement\")\n\n# Non-negativity is already enforced by default lower bound 0 for integer vars\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\n    print(f\"Trucks from warehouse A (xA): {xA.X}\")\n    print(f\"Trucks from warehouse B (xB): {xB.X}\")\nelse:\n    print(\"No optimal solution found\")\n```", "extracted_code": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create model\nmodel = gp.Model(\"Truck_Dispatch_Problem\")\n\n# Decision variables: number of trucks from A and B (integer, nonnegative)\nxA = model.addVar(vtype=GRB.INTEGER, name=\"xA\")  # trucks from warehouse A\nxB = model.addVar(vtype=GRB.INTEGER, name=\"xB\")  # trucks from warehouse B\n\n# Update model to integrate new variables\nmodel.update()\n\n# Objective: minimize total freight cost\n# Cost: 200 per truck from A, 160 per truck from B\nmodel.setObjective(200 * xA + 160 * xB, GRB.MINIMIZE)\n\n# Constraints\n\n# Raw material A (pieces): 4*xA + 7*xB >= 240\nmodel.addConstr(4 * xA + 7 * xB >= 240, name=\"Material_A_requirement\")\n\n# Raw material B (kg): 2*xA + 2*xB >= 80\nmodel.addConstr(2 * xA + 2 * xB >= 80, name=\"Material_B_requirement\")\n\n# Raw material C (tons): 6*xA + 2*xB >= 120\nmodel.addConstr(6 * xA + 2 * xB >= 120, name=\"Material_C_requirement\")\n\n# Non-negativity is already enforced by default lower bound 0 for integer vars\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\n    print(f\"Trucks from warehouse A (xA): {xA.X}\")\n    print(f\"Trucks from warehouse B (xB): {xB.X}\")\nelse:\n    print(\"No optimal solution found\")", "execution_success": true, "mathematical_accuracy": true, "execution_result": "Execution Successful", "execution_best_solution": 6800.0, "execution_state": "Execution Successful"}
{"task_id": "B075", "description": "A timber storage and transport company has a large warehouse for storing and transporting timber for sale. Due to seasonal price fluctuations, the company purchases timber at the beginning of each quarter, with part of it being sold within the quarter and part being stored for future sales. It is known that the maximum storage capacity of the company’s warehouse is 200,000 m³, and the storage cost is $(a+b u)$ yuan/m³, where $a=70$, $b=100$, and $u$ is the storage time (in quarters). The purchase and sale prices for each quarter and the estimated maximum sales volumes are shown in Table 1-18.\n\nTable 1-18\n| Quarter | Purchase Price (10,000 yuan/10,000 m²) | Sale Price (10,000 yuan/10,000 m²) | Estimated Maximum Sales Volume (10,000 m³) |\n|---------|----------------------------------------|------------------------------------|---------------------------------------------|\n| Winter  | 410                                    | 425                                | 100                                         |\n| Spring  | 430                                    | 440                                | 140                                         |\n| Summer  | 460                                    | 465                                | 200                                         |\n| Autumn  | 450                                    | 455                                | 160                                         |\n\nSince timber is not suitable for long-term storage, all inventory should be sold by the end of autumn. Try to establish a linear programming model for this problem to maximize the company's annual profit.", "ground_truth": 4700.0, "formulation": null, "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_timber_storage():\n    \"\"\"\n    Solves the timber storage and transport problem to maximize annual profit.\n    \"\"\"\n    try:\n        # --- Data ---\n        # Quarters: Winter (0), Spring (1), Summer (2), Autumn (3)\n        quarters = list(range(4))\n        quarter_names = ['Winter', 'Spring', 'Summer', 'Autumn']\n\n        # Prices and Sales Limits (Units: 10k yuan for price, 10k m^3 for volume)\n        purchase_prices = [410, 430, 460, 450]  # P_t\n        sale_prices = [425, 440, 465, 455]  # S_t\n        max_sales_volume = [100, 140, 200, 160]  # MaxSales_t\n\n        # Warehouse Capacity (Units: 10k m^3)\n        warehouse_capacity = 20\n\n        # Storage Cost (Units: 10k yuan per 10k m^3 per quarter)\n        # Calculated from (a+bu) yuan/m^3 with a=70, b=100, assuming u=1 for cost per quarter\n        storage_cost_per_unit_volume = 170  # H\n\n        # Initial Inventory (Units: 10k m^3)\n        initial_inventory = 0.0\n\n        # --- Create Gurobi Model ---\n        model = gp.Model(\"TimberStorageOptimization\")\n\n        # --- Decision Variables ---\n        # Buy[t]: Volume purchased at the beginning of quarter t\n        buy_vars = model.addVars(quarters,\n                                 name=\"Buy\",\n                                 lb=0.0,\n                                 vtype=GRB.CONTINUOUS)\n\n        # Sell[t]: Volume sold during quarter t\n        sell_vars = model.addVars(quarters,\n                                  name=\"Sell\",\n                                  lb=0.0,\n                                  vtype=GRB.CONTINUOUS)\n\n        # Inv[t]: Volume stored at the end of quarter t\n        inventory_vars = model.addVars(quarters,\n                                       name=\"Inventory\",\n                                       lb=0.0,\n                                       vtype=GRB.CONTINUOUS)\n\n        # --- Objective Function: Maximize Total Profit ---\n        # Profit = Sales Revenue - Purchase Cost - Holding Cost\n        total_sales_revenue = gp.quicksum(sale_prices[t] * sell_vars[t]\n                                          for t in quarters)\n        total_purchase_cost = gp.quicksum(purchase_prices[t] * buy_vars[t]\n                                          for t in quarters)\n        total_holding_cost = gp.quicksum(\n            storage_cost_per_unit_volume * inventory_vars[t] for t in quarters)\n\n        model.setObjective(\n            total_sales_revenue - total_purchase_cost - total_holding_cost,\n            GRB.MAXIMIZE)\n\n        # --- Constraints ---\n        for t in quarters:\n            # Inventory at the start of the current quarter t\n            prev_inventory = initial_inventory if t == 0 else inventory_vars[t\n                                                                             -\n                                                                             1]\n\n            # 1. Inventory Balance Constraint\n            # Inv[t] = Inv[t-1] + Buy[t] - Sell[t]\n            model.addConstr(inventory_vars[t] == prev_inventory + buy_vars[t] -\n                            sell_vars[t],\n                            name=f\"InventoryBalance_{quarter_names[t]}\")\n\n            # 2. Warehouse Capacity Constraint\n            # Inv[t] <= warehouse_capacity\n            model.addConstr(inventory_vars[t] <= warehouse_capacity,\n                            name=f\"WarehouseCapacity_{quarter_names[t]}\")\n\n            # 3. Sales Limit Constraint\n            # Sell[t] <= MaxSales[t]\n            model.addConstr(sell_vars[t] <= max_sales_volume[t],\n                            name=f\"MaxSales_{quarter_names[t]}\")\n\n            # 4. Availability for Sale Constraint\n            # Sell[t] <= Inv[t-1] + Buy[t]\n            model.addConstr(sell_vars[t] <= prev_inventory + buy_vars[t],\n                            name=f\"SalesAvailability_{quarter_names[t]}\")\n\n        # 5. End Condition: All inventory must be sold by the end of Autumn (t=3)\n        model.addConstr(inventory_vars[quarters[-1]] == 0,\n                        name=\"EndInventoryZero\")\n\n        # Suppress Gurobi output to console if desired\n        # model.setParam('OutputFlag', 0)\n\n        # Optimize the model\n        model.optimize()\n\n        # --- Results ---\n        if model.status == GRB.OPTIMAL:\n            print(\"Optimal storage and transport plan found.\")\n            print(f\"Maximum Annual Profit: {model.ObjVal * 10000:.2f} Yuan\"\n                  )  # Convert back to Yuan\n\n            print(\"\\nQuarterly Plan Details (Volumes in 10,000 m³):\")\n            header = f\"{'Quarter':<8} | {'Inv Start':<10} | {'Buy Qty':<10} | {'Sell Qty':<10} | {'Inv End':<10} | {'Holding Cost':<15}\"\n            print(header)\n            print(\"-\" * len(header))\n\n            current_inv = initial_inventory\n            for t in quarters:\n                holding_cost_t = storage_cost_per_unit_volume * inventory_vars[\n                    t].X\n                print(\n                    f\"{quarter_names[t]:<8} | {current_inv:<10.2f} | {buy_vars[t].X:<10.2f} | \"\n                    f\"{sell_vars[t].X:<10.2f} | {inventory_vars[t].X:<10.2f} | \"\n                    f\"{holding_cost_t * 10000:<15.2f}\"\n                )  # Convert cost back to Yuan\n                current_inv = inventory_vars[t].X\n            print(\"-\" * len(header))\n\n            print(\n                f\"\\nInitial Inventory (Start of Winter): {initial_inventory:.2f} (10k m³)\"\n            )\n            print(\n                f\"Final Inventory (End of Autumn): {inventory_vars[quarters[-1]].X:.2f} (10k m³)\"\n            )\n\n            # Cost breakdown\n            sales_rev_val = sum(sale_prices[t] * sell_vars[t].X\n                                for t in quarters) * 10000\n            purchase_cost_val = sum(purchase_prices[t] * buy_vars[t].X\n                                    for t in quarters) * 10000\n            holding_cost_val = sum(\n                storage_cost_per_unit_volume * inventory_vars[t].X\n                for t in quarters) * 10000\n            print(\"\\nFinancial Summary (Yuan):\")\n            print(f\"  Total Sales Revenue: {sales_rev_val:.2f}\")\n            print(f\"  Total Purchase Cost: {purchase_cost_val:.2f}\")\n            print(f\"  Total Holding Cost: {holding_cost_val:.2f}\")\n            print(\n                f\"  Calculated Profit: {(sales_rev_val - purchase_cost_val - holding_cost_val):.2f}\"\n            )\n\n        elif model.status == GRB.INFEASIBLE:\n            print(\n                \"Model is infeasible. Check constraints and data for contradictions.\"\n            )\n            # Compute and print IIS (Irreducible Inconsistent Subsystem)\n            # model.computeIIS()\n            # model.write(\"timber_storage_iis.ilp\")\n            # print(\"IIS written to timber_storage_iis.ilp.\")\n        else:\n            print(f\"Optimization stopped with status: {model.status}\")\n\n    except gp.GurobiError as e:\n        print(f\"Gurobi error code {e.errno}: {e}\")\n    except Exception as e:\n        print(f\"An unexpected error occurred: {e}\")\n\n\nif __name__ == '__main__':\n    solve_timber_storage()", "output_status": [], "success_count": 0, "success_confidence": 0, "fail_to_diagnose": 0, "fail_to_verify": 0, "retrieved_insights": [], "tag": [{"problem_domain": "Inventory Management", "modeling_type": "LP", "industry_sector": "Manufacturing", "reason": "The problem involves managing timber inventory over multiple quarters, making decisions on purchase and sales volumes to maximize profit, which is a classic inventory management problem. The formulation uses continuous variables and linear constraints and objective, classifying it as a Linear Program. The context of storing and transporting timber for sale falls under the broader manufacturing or raw material processing sector."}], "cluster": null, "prompt": "Below is an operations research question. First formulate the problem as an optimization problem. Then according to the formulated problem, write python code that uses 'gurobipy' to solve the optimization problem. You should write a complete python code that can be executed to solve the optimization problem.\n\nIMPORTANT: Your code should follow these requirements:\n1. Create a Gurobi model variable named 'model' (not 'm' or other names)\n2. Include all necessary imports and data setup\n3. Write the complete optimization code that can run independently\n4. Do NOT wrap everything in a function - write the code directly\n5. Make sure the model is created and optimized in the main execution flow\n6. The code should print the optimal objective value when solved successfully\n\nExample format:\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Data setup\ndata = {...}\n\n# Create model\nmodel = gp.Model(\"ProblemName\")\n\n# Decision variables\nx = model.addVars(...)\n\n# Objective\nmodel.setObjective(...)\n\n# Constraints\nmodel.addConstr(...)\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\nelse:\n    print(\"No optimal solution found\")\n```\n\n# Question:\nA timber storage and transport company has a large warehouse for storing and transporting timber for sale. Due to seasonal price fluctuations, the company purchases timber at the beginning of each quarter, with part of it being sold within the quarter and part being stored for future sales. It is known that the maximum storage capacity of the company’s warehouse is 200,000 m³, and the storage cost is $(a+b u)$ yuan/m³, where $a=70$, $b=100$, and $u$ is the storage time (in quarters). The purchase and sale prices for each quarter and the estimated maximum sales volumes are shown in Table 1-18.\n\nTable 1-18\n| Quarter | Purchase Price (10,000 yuan/10,000 m²) | Sale Price (10,000 yuan/10,000 m²) | Estimated Maximum Sales Volume (10,000 m³) |\n|---------|----------------------------------------|------------------------------------|---------------------------------------------|\n| Winter  | 410                                    | 425                                | 100                                         |\n| Spring  | 430                                    | 440                                | 140                                         |\n| Summer  | 460                                    | 465                                | 200                                         |\n| Autumn  | 450                                    | 455                                | 160                                         |\n\nSince timber is not suitable for long-term storage, all inventory should be sold by the end of autumn. Try to establish a linear programming model for this problem to maximize the company's annual profit.\n\n# Response:", "generated_output": "Below is a clear formulation and then a complete Gurobi Python code that can be run directly.\n\n---\n\n## 1. Model formulation\n\nIndices  \n- Quarters \\( t \\in \\{1,2,3,4\\} \\) corresponding to Winter, Spring, Summer, Autumn.\n\nParameters  \n(All volumes in 10,000 m³, prices in 10,000 yuan per 10,000 m³)\n\n- Purchase prices \\( c_t \\):\n  - \\( c_1 = 410 \\) (Winter)  \n  - \\( c_2 = 430 \\) (Spring)  \n  - \\( c_3 = 460 \\) (Summer)  \n  - \\( c_4 = 450 \\) (Autumn)\n- Sale prices \\( p_t \\):\n  - \\( p_1 = 425 \\) (Winter)  \n  - \\( p_2 = 440 \\) (Spring)  \n  - \\( p_3 = 465 \\) (Summer)  \n  - \\( p_4 = 455 \\) (Autumn)\n- Maximum sales volumes \\( D_t \\) (10,000 m³):\n  - \\( D_1 = 100 \\)  \n  - \\( D_2 = 140 \\)  \n  - \\( D_3 = 200 \\)  \n  - \\( D_4 = 160 \\)\n- Warehouse capacity: 200,000 m³ = 20 (in 10,000 m³ units)  \n  \\( \\text{Cap} = 20 \\)\n- Storage cost per m³ per quarter: \\( a + b u \\) yuan/m³, with \\( a = 70 \\), \\( b = 100 \\), \\( u \\) = storage time in quarters.  \n  In 10,000 yuan per 10,000 m³, this is:\n  \\[\n  \\text{storage\\_cost}(u) = \\frac{a + b u}{10000} = \\frac{70 + 100u}{10000}\n  \\]\n  for \\( u = 1,2,3 \\).\n\nDecision variables  \n- \\( x_t \\ge 0 \\): amount purchased in quarter \\( t \\) (10,000 m³)  \n- \\( s_t \\ge 0 \\): amount sold in quarter \\( t \\) (10,000 m³)  \n- \\( I_t \\ge 0 \\): inventory at end of quarter \\( t \\) (10,000 m³)  \n- \\( y_{i,t} \\ge 0 \\): amount purchased in quarter \\( i \\) and sold in quarter \\( t \\) (10,000 m³), for \\( i \\le t \\)\n\nInventory balance and flow constraints  \n1. Purchase equals total allocation to sales (no leftover unsold by source quarter):\n\\[\nx_i = \\sum_{t=i}^{4} y_{i,t}, \\quad i = 1,2,3,4\n\\]\n\n2. Sales in each quarter come from all previous purchases:\n\\[\ns_t = \\sum_{i=1}^{t} y_{i,t}, \\quad t = 1,2,3,4\n\\]\n\n3. Inventory evolution:\n\\[\nI_t = I_{t-1} + x_t - s_t, \\quad t = 1,2,3,4,\\quad I_0 = 0\n\\]\n\n4. Capacity:\n\\[\nI_t \\le \\text{Cap} = 20, \\quad t = 1,2,3,4\n\\]\n\n5. Demand (max sales) constraints:\n\\[\ns_t \\le D_t, \\quad t = 1,2,3,4\n\\]\n\n6. End-of-year inventory must be zero:\n\\[\nI_4 = 0\n\\]\n\nStorage cost  \nIf timber bought in quarter \\( i \\) is sold in quarter \\( t \\ge i \\), it is stored for \\( u = t - i \\) quarters.  \nStorage cost per unit (10,000 m³) for that flow is:\n\\[\n\\text{SC}_{i,t} = \\frac{70 + 100 (t-i)}{10000} \\quad \\text{(10,000 yuan per 10,000 m³)}\n\\]\nFor \\( t = i \\), \\( u = 0 \\), cost = \\( 70/10000 \\).  \nFor \\( t = i+1 \\), \\( u = 1 \\), cost = \\( 170/10000 \\), etc.\n\nObjective: maximize annual profit  \n\\[\n\\max \\; Z = \\sum_{t=1}^{4} p_t s_t \\;-\\; \\sum_{t=1}^{4} c_t x_t \\;-\\; \\sum_{i=1}^{4} \\sum_{t=i}^{4} \\text{SC}_{i,t} \\, y_{i,t}\n\\]\n\nSubject to all constraints above and nonnegativity of variables.\n\n---\n\n## 2. Complete Gurobi Python code\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# =========================\n# Data setup\n# =========================\n\nquarters = [1, 2, 3, 4]\n\n# Purchase prices (10,000 yuan per 10,000 m^3)\npurchase_price = {\n    1: 410,  # Winter\n    2: 430,  # Spring\n    3: 460,  # Summer\n    4: 450   # Autumn\n}\n\n# Sale prices (10,000 yuan per 10,000 m^3)\nsale_price = {\n    1: 425,  # Winter\n    2: 440,  # Spring\n    3: 465,  # Summer\n    4: 455   # Autumn\n}\n\n# Maximum sales volumes (10,000 m^3)\nmax_sales = {\n    1: 100,  # Winter\n    2: 140,  # Spring\n    3: 200,  # Summer\n    4: 160   # Autumn\n}\n\n# Warehouse capacity: 200,000 m^3 = 20 (in 10,000 m^3 units)\ncapacity = 20.0\n\n# Storage cost parameters (yuan per m^3 per quarter)\na = 70\nb = 100\n\n# Convert storage cost to 10,000 yuan per 10,000 m^3:\n# cost(u) = (a + b*u) / 10000\ndef storage_cost(u):\n    return (a + b * u) / 10000.0\n\n# Precompute storage cost for each (i, t) pair where t >= i\nstorage_cost_it = {}\nfor i in quarters:\n    for t in quarters:\n        if t >= i:\n            u = t - i  # number of quarters stored\n            storage_cost_it[(i, t)] = storage_cost(u)\n\n# =========================\n# Create model\n# =========================\n\nmodel = gp.Model(\"Timber_Storage_Transport\")\n\n# =========================\n# Decision variables\n# =========================\n\n# x_t: amount purchased in quarter t (10,000 m^3)\nx = model.addVars(quarters, name=\"x\", lb=0.0)\n\n# s_t: amount sold in quarter t (10,000 m^3)\ns = model.addVars(quarters, name=\"s\", lb=0.0)\n\n# I_t: inventory at end of quarter t (10,000 m^3)\nI = model.addVars(quarters, name=\"I\", lb=0.0)\n\n# y_{i,t}: amount purchased in quarter i and sold in quarter t (10,000 m^3), t >= i\ny = model.addVars(\n    [(i, t) for i in quarters for t in quarters if t >= i],\n    name=\"y\",\n    lb=0.0\n)\n\n# =========================\n# Constraints\n# =========================\n\n# 1) Purchase equals allocation to sales for each purchase quarter i\nfor i in quarters:\n    model.addConstr(\n        x[i] == gp.quicksum(y[i, t] for t in quarters if t >= i),\n        name=f\"purchase_flow_balance_{i}\"\n    )\n\n# 2) Sales in each quarter t equal sum of flows from all previous purchase quarters\nfor t in quarters:\n    model.addConstr(\n        s[t] == gp.quicksum(y[i, t] for i in quarters if i <= t),\n        name=f\"sales_flow_balance_{t}\"\n    )\n\n# 3) Inventory balance: I_t = I_{t-1} + x_t - s_t, with I_0 = 0\n# For t = 1: I_1 = x_1 - s_1\nmodel.addConstr(\n    I[1] == x[1] - s[1],\n    name=\"inventory_balance_1\"\n)\n\n# For t = 2,3,4\nfor t in quarters[1:]:\n    model.addConstr(\n        I[t] == I[t - 1] + x[t] - s[t],\n        name=f\"inventory_balance_{t}\"\n    )\n\n# 4) Capacity constraints: I_t <= capacity\nfor t in quarters:\n    model.addConstr(\n        I[t] <= capacity,\n        name=f\"capacity_{t}\"\n    )\n\n# 5) Maximum sales constraints: s_t <= max_sales_t\nfor t in quarters:\n    model.addConstr(\n        s[t] <= max_sales[t],\n        name=f\"max_sales_{t}\"\n    )\n\n# 6) End-of-year inventory must be zero: I_4 = 0\nmodel.addConstr(\n    I[4] == 0,\n    name=\"end_inventory_zero\"\n)\n\n# =========================\n# Objective: maximize profit\n# =========================\n\n# Revenue from sales\nrevenue = gp.quicksum(sale_price[t] * s[t] for t in quarters)\n\n# Purchase cost\npurchase_cost = gp.quicksum(purchase_price[t] * x[t] for t in quarters)\n\n# Storage cost: sum over all (i, t) with t >= i\nstorage_cost_total = gp.quicksum(\n    storage_cost_it[(i, t)] * y[i, t]\n    for (i, t) in y.keys()\n)\n\n# Maximize profit = revenue - purchase_cost - storage_cost_total\nmodel.setObjective(revenue - purchase_cost - storage_cost_total, GRB.MAXIMIZE)\n\n# =========================\n# Optimize\n# =========================\n\nmodel.optimize()\n\n# =========================\n# Results\n# =========================\n\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\nelse:\n    print(\"No optimal solution found\")\n```", "extracted_code": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# =========================\n# Data setup\n# =========================\n\nquarters = [1, 2, 3, 4]\n\n# Purchase prices (10,000 yuan per 10,000 m^3)\npurchase_price = {\n    1: 410,  # Winter\n    2: 430,  # Spring\n    3: 460,  # Summer\n    4: 450   # Autumn\n}\n\n# Sale prices (10,000 yuan per 10,000 m^3)\nsale_price = {\n    1: 425,  # Winter\n    2: 440,  # Spring\n    3: 465,  # Summer\n    4: 455   # Autumn\n}\n\n# Maximum sales volumes (10,000 m^3)\nmax_sales = {\n    1: 100,  # Winter\n    2: 140,  # Spring\n    3: 200,  # Summer\n    4: 160   # Autumn\n}\n\n# Warehouse capacity: 200,000 m^3 = 20 (in 10,000 m^3 units)\ncapacity = 20.0\n\n# Storage cost parameters (yuan per m^3 per quarter)\na = 70\nb = 100\n\n# Convert storage cost to 10,000 yuan per 10,000 m^3:\n# cost(u) = (a + b*u) / 10000\ndef storage_cost(u):\n    return (a + b * u) / 10000.0\n\n# Precompute storage cost for each (i, t) pair where t >= i\nstorage_cost_it = {}\nfor i in quarters:\n    for t in quarters:\n        if t >= i:\n            u = t - i  # number of quarters stored\n            storage_cost_it[(i, t)] = storage_cost(u)\n\n# =========================\n# Create model\n# =========================\n\nmodel = gp.Model(\"Timber_Storage_Transport\")\n\n# =========================\n# Decision variables\n# =========================\n\n# x_t: amount purchased in quarter t (10,000 m^3)\nx = model.addVars(quarters, name=\"x\", lb=0.0)\n\n# s_t: amount sold in quarter t (10,000 m^3)\ns = model.addVars(quarters, name=\"s\", lb=0.0)\n\n# I_t: inventory at end of quarter t (10,000 m^3)\nI = model.addVars(quarters, name=\"I\", lb=0.0)\n\n# y_{i,t}: amount purchased in quarter i and sold in quarter t (10,000 m^3), t >= i\ny = model.addVars(\n    [(i, t) for i in quarters for t in quarters if t >= i],\n    name=\"y\",\n    lb=0.0\n)\n\n# =========================\n# Constraints\n# =========================\n\n# 1) Purchase equals allocation to sales for each purchase quarter i\nfor i in quarters:\n    model.addConstr(\n        x[i] == gp.quicksum(y[i, t] for t in quarters if t >= i),\n        name=f\"purchase_flow_balance_{i}\"\n    )\n\n# 2) Sales in each quarter t equal sum of flows from all previous purchase quarters\nfor t in quarters:\n    model.addConstr(\n        s[t] == gp.quicksum(y[i, t] for i in quarters if i <= t),\n        name=f\"sales_flow_balance_{t}\"\n    )\n\n# 3) Inventory balance: I_t = I_{t-1} + x_t - s_t, with I_0 = 0\n# For t = 1: I_1 = x_1 - s_1\nmodel.addConstr(\n    I[1] == x[1] - s[1],\n    name=\"inventory_balance_1\"\n)\n\n# For t = 2,3,4\nfor t in quarters[1:]:\n    model.addConstr(\n        I[t] == I[t - 1] + x[t] - s[t],\n        name=f\"inventory_balance_{t}\"\n    )\n\n# 4) Capacity constraints: I_t <= capacity\nfor t in quarters:\n    model.addConstr(\n        I[t] <= capacity,\n        name=f\"capacity_{t}\"\n    )\n\n# 5) Maximum sales constraints: s_t <= max_sales_t\nfor t in quarters:\n    model.addConstr(\n        s[t] <= max_sales[t],\n        name=f\"max_sales_{t}\"\n    )\n\n# 6) End-of-year inventory must be zero: I_4 = 0\nmodel.addConstr(\n    I[4] == 0,\n    name=\"end_inventory_zero\"\n)\n\n# =========================\n# Objective: maximize profit\n# =========================\n\n# Revenue from sales\nrevenue = gp.quicksum(sale_price[t] * s[t] for t in quarters)\n\n# Purchase cost\npurchase_cost = gp.quicksum(purchase_price[t] * x[t] for t in quarters)\n\n# Storage cost: sum over all (i, t) with t >= i\nstorage_cost_total = gp.quicksum(\n    storage_cost_it[(i, t)] * y[i, t]\n    for (i, t) in y.keys()\n)\n\n# Maximize profit = revenue - purchase_cost - storage_cost_total\nmodel.setObjective(revenue - purchase_cost - storage_cost_total, GRB.MAXIMIZE)\n\n# =========================\n# Optimize\n# =========================\n\nmodel.optimize()\n\n# =========================\n# Results\n# =========================\n\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\nelse:\n    print(\"No optimal solution found\")", "execution_success": true, "mathematical_accuracy": false, "execution_result": "Execution Successful", "execution_best_solution": 5695.4, "execution_state": "Execution Successful"}
{"task_id": "B022", "description": "Hongdou Clothing Factory uses three special equipment to produce shirts, short-sleeved shirts, and casual clothes respectively. It is known that the labor, material usage, selling price, and variable cost of each of the above products are as shown in Table 5-10.\n\nTable 5-10\n\n| Product Name | Labor per unit | Material per unit | Selling Price | Variable Cost |\n|--------------|----------------|------------------|---------------|---------------|\n| Shirt        | 3              | 4                | 120           | 60            |\n| Short-sleeve | 2              | 3                | 80            | 40            |\n| Casual Cloth | 6              | 6                | 180           | 80            |\n\nIt is known that the available labor per week is 1500 units, the available material is 1600 units, and the weekly fixed costs for the three special equipment for producing shirts, short-sleeved shirts, and casual clothes are 2000, 1500, and 1000 respectively. Design a weekly production plan for the factory to maximize its profit.", "ground_truth": 21500.0, "formulation": null, "correct_program": "def hongdou_factory_optimization(labor_per_unit=[3, 2, 6],\n                                 material_per_unit=[4, 3, 6],\n                                 selling_price=[120, 80, 180],\n                                 variable_cost=[60, 40, 80],\n                                 labor_available=1500,\n                                 material_available=1600,\n                                 fixed_costs=[2000, 1500, 1000]):\n    from gurobipy import Model, GRB\n\n    n = 3  # number of products\n\n    # Net profit per unit for each product\n    profit_per_unit = [selling_price[i] - variable_cost[i] for i in range(n)]\n    total_fixed_cost = sum(fixed_costs)\n\n    try:\n        m = Model()\n        m.setParam('OutputFlag', 0)\n\n        # Decision variables: x[i] = number of units produced for product i\n        x = [\n            m.addVar(lb=0, vtype=GRB.CONTINUOUS, name=f\"x_{i+1}\")\n            for i in range(n)\n        ]\n\n        # Objective: maximize total profit\n        m.setObjective(\n            sum(profit_per_unit[i] * x[i]\n                for i in range(n)) - total_fixed_cost, GRB.MAXIMIZE)\n\n        # Labor constraint\n        m.addConstr(\n            sum(labor_per_unit[i] * x[i] for i in range(n)) <= labor_available,\n            \"Labor\")\n\n        # Material constraint\n        m.addConstr(\n            sum(material_per_unit[i] * x[i] for i in range(n))\n            <= material_available, \"Material\")\n\n        # Solve\n        m.optimize()\n\n        if m.status == GRB.OPTIMAL:\n            return m.objVal\n        else:\n            return None\n    except Exception:\n        return None\n\nprint(hongdou_factory_optimization())", "output_status": [], "success_count": 0, "success_confidence": 0, "fail_to_diagnose": 0, "fail_to_verify": 0, "retrieved_insights": [], "tag": [{"problem_domain": "Production Planning", "modeling_type": "LP", "industry_sector": "Manufacturing", "reason": "The problem aims to determine the optimal quantity of each product to manufacture given resource constraints (labor, material) to maximize profit, which is a classic production planning problem. The model uses continuous variables and linear objective and constraints, classifying it as a Linear Program. The context of producing clothing in a factory clearly places it in the manufacturing sector."}], "cluster": null, "prompt": "Below is an operations research question. First formulate the problem as an optimization problem. Then according to the formulated problem, write python code that uses 'gurobipy' to solve the optimization problem. You should write a complete python code that can be executed to solve the optimization problem.\n\nIMPORTANT: Your code should follow these requirements:\n1. Create a Gurobi model variable named 'model' (not 'm' or other names)\n2. Include all necessary imports and data setup\n3. Write the complete optimization code that can run independently\n4. Do NOT wrap everything in a function - write the code directly\n5. Make sure the model is created and optimized in the main execution flow\n6. The code should print the optimal objective value when solved successfully\n\nExample format:\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Data setup\ndata = {...}\n\n# Create model\nmodel = gp.Model(\"ProblemName\")\n\n# Decision variables\nx = model.addVars(...)\n\n# Objective\nmodel.setObjective(...)\n\n# Constraints\nmodel.addConstr(...)\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\nelse:\n    print(\"No optimal solution found\")\n```\n\n# Question:\nHongdou Clothing Factory uses three special equipment to produce shirts, short-sleeved shirts, and casual clothes respectively. It is known that the labor, material usage, selling price, and variable cost of each of the above products are as shown in Table 5-10.\n\nTable 5-10\n\n| Product Name | Labor per unit | Material per unit | Selling Price | Variable Cost |\n|--------------|----------------|------------------|---------------|---------------|\n| Shirt        | 3              | 4                | 120           | 60            |\n| Short-sleeve | 2              | 3                | 80            | 40            |\n| Casual Cloth | 6              | 6                | 180           | 80            |\n\nIt is known that the available labor per week is 1500 units, the available material is 1600 units, and the weekly fixed costs for the three special equipment for producing shirts, short-sleeved shirts, and casual clothes are 2000, 1500, and 1000 respectively. Design a weekly production plan for the factory to maximize its profit.\n\n# Response:", "generated_output": "Below is the formulation and then the complete Python code using `gurobipy`.\n\n---\n\n## 1. Optimization Model Formulation\n\nLet  \n- \\(x_1\\) = number of shirts produced per week  \n- \\(x_2\\) = number of short-sleeved shirts produced per week  \n- \\(x_3\\) = number of casual clothes produced per week  \n\nProfit per unit (selling price − variable cost):\n\n- Shirt: \\(120 - 60 = 60\\)\n- Short-sleeve: \\(80 - 40 = 40\\)\n- Casual cloth: \\(180 - 80 = 100\\)\n\nWeekly fixed costs (for the three special equipment):\n\n- Shirt equipment: 2000  \n- Short-sleeve equipment: 1500  \n- Casual cloth equipment: 1000  \n\nTotal fixed cost per week: \\(2000 + 1500 + 1000 = 4500\\)\n\n**Objective (maximize weekly profit):**\n\\[\n\\max Z = 60x_1 + 40x_2 + 100x_3 - 4500\n\\]\n\n**Constraints:**\n\nLabor constraint (available 1500 units):\n\\[\n3x_1 + 2x_2 + 6x_3 \\le 1500\n\\]\n\nMaterial constraint (available 1600 units):\n\\[\n4x_1 + 3x_2 + 6x_3 \\le 1600\n\\]\n\nNon-negativity:\n\\[\nx_1, x_2, x_3 \\ge 0\n\\]\n\n(If integer production is required, we can set them as integer variables; otherwise, treat them as continuous. Here we will assume continuous non-negative variables.)\n\n---\n\n## 2. Complete Python Code with Gurobi\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# -----------------------------\n# Data setup\n# -----------------------------\n# Profit per unit (selling price - variable cost)\nprofit = {\n    \"shirt\": 60,        # 120 - 60\n    \"short_sleeve\": 40, # 80 - 40\n    \"casual\": 100       # 180 - 80\n}\n\n# Fixed costs per week for each equipment\nfixed_costs = {\n    \"shirt\": 2000,\n    \"short_sleeve\": 1500,\n    \"casual\": 1000\n}\n\ntotal_fixed_cost = sum(fixed_costs.values())\n\n# Resource usage per unit\nlabor = {\n    \"shirt\": 3,\n    \"short_sleeve\": 2,\n    \"casual\": 6\n}\n\nmaterial = {\n    \"shirt\": 4,\n    \"short_sleeve\": 3,\n    \"casual\": 6\n}\n\n# Resource availability\nlabor_capacity = 1500\nmaterial_capacity = 1600\n\n# -----------------------------\n# Create model\n# -----------------------------\nmodel = gp.Model(\"Hongdou_Clothing_Production\")\n\n# -----------------------------\n# Decision variables\n# -----------------------------\n# x_shirt: number of shirts\n# x_short: number of short-sleeved shirts\n# x_casual: number of casual clothes\nx_shirt = model.addVar(name=\"x_shirt\", lb=0.0)\nx_short = model.addVar(name=\"x_short_sleeve\", lb=0.0)\nx_casual = model.addVar(name=\"x_casual\", lb=0.0)\n\n# -----------------------------\n# Objective: maximize profit\n# -----------------------------\nmodel.setObjective(\n    profit[\"shirt\"] * x_shirt\n    + profit[\"short_sleeve\"] * x_short\n    + profit[\"casual\"] * x_casual\n    - total_fixed_cost,\n    GRB.MAXIMIZE\n)\n\n# -----------------------------\n# Constraints\n# -----------------------------\n# Labor constraint\nmodel.addConstr(\n    labor[\"shirt\"] * x_shirt\n    + labor[\"short_sleeve\"] * x_short\n    + labor[\"casual\"] * x_casual\n    <= labor_capacity,\n    name=\"Labor_Capacity\"\n)\n\n# Material constraint\nmodel.addConstr(\n    material[\"shirt\"] * x_shirt\n    + material[\"short_sleeve\"] * x_short\n    + material[\"casual\"] * x_casual\n    <= material_capacity,\n    name=\"Material_Capacity\"\n)\n\n# -----------------------------\n# Optimize\n# -----------------------------\nmodel.optimize()\n\n# -----------------------------\n# Results\n# -----------------------------\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\n    print(\"Optimal production plan:\")\n    print(f\"  Shirts: {x_shirt.X}\")\n    print(f\"  Short-sleeved shirts: {x_short.X}\")\n    print(f\"  Casual clothes: {x_casual.X}\")\nelse:\n    print(\"No optimal solution found\")\n```", "extracted_code": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# -----------------------------\n# Data setup\n# -----------------------------\n# Profit per unit (selling price - variable cost)\nprofit = {\n    \"shirt\": 60,        # 120 - 60\n    \"short_sleeve\": 40, # 80 - 40\n    \"casual\": 100       # 180 - 80\n}\n\n# Fixed costs per week for each equipment\nfixed_costs = {\n    \"shirt\": 2000,\n    \"short_sleeve\": 1500,\n    \"casual\": 1000\n}\n\ntotal_fixed_cost = sum(fixed_costs.values())\n\n# Resource usage per unit\nlabor = {\n    \"shirt\": 3,\n    \"short_sleeve\": 2,\n    \"casual\": 6\n}\n\nmaterial = {\n    \"shirt\": 4,\n    \"short_sleeve\": 3,\n    \"casual\": 6\n}\n\n# Resource availability\nlabor_capacity = 1500\nmaterial_capacity = 1600\n\n# -----------------------------\n# Create model\n# -----------------------------\nmodel = gp.Model(\"Hongdou_Clothing_Production\")\n\n# -----------------------------\n# Decision variables\n# -----------------------------\n# x_shirt: number of shirts\n# x_short: number of short-sleeved shirts\n# x_casual: number of casual clothes\nx_shirt = model.addVar(name=\"x_shirt\", lb=0.0)\nx_short = model.addVar(name=\"x_short_sleeve\", lb=0.0)\nx_casual = model.addVar(name=\"x_casual\", lb=0.0)\n\n# -----------------------------\n# Objective: maximize profit\n# -----------------------------\nmodel.setObjective(\n    profit[\"shirt\"] * x_shirt\n    + profit[\"short_sleeve\"] * x_short\n    + profit[\"casual\"] * x_casual\n    - total_fixed_cost,\n    GRB.MAXIMIZE\n)\n\n# -----------------------------\n# Constraints\n# -----------------------------\n# Labor constraint\nmodel.addConstr(\n    labor[\"shirt\"] * x_shirt\n    + labor[\"short_sleeve\"] * x_short\n    + labor[\"casual\"] * x_casual\n    <= labor_capacity,\n    name=\"Labor_Capacity\"\n)\n\n# Material constraint\nmodel.addConstr(\n    material[\"shirt\"] * x_shirt\n    + material[\"short_sleeve\"] * x_short\n    + material[\"casual\"] * x_casual\n    <= material_capacity,\n    name=\"Material_Capacity\"\n)\n\n# -----------------------------\n# Optimize\n# -----------------------------\nmodel.optimize()\n\n# -----------------------------\n# Results\n# -----------------------------\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\n    print(\"Optimal production plan:\")\n    print(f\"  Shirts: {x_shirt.X}\")\n    print(f\"  Short-sleeved shirts: {x_short.X}\")\n    print(f\"  Casual clothes: {x_casual.X}\")\nelse:\n    print(\"No optimal solution found\")", "execution_success": true, "mathematical_accuracy": true, "execution_result": "Execution Successful", "execution_best_solution": 21500.0, "execution_state": "Execution Successful"}
{"task_id": "B043", "description": "Given that there are $m=2$ production points for a certain type of material, where the output at the $i$-th point $(i=1,2)$ is $a_i$, $a_1 = 100$, and $a_2 = 150$. This material is to be shipped to $n=2$ demand points, where the demand at the $j$-th point $(j=1, 2)$ is $b_j$, $b_1 = 80$, and $b_2 = 120$. It is known that $\\sum_i a_i \\geqslant \\sum_j b_j$. It is also known that when shipping from production points to demand points, it must pass through one of the $p=2$ intermediate marshaling stations. If the $k$-th $(k=1, 2)$ intermediate marshaling station is used, a fixed cost $f_k$ is incurred regardless of the transshipment volume, where $f_1 = 10$ and $f_2 = 15$. The $k$-th intermediate marshaling station has a maximum transshipment capacity limitation $q_k$, where $q_1 = 100$ and $q_2 = 100$. Let $c_{i k}$ and $c'_{k j}$ denote the unit transportation cost from $i$ to $k$ and from $k$ to $j$, respectively, where $c_{11}=2$, $c_{12}=3$, $c_{21}=4$, $c_{22}=1$, $c'_{11}=3$, $c'_{12}=2$, $c'_{21}=1$, and $c'_{22}=4$. Try to determine a transportation plan for this material that minimizes the total cost.", "ground_truth": 685.0, "formulation": null, "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_fixed_charge_transshipment():\n    \"\"\"\n    Solves a fixed-charge transshipment problem with intermediate marshaling stations.\n    The goal is to minimize total transportation and fixed operational costs.\n    \"\"\"\n    try:\n        # --- Data ---\n        # Production points (sources)\n        production_points = [1, 2]\n        supply = {1: 100, 2: 150}  # a_i\n\n        # Demand points (sinks)\n        demand_points = [1, 2]\n        demand = {1: 80, 2: 120}  # b_j\n\n        # Marshaling stations\n        marshaling_stations = [1, 2]\n        fixed_costs = {1: 10, 2: 15}  # f_k\n        station_capacities = {1: 100, 2: 100}  # q_k\n\n        # Unit transportation costs from production i to station k (c_ik)\n        cost_ik = {(1, 1): 2, (1, 2): 3, (2, 1): 4, (2, 2): 1}\n\n        # Unit transportation costs from station k to demand j (c'_kj)\n        cost_kj = {(1, 1): 3, (1, 2): 2, (2, 1): 1, (2, 2): 4}\n\n        # --- Create Gurobi Model ---\n        model = gp.Model(\"FixedChargeTransshipment\")\n\n        # --- Decision Variables ---\n        # x[i,k]: amount shipped from production point i to marshaling station k\n        x = model.addVars(production_points,\n                          marshaling_stations,\n                          name=\"x\",\n                          lb=0.0,\n                          vtype=GRB.CONTINUOUS)\n\n        # y[k,j]: amount shipped from marshaling station k to demand point j\n        y = model.addVars(marshaling_stations,\n                          demand_points,\n                          name=\"y\",\n                          lb=0.0,\n                          vtype=GRB.CONTINUOUS)\n\n        # u[k]: 1 if marshaling station k is used, 0 otherwise\n        u = model.addVars(marshaling_stations, name=\"u\", vtype=GRB.BINARY)\n\n        # --- Objective Function: Minimize Total Cost ---\n        var_cost_ik = gp.quicksum(cost_ik[i, k] * x[i, k]\n                                  for i in production_points\n                                  for k in marshaling_stations)\n        var_cost_kj = gp.quicksum(cost_kj[k, j] * y[k, j]\n                                  for k in marshaling_stations\n                                  for j in demand_points)\n        total_fixed_cost = gp.quicksum(fixed_costs[k] * u[k]\n                                       for k in marshaling_stations)\n\n        model.setObjective(var_cost_ik + var_cost_kj + total_fixed_cost,\n                           GRB.MINIMIZE)\n\n        # --- Constraints ---\n        # 1. Supply Constraints: sum_k x[i,k] <= supply[i] for each i\n        for i in production_points:\n            model.addConstr(gp.quicksum(x[i, k] for k in marshaling_stations)\n                            <= supply[i],\n                            name=f\"Supply_{i}\")\n\n        # 2. Demand Constraints: sum_k y[k,j] == demand[j] for each j\n        for j in demand_points:\n            model.addConstr(gp.quicksum(\n                y[k, j] for k in marshaling_stations) == demand[j],\n                            name=f\"Demand_{j}\")\n\n        # 3. Flow Conservation at Marshaling Stations: sum_i x[i,k] == sum_j y[k,j] for each k\n        for k in marshaling_stations:\n            model.addConstr(gp.quicksum(\n                x[i, k] for i in production_points) == gp.quicksum(\n                    y[k, j] for j in demand_points),\n                            name=f\"FlowCons_Station_{k}\")\n\n        # 4. Marshaling Station Capacity and Usage: sum_i x[i,k] <= capacity[k] * u[k] for each k\n        for k in marshaling_stations:\n            model.addConstr(gp.quicksum(x[i, k] for i in production_points)\n                            <= station_capacities[k] * u[k],\n                            name=f\"Capacity_Station_{k}\")\n\n        # Suppress Gurobi output to console if desired\n        # model.setParam('OutputFlag', 0)\n\n        # Optimize the model\n        model.optimize()\n\n        # --- Results ---\n        if model.status == GRB.OPTIMAL:\n            print(\"Optimal transportation plan found.\")\n            print(f\"Minimum Total Cost: {model.ObjVal:.2f}\")\n\n            print(\n                \"\\nShipments from Production Points to Marshaling Stations (x_ik):\"\n            )\n            for i in production_points:\n                for k in marshaling_stations:\n                    if x[i, k].X > 1e-6:  # Print only if flow is significant\n                        print(\n                            f\"  From Production {i} to Station {k}: {x[i,k].X:.2f} units\"\n                        )\n\n            print(\n                \"\\nShipments from Marshaling Stations to Demand Points (y_kj):\"\n            )\n            for k in marshaling_stations:\n                for j in demand_points:\n                    if y[k, j].X > 1e-6:  # Print only if flow is significant\n                        print(\n                            f\"  From Station {k} to Demand {j}: {y[k,j].X:.2f} units\"\n                        )\n\n            print(\"\\nMarshaling Station Usage (u_k):\")\n            total_flow_through_station = {}\n            for k in marshaling_stations:\n                flow = sum(x[i, k].X for i in production_points)\n                total_flow_through_station[k] = flow\n                if u[k].X > 0.5:  # If station is used\n                    print(\n                        f\"  Station {k}: Used (Fixed Cost: {fixed_costs[k]}). Flow: {flow:.2f} / Capacity: {station_capacities[k]}\"\n                    )\n                else:\n                    print(f\"  Station {k}: Not Used. Flow: {flow:.2f}\")\n\n            # Verification\n            print(\"\\nVerification:\")\n            print(\"  Supply Check:\")\n            for i in production_points:\n                shipped_from_i = sum(x[i, k].X for k in marshaling_stations)\n                print(\n                    f\"    Production {i}: Shipped {shipped_from_i:.2f}, Supply {supply[i]}\"\n                )\n\n            print(\"  Demand Check:\")\n            for j in demand_points:\n                received_at_j = sum(y[k, j].X for k in marshaling_stations)\n                print(\n                    f\"    Demand {j}: Received {received_at_j:.2f}, Demand {demand[j]}\"\n                )\n\n            print(\"  Station Flow Conservation Check:\")\n            for k in marshaling_stations:\n                inflow_k = sum(x[i, k].X for i in production_points)\n                outflow_k = sum(y[k, j].X for j in demand_points)\n                print(\n                    f\"    Station {k}: Inflow={inflow_k:.2f}, Outflow={outflow_k:.2f} (Difference: {inflow_k - outflow_k:.2f})\"\n                )\n\n        elif model.status == GRB.INFEASIBLE:\n            print(\"Model is infeasible. Check constraints and parameters.\")\n            # Compute and print IIS (Irreducible Inconsistent Subsystem)\n            # model.computeIIS()\n            # model.write(\"transshipment_iis.ilp\")\n            # print(\"IIS written to transshipment_iis.ilp.\")\n        else:\n            print(f\"Optimization stopped with status: {model.status}\")\n\n    except gp.GurobiError as e:\n        print(f\"Gurobi error code {e.errno}: {e}\")\n    except Exception as e:\n        print(f\"An unexpected error occurred: {e}\")\n\n\nif __name__ == '__main__':\n    solve_fixed_charge_transshipment()", "output_status": [], "success_count": 0, "success_confidence": 0, "fail_to_diagnose": 0, "fail_to_verify": 0, "retrieved_insights": [], "tag": [{"problem_domain": "Transshipment", "modeling_type": "MILP", "industry_sector": "Logistics", "reason": "The problem involves moving goods from production points to demand points via intermediate marshaling stations, which is a classic transshipment problem. The inclusion of fixed costs for using marshaling stations and binary decision variables makes it a Mixed-Integer Linear Program (MILP), and the application is clearly within the domain of managing material flow and transportation, hence logistics."}], "cluster": null, "prompt": "Below is an operations research question. First formulate the problem as an optimization problem. Then according to the formulated problem, write python code that uses 'gurobipy' to solve the optimization problem. You should write a complete python code that can be executed to solve the optimization problem.\n\nIMPORTANT: Your code should follow these requirements:\n1. Create a Gurobi model variable named 'model' (not 'm' or other names)\n2. Include all necessary imports and data setup\n3. Write the complete optimization code that can run independently\n4. Do NOT wrap everything in a function - write the code directly\n5. Make sure the model is created and optimized in the main execution flow\n6. The code should print the optimal objective value when solved successfully\n\nExample format:\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Data setup\ndata = {...}\n\n# Create model\nmodel = gp.Model(\"ProblemName\")\n\n# Decision variables\nx = model.addVars(...)\n\n# Objective\nmodel.setObjective(...)\n\n# Constraints\nmodel.addConstr(...)\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\nelse:\n    print(\"No optimal solution found\")\n```\n\n# Question:\nGiven that there are $m=2$ production points for a certain type of material, where the output at the $i$-th point $(i=1,2)$ is $a_i$, $a_1 = 100$, and $a_2 = 150$. This material is to be shipped to $n=2$ demand points, where the demand at the $j$-th point $(j=1, 2)$ is $b_j$, $b_1 = 80$, and $b_2 = 120$. It is known that $\\sum_i a_i \\geqslant \\sum_j b_j$. It is also known that when shipping from production points to demand points, it must pass through one of the $p=2$ intermediate marshaling stations. If the $k$-th $(k=1, 2)$ intermediate marshaling station is used, a fixed cost $f_k$ is incurred regardless of the transshipment volume, where $f_1 = 10$ and $f_2 = 15$. The $k$-th intermediate marshaling station has a maximum transshipment capacity limitation $q_k$, where $q_1 = 100$ and $q_2 = 100$. Let $c_{i k}$ and $c'_{k j}$ denote the unit transportation cost from $i$ to $k$ and from $k$ to $j$, respectively, where $c_{11}=2$, $c_{12}=3$, $c_{21}=4$, $c_{22}=1$, $c'_{11}=3$, $c'_{12}=2$, $c'_{21}=1$, and $c'_{22}=4$. Try to determine a transportation plan for this material that minimizes the total cost.\n\n# Response:", "generated_output": "Below is a mathematical formulation followed by complete Python code using `gurobipy` that can be run directly.\n\n---\n\n## 1. Optimization Model Formulation\n\n**Indices**\n\n- Production points: \\( i \\in \\{1,2\\} \\)\n- Intermediate stations: \\( k \\in \\{1,2\\} \\)\n- Demand points: \\( j \\in \\{1,2\\} \\)\n\n**Parameters**\n\n- Supply at production points:  \n  \\( a_1 = 100,\\; a_2 = 150 \\)\n- Demand at demand points:  \n  \\( b_1 = 80,\\; b_2 = 120 \\)\n- Fixed cost for using intermediate station \\(k\\):  \n  \\( f_1 = 10,\\; f_2 = 15 \\)\n- Capacity of intermediate station \\(k\\):  \n  \\( q_1 = 100,\\; q_2 = 100 \\)\n- Unit transportation cost from production \\(i\\) to station \\(k\\):  \n  \\( c_{11}=2,\\; c_{12}=3,\\; c_{21}=4,\\; c_{22}=1 \\)\n- Unit transportation cost from station \\(k\\) to demand \\(j\\):  \n  \\( c'_{11}=3,\\; c'_{12}=2,\\; c'_{21}=1,\\; c'_{22}=4 \\)\n\n**Decision Variables**\n\n- \\( x_{ik} \\ge 0 \\): quantity shipped from production point \\(i\\) to station \\(k\\)\n- \\( y_{kj} \\ge 0 \\): quantity shipped from station \\(k\\) to demand point \\(j\\)\n- \\( z_k \\in \\{0,1\\} \\): 1 if station \\(k\\) is used (any positive flow), 0 otherwise\n\n**Objective**\n\nMinimize total cost (transportation + fixed station costs):\n\\[\n\\min \\sum_{i=1}^2 \\sum_{k=1}^2 c_{ik} x_{ik}\n    + \\sum_{k=1}^2 \\sum_{j=1}^2 c'_{kj} y_{kj}\n    + \\sum_{k=1}^2 f_k z_k\n\\]\n\n**Constraints**\n\n1. **Supply constraints (each production point cannot ship more than its supply):**\n\\[\n\\sum_{k=1}^2 x_{ik} \\le a_i, \\quad i=1,2\n\\]\n\n2. **Demand constraints (each demand point must receive its demand):**\n\\[\n\\sum_{k=1}^2 y_{kj} = b_j, \\quad j=1,2\n\\]\n\n3. **Flow conservation at each intermediate station (inflow = outflow):**\n\\[\n\\sum_{i=1}^2 x_{ik} = \\sum_{j=1}^2 y_{kj}, \\quad k=1,2\n\\]\n\n4. **Capacity constraints at each station (total flow through station ≤ capacity if used):**\n\\[\n\\sum_{i=1}^2 x_{ik} \\le q_k \\, z_k, \\quad k=1,2\n\\]\n\n5. **Variable domains:**\n\\[\nx_{ik} \\ge 0,\\; y_{kj} \\ge 0,\\; z_k \\in \\{0,1\\}\n\\]\n\n---\n\n## 2. Complete Python Code with Gurobi\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# -------------------------\n# Data setup\n# -------------------------\n\n# Sets\nI = [1, 2]  # production points\nK = [1, 2]  # intermediate stations\nJ = [1, 2]  # demand points\n\n# Supply at production points\na = {1: 100, 2: 150}\n\n# Demand at demand points\nb = {1: 80, 2: 120}\n\n# Fixed cost for using each intermediate station\nf = {1: 10, 2: 15}\n\n# Capacity of each intermediate station\nq = {1: 100, 2: 100}\n\n# Transportation cost from production i to station k\nc = {\n    (1, 1): 2,\n    (1, 2): 3,\n    (2, 1): 4,\n    (2, 2): 1\n}\n\n# Transportation cost from station k to demand j\ncp = {\n    (1, 1): 3,\n    (1, 2): 2,\n    (2, 1): 1,\n    (2, 2): 4\n}\n\n# -------------------------\n# Create model\n# -------------------------\n\nmodel = gp.Model(\"TwoStageTransshipmentWithFixedCosts\")\n\n# -------------------------\n# Decision variables\n# -------------------------\n\n# x[i,k]: flow from production i to station k\nx = model.addVars(I, K, name=\"x\", lb=0.0)\n\n# y[k,j]: flow from station k to demand j\ny = model.addVars(K, J, name=\"y\", lb=0.0)\n\n# z[k]: 1 if station k is used, 0 otherwise\nz = model.addVars(K, vtype=GRB.BINARY, name=\"z\")\n\n# -------------------------\n# Objective function\n# -------------------------\n\ntransport_cost_1 = gp.quicksum(c[i, k] * x[i, k] for i in I for k in K)\ntransport_cost_2 = gp.quicksum(cp[k, j] * y[k, j] for k in K for j in J)\nfixed_cost = gp.quicksum(f[k] * z[k] for k in K)\n\nmodel.setObjective(transport_cost_1 + transport_cost_2 + fixed_cost, GRB.MINIMIZE)\n\n# -------------------------\n# Constraints\n# -------------------------\n\n# 1. Supply constraints: sum_k x[i,k] <= a[i]\nfor i in I:\n    model.addConstr(gp.quicksum(x[i, k] for k in K) <= a[i], name=f\"supply_{i}\")\n\n# 2. Demand constraints: sum_k y[k,j] = b[j]\nfor j in J:\n    model.addConstr(gp.quicksum(y[k, j] for k in K) == b[j], name=f\"demand_{j}\")\n\n# 3. Flow conservation at each station: sum_i x[i,k] = sum_j y[k,j]\nfor k in K:\n    model.addConstr(\n        gp.quicksum(x[i, k] for i in I) == gp.quicksum(y[k, j] for j in J),\n        name=f\"flow_balance_{k}\"\n    )\n\n# 4. Capacity and linking constraints: sum_i x[i,k] <= q[k] * z[k]\nfor k in K:\n    model.addConstr(\n        gp.quicksum(x[i, k] for i in I) <= q[k] * z[k],\n        name=f\"capacity_{k}\"\n    )\n\n# -------------------------\n# Optimize\n# -------------------------\n\nmodel.optimize()\n\n# -------------------------\n# Results\n# -------------------------\n\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\n    # Optional: print flows and station usage\n    for i in I:\n        for k in K:\n            if x[i, k].X > 1e-6:\n                print(f\"x[{i},{k}] = {x[i, k].X}\")\n    for k in K:\n        for j in J:\n            if y[k, j].X > 1e-6:\n                print(f\"y[{k},{j}] = {y[k, j].X}\")\n    for k in K:\n        print(f\"z[{k}] = {z[k].X}\")\nelse:\n    print(\"No optimal solution found\")\n```", "extracted_code": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# -------------------------\n# Data setup\n# -------------------------\n\n# Sets\nI = [1, 2]  # production points\nK = [1, 2]  # intermediate stations\nJ = [1, 2]  # demand points\n\n# Supply at production points\na = {1: 100, 2: 150}\n\n# Demand at demand points\nb = {1: 80, 2: 120}\n\n# Fixed cost for using each intermediate station\nf = {1: 10, 2: 15}\n\n# Capacity of each intermediate station\nq = {1: 100, 2: 100}\n\n# Transportation cost from production i to station k\nc = {\n    (1, 1): 2,\n    (1, 2): 3,\n    (2, 1): 4,\n    (2, 2): 1\n}\n\n# Transportation cost from station k to demand j\ncp = {\n    (1, 1): 3,\n    (1, 2): 2,\n    (2, 1): 1,\n    (2, 2): 4\n}\n\n# -------------------------\n# Create model\n# -------------------------\n\nmodel = gp.Model(\"TwoStageTransshipmentWithFixedCosts\")\n\n# -------------------------\n# Decision variables\n# -------------------------\n\n# x[i,k]: flow from production i to station k\nx = model.addVars(I, K, name=\"x\", lb=0.0)\n\n# y[k,j]: flow from station k to demand j\ny = model.addVars(K, J, name=\"y\", lb=0.0)\n\n# z[k]: 1 if station k is used, 0 otherwise\nz = model.addVars(K, vtype=GRB.BINARY, name=\"z\")\n\n# -------------------------\n# Objective function\n# -------------------------\n\ntransport_cost_1 = gp.quicksum(c[i, k] * x[i, k] for i in I for k in K)\ntransport_cost_2 = gp.quicksum(cp[k, j] * y[k, j] for k in K for j in J)\nfixed_cost = gp.quicksum(f[k] * z[k] for k in K)\n\nmodel.setObjective(transport_cost_1 + transport_cost_2 + fixed_cost, GRB.MINIMIZE)\n\n# -------------------------\n# Constraints\n# -------------------------\n\n# 1. Supply constraints: sum_k x[i,k] <= a[i]\nfor i in I:\n    model.addConstr(gp.quicksum(x[i, k] for k in K) <= a[i], name=f\"supply_{i}\")\n\n# 2. Demand constraints: sum_k y[k,j] = b[j]\nfor j in J:\n    model.addConstr(gp.quicksum(y[k, j] for k in K) == b[j], name=f\"demand_{j}\")\n\n# 3. Flow conservation at each station: sum_i x[i,k] = sum_j y[k,j]\nfor k in K:\n    model.addConstr(\n        gp.quicksum(x[i, k] for i in I) == gp.quicksum(y[k, j] for j in J),\n        name=f\"flow_balance_{k}\"\n    )\n\n# 4. Capacity and linking constraints: sum_i x[i,k] <= q[k] * z[k]\nfor k in K:\n    model.addConstr(\n        gp.quicksum(x[i, k] for i in I) <= q[k] * z[k],\n        name=f\"capacity_{k}\"\n    )\n\n# -------------------------\n# Optimize\n# -------------------------\n\nmodel.optimize()\n\n# -------------------------\n# Results\n# -------------------------\n\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\n    # Optional: print flows and station usage\n    for i in I:\n        for k in K:\n            if x[i, k].X > 1e-6:\n                print(f\"x[{i},{k}] = {x[i, k].X}\")\n    for k in K:\n        for j in J:\n            if y[k, j].X > 1e-6:\n                print(f\"y[{k},{j}] = {y[k, j].X}\")\n    for k in K:\n        print(f\"z[{k}] = {z[k].X}\")\nelse:\n    print(\"No optimal solution found\")", "execution_success": true, "mathematical_accuracy": true, "execution_result": "Execution Successful", "execution_best_solution": 685.0, "execution_state": "Execution Successful"}
{"task_id": "B040", "description": "A person has a fund of 500,000 yuan and the following investment projects available in the next three years:\n\n(1) Investment can be made at the beginning of each year within three years, and the annual profit is 20% of the investment amount.\n\n(2) Investment is only allowed at the beginning of the first year, and can be recovered at the end of the second year, with the total principal and interest being 150% of the investment amount. However, this type of investment is limited to no more than 120,000 yuan.\n\n(3) Investment at the beginning of the second year, recoverable at the end of the second year, with the total principal and interest being 160% of the investment amount. This type of investment is limited to 150,000 yuan.\n\n(4) Investment is allowed at the beginning of the third year, recoverable in one year, with a profit of 40%, and the investment limit is 100,000 yuan.\n\nDetermine an investment plan for the person that maximizes the total principal and interest by the end of the third year.", "ground_truth": 964640.0, "formulation": null, "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_investment_problem_new_scenario():\n    \"\"\"\n    Solves the multi-period investment problem to maximize\n    the total principal and interest at the end of the third year.\n    \"\"\"\n    try:\n        # Initial capital\n        K0 = 500000.0\n\n        # Create a new model\n        model = gp.Model(\"MultiPeriodInvestment_NewScenario\")\n\n        # --- Decision Variables ---\n        # x_ij: amount invested in project i at the start of year j\n\n        # Project 1: Annual, 20% profit (return 1.2)\n        x11 = model.addVar(name=\"x11_P1_Y1\", lb=0.0,\n                           vtype=GRB.CONTINUOUS)  # P1, Start of Year 1\n        x12 = model.addVar(name=\"x12_P1_Y2\", lb=0.0,\n                           vtype=GRB.CONTINUOUS)  # P1, Start of Year 2\n        x13 = model.addVar(name=\"x13_P1_Y3\", lb=0.0,\n                           vtype=GRB.CONTINUOUS)  # P1, Start of Year 3\n\n        # Project 2: Start Y1, 2-year, 150% total return (factor 1.5), limit 120k\n        # Matures EOY2 (SOY3)\n        x21 = model.addVar(name=\"x21_P2_Y1\", lb=0.0, vtype=GRB.CONTINUOUS)\n\n        # Project 3: Start Y2, 1-year, 160% total return (factor 1.6), limit 150k\n        # Matures EOY2 (SOY3)\n        x32 = model.addVar(name=\"x32_P3_Y2\", lb=0.0, vtype=GRB.CONTINUOUS)\n\n        # Project 4: Start Y3, 1-year, 40% profit (return 1.4), limit 100k\n        # Matures EOY3\n        x43 = model.addVar(name=\"x43_P4_Y3\", lb=0.0, vtype=GRB.CONTINUOUS)\n\n        # --- Objective Function ---\n        # Maximize total principal and interest at the end of Year 3.\n        # Z = K0 + 0.2*x11 + 0.5*x21 + 0.2*x12 + 0.6*x32 + 0.2*x13 + 0.4*x43\n        objective = K0 + 0.2 * x11 + 0.5 * x21 + 0.2 * x12 + 0.6 * x32 + 0.2 * x13 + 0.4 * x43\n        model.setObjective(objective, GRB.MAXIMIZE)\n\n        # --- Constraints ---\n        # 1. Cash Availability at Start of Year 1\n        # Investments_SOY1 <= K0\n        model.addConstr(x11 + x21 <= K0, \"Cash_SOY1\")\n\n        # 2. Cash Availability at Start of Year 2\n        # Investments_SOY2 <= K0 + 0.2*x11 - x21\n        # x12 + x32 - 0.2*x11 + x21 <= K0\n        model.addConstr(x12 + x32 - 0.2 * x11 + x21 <= K0, \"Cash_SOY2\")\n\n        # 3. Cash Availability at Start of Year 3\n        # Investments_SOY3 <= K0 + 0.2*x11 + 0.5*x21 + 0.2*x12 + 0.6*x32\n        # x13 + x43 - 0.2*x11 - 0.5*x21 - 0.2*x12 - 0.6*x32 <= K0\n        model.addConstr(\n            x13 + x43 - 0.2 * x11 - 0.5 * x21 - 0.2 * x12 - 0.6 * x32 <= K0,\n            \"Cash_SOY3\")\n\n        # 4. Investment Limit for Project 2\n        model.addConstr(x21 <= 120000, \"Limit_P2\")\n\n        # 5. Investment Limit for Project 3\n        model.addConstr(x32 <= 150000, \"Limit_P3\")\n\n        # 6. Investment Limit for Project 4\n        model.addConstr(x43 <= 100000, \"Limit_P4\")\n\n        # Suppress Gurobi output to console\n        model.setParam('OutputFlag', 0)\n\n        # Optimize the model\n        model.optimize()\n\n        # --- Results ---\n        if model.status == GRB.OPTIMAL:\n            print(\"Optimal investment plan found.\")\n            print(\n                f\"Maximum Principal and Interest at End of Year 3: {model.objVal:.2f} yuan\"\n            )\n\n            total_profit = model.objVal - K0\n            print(f\"Total Profit over 3 years: {total_profit:.2f} yuan\")\n\n            print(\"\\nInvestment Plan Details (yuan):\")\n            # Start of Year 1\n            print(\"  Start of Year 1:\")\n            print(f\"    Project 1 (Annual, 20% profit, x11): {x11.X:.2f}\")\n            print(\n                f\"    Project 2 (2-year, 150% return, limit 120k, x21): {x21.X:.2f}\"\n            )\n            cash_soy1_invested = x11.X + x21.X\n            cash_soy1_uninvested = K0 - cash_soy1_invested\n            print(f\"    Total invested at SOY1: {cash_soy1_invested:.2f}\")\n            print(\n                f\"    Uninvested cash carried from SOY1: {cash_soy1_uninvested:.2f}\"\n            )\n\n            # Start of Year 2\n            cash_available_soy2 = K0 + 0.2 * x11.X - x21.X\n            print(\n                f\"\\n  Cash available at Start of Year 2: {cash_available_soy2:.2f}\"\n            )\n            print(\"  Start of Year 2:\")\n            print(f\"    Project 1 (Annual, 20% profit, x12): {x12.X:.2f}\")\n            print(\n                f\"    Project 3 (1-year, 160% return, limit 150k, x32): {x32.X:.2f}\"\n            )\n            cash_soy2_invested = x12.X + x32.X\n            cash_soy2_uninvested = cash_available_soy2 - cash_soy2_invested\n            print(f\"    Total invested at SOY2: {cash_soy2_invested:.2f}\")\n            print(\n                f\"    Uninvested cash carried from SOY2: {cash_soy2_uninvested:.2f}\"\n            )\n\n            # Start of Year 3\n            cash_available_soy3 = K0 + 0.2 * x11.X + 0.5 * x21.X + 0.2 * x12.X + 0.6 * x32.X\n            print(\n                f\"\\n  Cash available at Start of Year 3: {cash_available_soy3:.2f}\"\n            )\n            print(\"  Start of Year 3:\")\n            print(f\"    Project 1 (Annual, 20% profit, x13): {x13.X:.2f}\")\n            print(\n                f\"    Project 4 (1-year, 40% profit, limit 100k, x43): {x43.X:.2f}\"\n            )\n            cash_soy3_invested = x13.X + x43.X\n            cash_soy3_uninvested = cash_available_soy3 - cash_soy3_invested\n            print(f\"    Total invested at SOY3: {cash_soy3_invested:.2f}\")\n            print(\n                f\"    Uninvested cash from SOY3 (forms part of EOY3 total): {cash_soy3_uninvested:.2f}\"\n            )\n\n        else:\n            print(\"No optimal solution found. Status code:\", model.status)\n\n    except gp.GurobiError as e:\n        print(f\"Error code {e.errno}: {e}\")\n    except AttributeError:\n        print(\n            \"Encountered an attribute error. Gurobi might not be installed or licensed correctly.\"\n        )\n    except Exception as e:\n        print(f\"An unexpected error occurred: {e}\")\n\n\nif __name__ == '__main__':\n    solve_investment_problem_new_scenario()", "output_status": [], "success_count": 0, "success_confidence": 0, "fail_to_diagnose": 0, "fail_to_verify": 0, "retrieved_insights": [], "tag": [{"problem_domain": "Resource Allocation", "modeling_type": "LP", "industry_sector": "Finance", "reason": "The problem involves allocating a limited fund across various investment projects over multiple time periods to maximize total returns, which is a classic resource allocation problem. The solver uses continuous variables and linear constraints and objective function, making it a Linear Program. The context of funds, investments, and profits clearly places it within the finance sector."}], "cluster": null, "prompt": "Below is an operations research question. First formulate the problem as an optimization problem. Then according to the formulated problem, write python code that uses 'gurobipy' to solve the optimization problem. You should write a complete python code that can be executed to solve the optimization problem.\n\nIMPORTANT: Your code should follow these requirements:\n1. Create a Gurobi model variable named 'model' (not 'm' or other names)\n2. Include all necessary imports and data setup\n3. Write the complete optimization code that can run independently\n4. Do NOT wrap everything in a function - write the code directly\n5. Make sure the model is created and optimized in the main execution flow\n6. The code should print the optimal objective value when solved successfully\n\nExample format:\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Data setup\ndata = {...}\n\n# Create model\nmodel = gp.Model(\"ProblemName\")\n\n# Decision variables\nx = model.addVars(...)\n\n# Objective\nmodel.setObjective(...)\n\n# Constraints\nmodel.addConstr(...)\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\nelse:\n    print(\"No optimal solution found\")\n```\n\n# Question:\nA person has a fund of 500,000 yuan and the following investment projects available in the next three years:\n\n(1) Investment can be made at the beginning of each year within three years, and the annual profit is 20% of the investment amount.\n\n(2) Investment is only allowed at the beginning of the first year, and can be recovered at the end of the second year, with the total principal and interest being 150% of the investment amount. However, this type of investment is limited to no more than 120,000 yuan.\n\n(3) Investment at the beginning of the second year, recoverable at the end of the second year, with the total principal and interest being 160% of the investment amount. This type of investment is limited to 150,000 yuan.\n\n(4) Investment is allowed at the beginning of the third year, recoverable in one year, with a profit of 40%, and the investment limit is 100,000 yuan.\n\nDetermine an investment plan for the person that maximizes the total principal and interest by the end of the third year.\n\n# Response:", "generated_output": "Below is a formulation and then complete Python code using `gurobipy` that can be run directly.\n\n---\n\n## 1. Optimization model formulation\n\n### Decision variables\nLet:\n\n- \\(x_{1}, x_{2}, x_{3} \\ge 0\\): amount invested in project (1) at the beginning of years 1, 2, and 3, respectively.\n- \\(y \\ge 0\\): amount invested in project (2) at the beginning of year 1.\n- \\(z \\ge 0\\): amount invested in project (3) at the beginning of year 2.\n- \\(w \\ge 0\\): amount invested in project (4) at the beginning of year 3.\n\nAll amounts are in yuan.\n\n### Returns\n\n- Project (1): invest at beginning of year \\(t\\), get back \\(1.2\\) times the investment at the end of that same year.\n- Project (2): invest at beginning of year 1, get back \\(1.5y\\) at end of year 2.\n- Project (3): invest at beginning of year 2, get back \\(1.6z\\) at end of year 2.\n- Project (4): invest at beginning of year 3, get back \\(1.4w\\) at end of year 3.\n\n### Cash-flow constraints\n\nInitial fund at beginning of year 1: 500,000.\n\n1. **Beginning of Year 1 (t = 1)**  \n   Total investment cannot exceed initial fund:\n   \\[\n   x_1 + y \\le 500000\n   \\]\n   Also project (2) limit:\n   \\[\n   y \\le 120000\n   \\]\n\n2. **Beginning of Year 2 (t = 2)**  \n   Available cash at beginning of year 2 is the amount returned from year-1 project (1):\n   \\[\n   \\text{Cash at start of year 2} = 1.2 x_1\n   \\]\n   This must cover investments in project (1) and (3) in year 2:\n   \\[\n   x_2 + z \\le 1.2 x_1\n   \\]\n   Project (3) limit:\n   \\[\n   z \\le 150000\n   \\]\n\n3. **Beginning of Year 3 (t = 3)**  \n   Cash at beginning of year 3 comes from:\n   - Project (1) in year 2: \\(1.2 x_2\\)\n   - Project (2): \\(1.5 y\\) (pays at end of year 2)\n   - Project (3): \\(1.6 z\\) (pays at end of year 2)\n   So:\n   \\[\n   \\text{Cash at start of year 3} = 1.2 x_2 + 1.5 y + 1.6 z\n   \\]\n   This must cover investments in project (1) and (4) in year 3:\n   \\[\n   x_3 + w \\le 1.2 x_2 + 1.5 y + 1.6 z\n   \\]\n   Project (4) limit:\n   \\[\n   w \\le 100000\n   \\]\n\n4. **End of Year 3 (objective)**  \n   Total principal + interest at end of year 3:\n   - From project (1): \\(1.2 x_3\\) (year 3 investment)\n   - From project (4): \\(1.4 w\\)\n   There is no further compounding beyond year 3 for earlier projects; their proceeds were already reinvested or held as cash and are captured via the constraints. Thus the final wealth is:\n   \\[\n   \\text{Final wealth} = 1.2 x_3 + 1.4 w\n   \\]\n\n### Objective\nMaximize final wealth at the end of year 3:\n\\[\n\\max \\; 1.2 x_3 + 1.4 w\n\\]\n\n### Non-negativity\n\\[\nx_1, x_2, x_3, y, z, w \\ge 0\n\\]\n\n---\n\n## 2. Complete Python code with Gurobi\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Create model\nmodel = gp.Model(\"ThreeYearInvestmentPlanning\")\n\n# Decision variables (all continuous and non-negative)\nx1 = model.addVar(name=\"x1\", lb=0.0)  # Project (1) at beginning of year 1\nx2 = model.addVar(name=\"x2\", lb=0.0)  # Project (1) at beginning of year 2\nx3 = model.addVar(name=\"x3\", lb=0.0)  # Project (1) at beginning of year 3\ny  = model.addVar(name=\"y\",  lb=0.0)  # Project (2) at beginning of year 1\nz  = model.addVar(name=\"z\",  lb=0.0)  # Project (3) at beginning of year 2\nw  = model.addVar(name=\"w\",  lb=0.0)  # Project (4) at beginning of year 3\n\n# Initial fund\ninitial_fund = 500000.0\n\n# Constraints\n\n# Year 1: investments in project (1) and (2) cannot exceed initial fund\nmodel.addConstr(x1 + y <= initial_fund, name=\"Year1_budget\")\n\n# Project (2) limit\nmodel.addConstr(y <= 120000.0, name=\"Proj2_limit\")\n\n# Year 2: investments in project (1) and (3) cannot exceed returns from year-1 project (1)\n# Cash at start of year 2 = 1.2 * x1\nmodel.addConstr(x2 + z <= 1.2 * x1, name=\"Year2_budget\")\n\n# Project (3) limit\nmodel.addConstr(z <= 150000.0, name=\"Proj3_limit\")\n\n# Year 3: investments in project (1) and (4) cannot exceed cash available\n# Cash at start of year 3 = 1.2 * x2 + 1.5 * y + 1.6 * z\nmodel.addConstr(x3 + w <= 1.2 * x2 + 1.5 * y + 1.6 * z, name=\"Year3_budget\")\n\n# Project (4) limit\nmodel.addConstr(w <= 100000.0, name=\"Proj4_limit\")\n\n# Objective: maximize total principal + interest at end of year 3\n# Returns at end of year 3: 1.2 * x3 from project (1) in year 3, and 1.4 * w from project (4)\nmodel.setObjective(1.2 * x3 + 1.4 * w, GRB.MAXIMIZE)\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\n    print(\"Optimal decisions:\")\n    print(f\"  x1 (Proj1, year1) = {x1.X:.2f}\")\n    print(f\"  x2 (Proj1, year2) = {x2.X:.2f}\")\n    print(f\"  x3 (Proj1, year3) = {x3.X:.2f}\")\n    print(f\"  y  (Proj2, year1) = {y.X:.2f}\")\n    print(f\"  z  (Proj3, year2) = {z.X:.2f}\")\n    print(f\"  w  (Proj4, year3) = {w.X:.2f}\")\nelse:\n    print(\"No optimal solution found\")\n```", "extracted_code": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create model\nmodel = gp.Model(\"ThreeYearInvestmentPlanning\")\n\n# Decision variables (all continuous and non-negative)\nx1 = model.addVar(name=\"x1\", lb=0.0)  # Project (1) at beginning of year 1\nx2 = model.addVar(name=\"x2\", lb=0.0)  # Project (1) at beginning of year 2\nx3 = model.addVar(name=\"x3\", lb=0.0)  # Project (1) at beginning of year 3\ny  = model.addVar(name=\"y\",  lb=0.0)  # Project (2) at beginning of year 1\nz  = model.addVar(name=\"z\",  lb=0.0)  # Project (3) at beginning of year 2\nw  = model.addVar(name=\"w\",  lb=0.0)  # Project (4) at beginning of year 3\n\n# Initial fund\ninitial_fund = 500000.0\n\n# Constraints\n\n# Year 1: investments in project (1) and (2) cannot exceed initial fund\nmodel.addConstr(x1 + y <= initial_fund, name=\"Year1_budget\")\n\n# Project (2) limit\nmodel.addConstr(y <= 120000.0, name=\"Proj2_limit\")\n\n# Year 2: investments in project (1) and (3) cannot exceed returns from year-1 project (1)\n# Cash at start of year 2 = 1.2 * x1\nmodel.addConstr(x2 + z <= 1.2 * x1, name=\"Year2_budget\")\n\n# Project (3) limit\nmodel.addConstr(z <= 150000.0, name=\"Proj3_limit\")\n\n# Year 3: investments in project (1) and (4) cannot exceed cash available\n# Cash at start of year 3 = 1.2 * x2 + 1.5 * y + 1.6 * z\nmodel.addConstr(x3 + w <= 1.2 * x2 + 1.5 * y + 1.6 * z, name=\"Year3_budget\")\n\n# Project (4) limit\nmodel.addConstr(w <= 100000.0, name=\"Proj4_limit\")\n\n# Objective: maximize total principal + interest at end of year 3\n# Returns at end of year 3: 1.2 * x3 from project (1) in year 3, and 1.4 * w from project (4)\nmodel.setObjective(1.2 * x3 + 1.4 * w, GRB.MAXIMIZE)\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\n    print(\"Optimal decisions:\")\n    print(f\"  x1 (Proj1, year1) = {x1.X:.2f}\")\n    print(f\"  x2 (Proj1, year2) = {x2.X:.2f}\")\n    print(f\"  x3 (Proj1, year3) = {x3.X:.2f}\")\n    print(f\"  y  (Proj2, year1) = {y.X:.2f}\")\n    print(f\"  z  (Proj3, year2) = {z.X:.2f}\")\n    print(f\"  w  (Proj4, year3) = {w.X:.2f}\")\nelse:\n    print(\"No optimal solution found\")", "execution_success": true, "mathematical_accuracy": true, "execution_result": "Execution Successful", "execution_best_solution": 964640.0, "execution_state": "Execution Successful"}
{"task_id": "B005", "description": "The contract reservations for the next year for products I, II, and III of a certain factory in each quarter are shown in Table 1-10.\n\nTable 1-10\n| Product | 1    | 2    | 3    | 4    |\n|---------|------|------|------|------|\n| I       | 1500 | 1000 | 2000 | 1200 |\n| II      | 1500 | 1500 | 1200 | 1500 |\n| III     | 1000 | 2000 | 1500 | 2500 |\n\nAt the beginning of the first quarter, there is no inventory for these three products, and it is required to have 150 units in stock for each product by the end of the fourth quarter. It is known that the factory has 15,000 production hours per quarter, and each unit of products I, II, and III requires 2, 4, and 3 hours respectively. Due to a change in equipment, product I cannot be produced in the second quarter. It is stipulated that if the products cannot be delivered on time, a compensation of 20 yuan per unit per quarter delay is required for products I and II, while for product III, the compensation is 10 yuan. Additionally, for products produced but not delivered in the current quarter, the inventory cost is 5 yuan per unit per quarter. How should the factory schedule production to minimize the total cost of compensation and inventory?", "ground_truth": 10755.0, "formulation": null, "correct_program": "from gurobipy import Model, GRB, quicksum\n\n\ndef solve_factory_scheduling():\n    # --- 模型初始化 ---\n    model = Model(\"FactoryProductionScheduling\")\n\n    # --- 集合定义 ---\n    products = [\"I\", \"II\", \"III\"]\n    quarters = list(range(4))  # 0: Q1, 1: Q2, 2: Q3, 3: Q4\n\n    # --- 参数定义 ---\n    demand = {\n        (\"I\", 0): 1500,\n        (\"I\", 1): 1000,\n        (\"I\", 2): 2000,\n        (\"I\", 3): 1200,\n        (\"II\", 0): 1500,\n        (\"II\", 1): 1500,\n        (\"II\", 2): 1200,\n        (\"II\", 3): 1500,\n        (\"III\", 0): 1000,\n        (\"III\", 1): 2000,\n        (\"III\", 2): 1500,\n        (\"III\", 3): 2500,\n    }\n\n    initial_inventory = {prod: 0 for prod in products}  # 期初库存\n    ending_inventory_target = {prod: 150 for prod in products}  # 第四季度末库存目标\n\n    production_hours_per_quarter = 15000  # 每季度可用生产工时\n\n    hours_per_unit = {  # 每单位产品所需工时\n        \"I\": 2,\n        \"II\": 4,\n        \"III\": 3,\n    }\n\n    # 产品I在第二季度 (索引1) 不能生产\n    production_restriction_product = \"I\"\n    production_restriction_quarter = 1\n\n    backlog_cost_per_unit_per_quarter = { # 单位产品每季度延期赔偿\n        \"I\": 20,\n        \"II\": 20,\n        \"III\": 10,\n    }\n\n    inventory_cost_per_unit_per_quarter = 5  # 单位产品每季度库存成本\n\n    # --- 决策变量 ---\n    # P[p, q]: 在季度q生产产品p的数量\n    P = model.addVars(products,\n                      quarters,\n                      name=\"Production\",\n                    #   vtype=GRB.CONTINUOUS,\n                      vtype=GRB.INTEGER,\n                      lb=0)\n    # I[p, q]: 在季度q末产品p的库存量\n    I = model.addVars(products,\n                      quarters,\n                      name=\"Inventory\",\n                    #   vtype=GRB.CONTINUOUS,\n                      vtype=GRB.INTEGER,\n                      lb=0)\n    # B[p, q]: 在季度q末产品p的积压订单量\n    B = model.addVars(products,\n                      quarters,\n                      name=\"Backlog\",\n                    #   vtype=GRB.CONTINUOUS,\n                      vtype=GRB.INTEGER,\n                      lb=0)\n\n    # --- 目标函数: 最小化总成本 (赔偿成本 + 库存成本) ---\n    total_backlog_cost = quicksum(\n        B[p, q] * backlog_cost_per_unit_per_quarter[p] for p in products\n        for q in quarters)\n    total_inventory_cost = quicksum(\n        I[p, q] * inventory_cost_per_unit_per_quarter for p in products\n        for q in quarters)\n\n    model.setObjective(total_backlog_cost + total_inventory_cost, GRB.MINIMIZE)\n\n    # --- 约束条件 ---\n    for q in quarters:\n        # 1. 生产能力约束 (每季度总工时)\n        model.addConstr(quicksum(P[p, q] * hours_per_unit[p] for p in products)\n                        <= production_hours_per_quarter,\n                        name=f\"Capacity_Q{q+1}\")\n\n        for p in products:\n            # 2. 库存平衡约束\n            # 期初库存 (I_prev) + 本期生产 (P) - 本期需求 (D) = 期末库存 (I_curr) - 期末积压 (B_curr)\n            # I_prev - B_prev + P = D + I_curr - B_curr (如果B代表的是净效应)\n            # 我们使用: I[p,q-1] + P[p,q] - Demand[p,q] = I[p,q] - B[p,q]\n            # 这意味着 I[p,q] 和 B[p,q] 中至少一个为0 (或模型会趋向于此以最小化成本)\n\n            inventory_at_start_of_quarter = I[\n                p, q - 1] if q > 0 else initial_inventory[p]\n            # 积压订单是上期末的，本期需要优先满足\n            # 修正库存平衡方程：\n            # (上期末库存 - 上期末积压) + 本期生产 - 本期需求 = (本期末库存 - 本期末积压)\n            # I[p, q-1] - B[p, q-1] + P[p,q] - D[p,q] = I[p,q] - B[p,q]\n            # 整理为： I[p,q-1] + P[p,q] + B[p,q] = D[p,q] + I[p,q] + B[p,q-1]\n            # 这个形式更标准，表示 (可供量) + (新欠货) = (需求) + (结转库存) + (已满足的旧欠货或继续欠)\n\n            backlog_at_start_of_quarter = B[p, q - 1] if q > 0 else 0  # 初始无积压\n\n            model.addConstr(inventory_at_start_of_quarter + P[p, q] +\n                            B[p, q] == demand[p, q] + I[p, q] +\n                            backlog_at_start_of_quarter,\n                            name=f\"InventoryBalance_{p}_Q{q+1}\")\n\n    # 3. 特定生产限制: 产品I在第二季度 (索引1) 不能生产\n    model.addConstr(\n        P[production_restriction_product, production_restriction_quarter] == 0,\n        name=\n        f\"NoProduction_{production_restriction_product}_Q{production_restriction_quarter+1}\"\n    )\n\n    # 4. 期末库存要求: 第四季度末 (索引3)\n    for p in products:\n        model.addConstr(I[p, quarters[-1]] >= ending_inventory_target[p],\n                        name=f\"EndingInventory_{p}\")\n        # 确保第四季度末没有积压订单，虽然目标函数会尝试最小化积压，但这里可以明确要求\n        # 如果允许第四季度末有积压，则不需要此约束。题目未明确禁止，但通常目标是清零。\n        # 考虑到有期末库存目标，清零积压是合理的。\n        model.addConstr(B[p, quarters[-1]] == 0, name=f\"EndingBacklogZero_{p}\")\n\n    # --- 模型求解 ---\n    model.optimize()\n\n    # --- 打印结果 ---\n    if model.status == GRB.OPTIMAL:\n        print(f\"\\n找到最优生产计划! 最小总成本: {model.objVal:,.2f} 元\")\n        print(\"-\" * 100)\n        print(\n            f\"{'产品':<5} | {'季度':<5} | {'生产量':>10} | {'期末库存':>10} | {'期末积压':>10} | {'需求量':>10}\"\n        )\n        print(\"=\" * 100)\n        for q in quarters:\n            for p in products:\n                print(\n                    f\"{p:<5} | {q+1:<5} | {P[p,q].X:>10.1f} | {I[p,q].X:>10.1f} | {B[p,q].X:>10.1f} | {demand[p,q]:>10}\"\n                )\n            print(\"-\" * 100)\n\n        print(\"\\n成本构成:\")\n        calc_total_backlog_cost = sum(\n            B[p, q].X * backlog_cost_per_unit_per_quarter[p] for p in products\n            for q in quarters)\n        calc_total_inventory_cost = sum(\n            I[p, q].X * inventory_cost_per_unit_per_quarter for p in products\n            for q in quarters)\n        print(f\"  总延期赔偿成本: {calc_total_backlog_cost:,.2f} 元\")\n        print(f\"  总库存持有成本: {calc_total_inventory_cost:,.2f} 元\")\n        print(\n            f\"  计算得到的总成本: {calc_total_backlog_cost + calc_total_inventory_cost:,.2f} 元\"\n        )\n\n    elif model.status == GRB.INFEASIBLE:\n        print(\"模型不可行。请检查约束条件是否相互冲突。\")\n        print(\"正在计算不可行子系统 (IIS) 来帮助定位问题...\")\n        model.computeIIS()\n        model.write(\"factory_scheduling_iis.ilp\")\n        print(\"IIS 已写入 factory_scheduling_iis.ilp 文件。\")\n    elif model.status == GRB.UNBOUNDED:\n        print(\"模型无界。目标函数可以无限减小。\")\n    else:\n        print(f\"优化过程因状态码 {model.status} 而停止。\")\n\n\nif __name__ == '__main__':\n    solve_factory_scheduling()", "output_status": [], "success_count": 0, "success_confidence": 0, "fail_to_diagnose": 0, "fail_to_verify": 0, "retrieved_insights": [], "tag": [{"problem_domain": "Production Planning", "modeling_type": "MILP", "industry_sector": "Manufacturing", "reason": "The problem involves determining optimal production quantities for multiple products over several time periods to meet demand while minimizing costs (inventory and backlog), subject to capacity and specific production constraints. This is a classic Production Planning problem. The solver uses integer variables for production, inventory, and backlog, and linear constraints and objective function, making it a Mixed-Integer Linear Program (MILP). The context of a factory producing products falls under the Manufacturing sector."}], "cluster": null, "prompt": "Below is an operations research question. First formulate the problem as an optimization problem. Then according to the formulated problem, write python code that uses 'gurobipy' to solve the optimization problem. You should write a complete python code that can be executed to solve the optimization problem.\n\nIMPORTANT: Your code should follow these requirements:\n1. Create a Gurobi model variable named 'model' (not 'm' or other names)\n2. Include all necessary imports and data setup\n3. Write the complete optimization code that can run independently\n4. Do NOT wrap everything in a function - write the code directly\n5. Make sure the model is created and optimized in the main execution flow\n6. The code should print the optimal objective value when solved successfully\n\nExample format:\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Data setup\ndata = {...}\n\n# Create model\nmodel = gp.Model(\"ProblemName\")\n\n# Decision variables\nx = model.addVars(...)\n\n# Objective\nmodel.setObjective(...)\n\n# Constraints\nmodel.addConstr(...)\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\nelse:\n    print(\"No optimal solution found\")\n```\n\n# Question:\nThe contract reservations for the next year for products I, II, and III of a certain factory in each quarter are shown in Table 1-10.\n\nTable 1-10\n| Product | 1    | 2    | 3    | 4    |\n|---------|------|------|------|------|\n| I       | 1500 | 1000 | 2000 | 1200 |\n| II      | 1500 | 1500 | 1200 | 1500 |\n| III     | 1000 | 2000 | 1500 | 2500 |\n\nAt the beginning of the first quarter, there is no inventory for these three products, and it is required to have 150 units in stock for each product by the end of the fourth quarter. It is known that the factory has 15,000 production hours per quarter, and each unit of products I, II, and III requires 2, 4, and 3 hours respectively. Due to a change in equipment, product I cannot be produced in the second quarter. It is stipulated that if the products cannot be delivered on time, a compensation of 20 yuan per unit per quarter delay is required for products I and II, while for product III, the compensation is 10 yuan. Additionally, for products produced but not delivered in the current quarter, the inventory cost is 5 yuan per unit per quarter. How should the factory schedule production to minimize the total cost of compensation and inventory?\n\n# Response:", "generated_output": "Below is a clear formulation and then a complete Gurobi Python code that can be run as-is.\n\n---\n\n## 1. Optimization Model Formulation\n\n### Indices\n- Products: \\( p \\in \\{1,2,3\\} \\) (I, II, III)\n- Quarters: \\( t \\in \\{1,2,3,4\\} \\)\n\n### Parameters\n\nDemand (contract reservations) \\( d_{p,t} \\):\n\n\\[\n\\begin{array}{c|cccc}\n\\text{Product} & t=1 & t=2 & t=3 & t=4 \\\\\n\\hline\n1 & 1500 & 1000 & 2000 & 1200 \\\\\n2 & 1500 & 1500 & 1200 & 1500 \\\\\n3 & 1000 & 2000 & 1500 & 2500 \\\\\n\\end{array}\n\\]\n\n- Required ending inventory: \\( I_{p,4} \\ge 150 \\) for each product \\(p\\).\n- Initial inventory: \\( I_{p,0} = 0 \\) for all \\(p\\).\n- Production hours per quarter: \\( H = 15000 \\).\n- Processing time per unit:\n  - \\( h_1 = 2 \\) hours/unit (product I)\n  - \\( h_2 = 4 \\) hours/unit (product II)\n  - \\( h_3 = 3 \\) hours/unit (product III)\n- Penalty cost per unit per quarter of delay:\n  - \\( c^{\\text{late}}_1 = 20 \\)\n  - \\( c^{\\text{late}}_2 = 20 \\)\n  - \\( c^{\\text{late}}_3 = 10 \\)\n- Inventory holding cost per unit per quarter: \\( c^{\\text{inv}} = 5 \\).\n- Product I cannot be produced in quarter 2.\n\n### Decision Variables\n\nFor each product \\(p\\) and quarter \\(t\\):\n\n- \\( x_{p,t} \\ge 0 \\): units of product \\(p\\) produced in quarter \\(t\\).\n- \\( I_{p,t} \\ge 0 \\): inventory of product \\(p\\) at the end of quarter \\(t\\).\n- \\( L_{p,t} \\ge 0 \\): backlog (undelivered demand) of product \\(p\\) at the end of quarter \\(t\\).\n\nBacklog represents cumulative unmet demand up to quarter \\(t\\). Each unit in backlog in a quarter incurs the per-quarter delay penalty.\n\n### Constraints\n\n1. **Inventory–backlog balance (demand satisfaction over time)**  \n   For each product \\(p\\) and quarter \\(t\\):\n   \\[\n   I_{p,t} - L_{p,t} = I_{p,t-1} - L_{p,t-1} + x_{p,t} - d_{p,t}\n   \\]\n   with \\( I_{p,0} = 0, L_{p,0} = 0 \\).\n\n2. **Production capacity per quarter**  \n   For each quarter \\(t\\):\n   \\[\n   2x_{1,t} + 4x_{2,t} + 3x_{3,t} \\le 15000\n   \\]\n\n3. **No production of product I in quarter 2**  \n   \\[\n   x_{1,2} = 0\n   \\]\n\n4. **Ending inventory requirement**  \n   For each product \\(p\\):\n   \\[\n   I_{p,4} \\ge 150\n   \\]\n\n5. **Non-negativity**  \n   \\[\n   x_{p,t} \\ge 0,\\quad I_{p,t} \\ge 0,\\quad L_{p,t} \\ge 0\n   \\]\n\n### Objective Function\n\nMinimize total cost = inventory holding cost + delay penalty cost:\n\n\\[\n\\min \\sum_{p=1}^3 \\sum_{t=1}^4 \\left( 5 \\cdot I_{p,t} + c^{\\text{late}}_p \\cdot L_{p,t} \\right)\n\\]\n\n---\n\n## 2. Complete Gurobi Python Code\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# -------------------------\n# Data setup\n# -------------------------\n\nproducts = [1, 2, 3]  # I, II, III\nquarters = [1, 2, 3, 4]\n\n# Demand d[p][t]\ndemand = {\n    1: {1: 1500, 2: 1000, 3: 2000, 4: 1200},  # Product I\n    2: {1: 1500, 2: 1500, 3: 1200, 4: 1500},  # Product II\n    3: {1: 1000, 2: 2000, 3: 1500, 4: 2500},  # Product III\n}\n\n# Processing hours per unit\nproc_time = {\n    1: 2,  # Product I\n    2: 4,  # Product II\n    3: 3,  # Product III\n}\n\n# Penalty cost per unit per quarter of delay\nlate_cost = {\n    1: 20,  # Product I\n    2: 20,  # Product II\n    3: 10,  # Product III\n}\n\n# Inventory holding cost per unit per quarter\ninv_cost = 5\n\n# Production hours available per quarter\ncapacity = 15000\n\n# Required ending inventory at end of quarter 4\nrequired_ending_inventory = 150\n\n# -------------------------\n# Create model\n# -------------------------\n\nmodel = gp.Model(\"Production_Planning_MinCost\")\n\n# -------------------------\n# Decision variables\n# -------------------------\n\n# x[p,t]: production quantity of product p in quarter t\nx = model.addVars(products, quarters, name=\"x\", lb=0)\n\n# I[p,t]: inventory of product p at end of quarter t\nI = model.addVars(products, quarters, name=\"I\", lb=0)\n\n# L[p,t]: backlog (undelivered demand) of product p at end of quarter t\nL = model.addVars(products, quarters, name=\"L\", lb=0)\n\n# -------------------------\n# Constraints\n# -------------------------\n\n# 1. Inventory-backlog balance constraints\nfor p in products:\n    # Initial conditions: I[p,0] = 0, L[p,0] = 0 (handled explicitly in first period)\n    for t in quarters:\n        if t == 1:\n            # I[p,1] - L[p,1] = 0 - 0 + x[p,1] - d[p,1]\n            model.addConstr(\n                I[p,1] - L[p,1] == x[p,1] - demand[p][1],\n                name=f\"balance_p{p}_t{t}\"\n            )\n        else:\n            # I[p,t] - L[p,t] = I[p,t-1] - L[p,t-1] + x[p,t] - d[p,t]\n            model.addConstr(\n                I[p,t] - L[p,t] == I[p,t-1] - L[p,t-1] + x[p,t] - demand[p][t],\n                name=f\"balance_p{p}_t{t}\"\n            )\n\n# 2. Production capacity constraints per quarter\nfor t in quarters:\n    model.addConstr(\n        gp.quicksum(proc_time[p] * x[p, t] for p in products) <= capacity,\n        name=f\"capacity_t{t}\"\n    )\n\n# 3. No production of product I in quarter 2\nmodel.addConstr(x[1, 2] == 0, name=\"no_prod_I_q2\")\n\n# 4. Ending inventory requirement at end of quarter 4\nfor p in products:\n    model.addConstr(\n        I[p, 4] >= required_ending_inventory,\n        name=f\"ending_inventory_p{p}\"\n    )\n\n# -------------------------\n# Objective: Minimize total cost\n# -------------------------\n\nobj = gp.quicksum(\n    inv_cost * I[p, t] + late_cost[p] * L[p, t]\n    for p in products\n    for t in quarters\n)\n\nmodel.setObjective(obj, GRB.MINIMIZE)\n\n# -------------------------\n# Optimize\n# -------------------------\n\nmodel.optimize()\n\n# -------------------------\n# Results\n# -------------------------\n\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\nelse:\n    print(\"No optimal solution found\")\n```", "extracted_code": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# -------------------------\n# Data setup\n# -------------------------\n\nproducts = [1, 2, 3]  # I, II, III\nquarters = [1, 2, 3, 4]\n\n# Demand d[p][t]\ndemand = {\n    1: {1: 1500, 2: 1000, 3: 2000, 4: 1200},  # Product I\n    2: {1: 1500, 2: 1500, 3: 1200, 4: 1500},  # Product II\n    3: {1: 1000, 2: 2000, 3: 1500, 4: 2500},  # Product III\n}\n\n# Processing hours per unit\nproc_time = {\n    1: 2,  # Product I\n    2: 4,  # Product II\n    3: 3,  # Product III\n}\n\n# Penalty cost per unit per quarter of delay\nlate_cost = {\n    1: 20,  # Product I\n    2: 20,  # Product II\n    3: 10,  # Product III\n}\n\n# Inventory holding cost per unit per quarter\ninv_cost = 5\n\n# Production hours available per quarter\ncapacity = 15000\n\n# Required ending inventory at end of quarter 4\nrequired_ending_inventory = 150\n\n# -------------------------\n# Create model\n# -------------------------\n\nmodel = gp.Model(\"Production_Planning_MinCost\")\n\n# -------------------------\n# Decision variables\n# -------------------------\n\n# x[p,t]: production quantity of product p in quarter t\nx = model.addVars(products, quarters, name=\"x\", lb=0)\n\n# I[p,t]: inventory of product p at end of quarter t\nI = model.addVars(products, quarters, name=\"I\", lb=0)\n\n# L[p,t]: backlog (undelivered demand) of product p at end of quarter t\nL = model.addVars(products, quarters, name=\"L\", lb=0)\n\n# -------------------------\n# Constraints\n# -------------------------\n\n# 1. Inventory-backlog balance constraints\nfor p in products:\n    # Initial conditions: I[p,0] = 0, L[p,0] = 0 (handled explicitly in first period)\n    for t in quarters:\n        if t == 1:\n            # I[p,1] - L[p,1] = 0 - 0 + x[p,1] - d[p,1]\n            model.addConstr(\n                I[p,1] - L[p,1] == x[p,1] - demand[p][1],\n                name=f\"balance_p{p}_t{t}\"\n            )\n        else:\n            # I[p,t] - L[p,t] = I[p,t-1] - L[p,t-1] + x[p,t] - d[p,t]\n            model.addConstr(\n                I[p,t] - L[p,t] == I[p,t-1] - L[p,t-1] + x[p,t] - demand[p][t],\n                name=f\"balance_p{p}_t{t}\"\n            )\n\n# 2. Production capacity constraints per quarter\nfor t in quarters:\n    model.addConstr(\n        gp.quicksum(proc_time[p] * x[p, t] for p in products) <= capacity,\n        name=f\"capacity_t{t}\"\n    )\n\n# 3. No production of product I in quarter 2\nmodel.addConstr(x[1, 2] == 0, name=\"no_prod_I_q2\")\n\n# 4. Ending inventory requirement at end of quarter 4\nfor p in products:\n    model.addConstr(\n        I[p, 4] >= required_ending_inventory,\n        name=f\"ending_inventory_p{p}\"\n    )\n\n# -------------------------\n# Objective: Minimize total cost\n# -------------------------\n\nobj = gp.quicksum(\n    inv_cost * I[p, t] + late_cost[p] * L[p, t]\n    for p in products\n    for t in quarters\n)\n\nmodel.setObjective(obj, GRB.MINIMIZE)\n\n# -------------------------\n# Optimize\n# -------------------------\n\nmodel.optimize()\n\n# -------------------------\n# Results\n# -------------------------\n\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\nelse:\n    print(\"No optimal solution found\")", "execution_success": true, "mathematical_accuracy": true, "execution_result": "Execution Successful", "execution_best_solution": 10750.0, "execution_state": "Execution Successful"}
{"task_id": "B026", "description": "A factory produces three types of products: I, II, and III. Each product needs to go through two processing procedures, A and B. The factory has two pieces of equipment that can complete process A, denoted as A1 and A2; it has three pieces of equipment that complete process B, denoted as B1, B2, and B3. Product I can be processed on any equipment for A and B; Product II can be processed on any A equipment but only on B1 for process B; Product III can only be processed on A2 and B2. Given the unit processing time on various machines, raw material costs, product sale prices, effective machine hours, and the costs of operating the machines at full capacity as shown in Table 1-4, the task is to arrange the optimal production plan to maximize the factory's profit.\n\nTable 1-4\n| Equipment  | Product I | Product II | Product III | Effective Machine Hours | Operating Costs at Full Capacity (Yuan) |\n|------------|-----------|------------|-------------|--------------------------|------------------------------------------|\n| A1         | 5         | 10         |             | 6000                     | 300                                      |\n| A2         | 7         | 9          | 12          | 10000                    | 321                                      |\n| B1         | 6         | 8          |             | 4000                     | 250                                      |\n| B2         | 4         |            | 11          | 7000                     | 783                                      |\n| B3         | 7         |            |             | 4000                     | 200                                      |\n| Raw Material Cost (Yuan/Unit) | 0.25 | 0.35       | 0.50       |                          |                                          |\n| Unit Price (Yuan/Unit)        | 1.25 | 2.00       | 2.80       |                          |                                          |", "ground_truth": 1146.57, "formulation": null, "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_factory_production():\n    \"\"\"\n    Solves the factory production planning problem to maximize profit.\n    \"\"\"\n    try:\n        # Create a new model\n        model = gp.Model(\"FactoryProductionOptimization\")\n\n        # --- Data ---\n        # Processing times (hours/unit)\n        proc_times = {\n            ('I', 'A1'): 5,\n            ('I', 'A2'): 7,\n            ('II', 'A1'): 10,\n            ('II', 'A2'): 9,\n            ('III', 'A2'): 12,  # Product III only on A2 for Process A\n            ('I', 'B1'): 6,\n            ('I', 'B2'): 4,\n            ('I', 'B3'): 7,\n            ('II', 'B1'): 8,  # Product II only on B1 for Process B\n            ('III', 'B2'): 11  # Product III only on B2 for Process B\n        }\n\n        # Effective machine hours (capacity)\n        capacities = {\n            'A1': 6000,\n            'A2': 10000,\n            'B1': 4000,\n            'B2': 7000,\n            'B3': 4000\n        }\n\n        # Operating costs at full capacity (Yuan)\n        ocfc = {'A1': 300, 'A2': 321, 'B1': 250, 'B2': 783, 'B3': 200}\n\n        # Variable operating costs per hour (Yuan/hr)\n        voc = {m: ocfc[m] / capacities[m] for m in capacities}\n\n        # Raw material costs (Yuan/unit)\n        rmc = {'I': 0.25, 'II': 0.35, 'III': 0.50}\n\n        # Unit sale prices (Yuan/unit)\n        sp = {'I': 1.25, 'II': 2.00, 'III': 2.80}\n\n        products = ['I', 'II', 'III']\n        machines_A = ['A1', 'A2']\n        machines_B = ['B1', 'B2', 'B3']\n        all_machines = machines_A + machines_B\n\n        # --- Decision Variables ---\n        # X_p: Total units of product p to produce\n        X = model.addVars(products, name=\"X\", lb=0.0)\n\n        # x_pm: Quantity of product p processed on machine m\n        # For Process A machines\n        x_IA1 = model.addVar(name=\"x_I_A1\", lb=0.0)\n        x_IA2 = model.addVar(name=\"x_I_A2\", lb=0.0)\n        x_IIA1 = model.addVar(name=\"x_II_A1\", lb=0.0)\n        x_IIA2 = model.addVar(name=\"x_II_A2\", lb=0.0)\n        x_IIIA2 = model.addVar(name=\"x_III_A2\", lb=0.0)  # P-III only on A2\n\n        # For Process B machines\n        x_IB1 = model.addVar(name=\"x_I_B1\", lb=0.0)\n        x_IB2 = model.addVar(name=\"x_I_B2\", lb=0.0)\n        x_IB3 = model.addVar(name=\"x_I_B3\", lb=0.0)\n        x_IIB1 = model.addVar(name=\"x_II_B1\", lb=0.0)  # P-II only on B1\n        x_IIIB2 = model.addVar(name=\"x_III_B2\", lb=0.0)  # P-III only on B2\n\n        # --- Objective Function: Maximize Profit ---\n        total_revenue = gp.quicksum(sp[p] * X[p] for p in products)\n        total_rmc = gp.quicksum(rmc[p] * X[p] for p in products)\n\n        # Variable operating costs\n        op_cost_A1 = (proc_times[('I', 'A1')] * x_IA1 +\n                      proc_times[('II', 'A1')] * x_IIA1) * voc['A1']\n        op_cost_A2 = (proc_times[('I', 'A2')] * x_IA2 +\n                      proc_times[('II', 'A2')] * x_IIA2 +\n                      proc_times[('III', 'A2')] * x_IIIA2) * voc['A2']\n        op_cost_B1 = (proc_times[('I', 'B1')] * x_IB1 +\n                      proc_times[('II', 'B1')] * x_IIB1) * voc['B1']\n        op_cost_B2 = (proc_times[('I', 'B2')] * x_IB2 +\n                      proc_times[('III', 'B2')] * x_IIIB2) * voc['B2']\n        op_cost_B3 = (proc_times[('I', 'B3')] * x_IB3) * voc['B3']\n\n        total_variable_op_cost = op_cost_A1 + op_cost_A2 + op_cost_B1 + op_cost_B2 + op_cost_B3\n\n        profit = total_revenue - total_rmc - total_variable_op_cost\n        model.setObjective(profit, GRB.MAXIMIZE)\n\n        # --- Constraints ---\n        # 1. Machine Capacity Constraints\n        model.addConstr(\n            proc_times[('I', 'A1')] * x_IA1 + proc_times[('II', 'A1')] * x_IIA1\n            <= capacities['A1'], \"Cap_A1\")\n        model.addConstr(\n            proc_times[('I', 'A2')] * x_IA2 +\n            proc_times[('II', 'A2')] * x_IIA2 +\n            proc_times[('III', 'A2')] * x_IIIA2 <= capacities['A2'], \"Cap_A2\")\n        model.addConstr(\n            proc_times[('I', 'B1')] * x_IB1 + proc_times[('II', 'B1')] * x_IIB1\n            <= capacities['B1'], \"Cap_B1\")\n        model.addConstr(\n            proc_times[('I', 'B2')] * x_IB2 +\n            proc_times[('III', 'B2')] * x_IIIB2 <= capacities['B2'], \"Cap_B2\")\n        model.addConstr(proc_times[('I', 'B3')] * x_IB3 <= capacities['B3'],\n                        \"Cap_B3\")\n\n        # 2. Production Flow Conservation\n        # Product I\n        model.addConstr(x_IA1 + x_IA2 == X['I'], \"Flow_I_A\")\n        model.addConstr(x_IB1 + x_IB2 + x_IB3 == X['I'], \"Flow_I_B\")\n        # Product II\n        model.addConstr(x_IIA1 + x_IIA2 == X['II'], \"Flow_II_A\")\n        model.addConstr(x_IIB1 == X['II'], \"Flow_II_B\")  # P-II only on B1\n        # Product III\n        model.addConstr(x_IIIA2 == X['III'], \"Flow_III_A\")  # P-III only on A2\n        model.addConstr(x_IIIB2 == X['III'], \"Flow_III_B\")  # P-III only on B2\n\n        # Suppress Gurobi output to console\n        model.setParam('OutputFlag', 0)\n\n        # Optimize the model\n        model.optimize()\n\n        # --- Results ---\n        if model.status == GRB.OPTIMAL:\n            print(\"Optimal production plan found.\")\n            print(f\"Maximum Profit: {model.objVal:.2f} Yuan\")\n            print(\"\\nTotal units of each product to produce:\")\n            for p in products:\n                print(f\"  Product {p}: {X[p].X:.2f} units\")\n\n            print(\"\\nProduction allocation (units on each machine):\")\n            print(\"  Process A:\")\n            print(f\"    Product I on A1 (x_I_A1): {x_IA1.X:.2f}\")\n            print(f\"    Product I on A2 (x_I_A2): {x_IA2.X:.2f}\")\n            print(f\"    Product II on A1 (x_II_A1): {x_IIA1.X:.2f}\")\n            print(f\"    Product II on A2 (x_II_A2): {x_IIA2.X:.2f}\")\n            print(f\"    Product III on A2 (x_III_A2): {x_IIIA2.X:.2f}\")\n            print(\"  Process B:\")\n            print(f\"    Product I on B1 (x_I_B1): {x_IB1.X:.2f}\")\n            print(f\"    Product I on B2 (x_I_B2): {x_IB2.X:.2f}\")\n            print(f\"    Product I on B3 (x_I_B3): {x_IB3.X:.2f}\")\n            print(f\"    Product II on B1 (x_II_B1): {x_IIB1.X:.2f}\")\n            print(f\"    Product III on B2 (x_III_B2): {x_IIIB2.X:.2f}\")\n\n            print(\"\\nMachine Utilization (Hours Used / Capacity):\")\n            hours_A1 = proc_times[('I', 'A1')] * x_IA1.X + proc_times[\n                ('II', 'A1')] * x_IIA1.X\n            hours_A2 = proc_times[('I', 'A2')] * x_IA2.X + proc_times[(\n                'II', 'A2')] * x_IIA2.X + proc_times[('III', 'A2')] * x_IIIA2.X\n            hours_B1 = proc_times[('I', 'B1')] * x_IB1.X + proc_times[\n                ('II', 'B1')] * x_IIB1.X\n            hours_B2 = proc_times[('I', 'B2')] * x_IB2.X + proc_times[\n                ('III', 'B2')] * x_IIIB2.X\n            hours_B3 = proc_times[('I', 'B3')] * x_IB3.X\n\n            print(\n                f\"  Machine A1: {hours_A1:.2f} / {capacities['A1']} hours ({hours_A1/capacities['A1']*100:.1f}%)\"\n            )\n            print(\n                f\"  Machine A2: {hours_A2:.2f} / {capacities['A2']} hours ({hours_A2/capacities['A2']*100:.1f}%)\"\n            )\n            print(\n                f\"  Machine B1: {hours_B1:.2f} / {capacities['B1']} hours ({hours_B1/capacities['B1']*100:.1f}%)\"\n            )\n            print(\n                f\"  Machine B2: {hours_B2:.2f} / {capacities['B2']} hours ({hours_B2/capacities['B2']*100:.1f}%)\"\n            )\n            print(\n                f\"  Machine B3: {hours_B3:.2f} / {capacities['B3']} hours ({hours_B3/capacities['B3']*100:.1f}%)\"\n            )\n\n        elif model.status == GRB.INFEASIBLE:\n            print(\"Model is infeasible. Check constraints and data.\")\n            # Compute and print IIS (Irreducible Inconsistent Subsystem)\n            # model.computeIIS()\n            # model.write(\"model_iis.ilp\")\n            # print(\"IIS written to model_iis.ilp\")\n        else:\n            print(f\"Optimization was stopped with status {model.status}\")\n\n    except gp.GurobiError as e:\n        print(f\"Gurobi error code {e.errno}: {e}\")\n    except Exception as e:\n        print(f\"An error occurred: {e}\")\n\n\nif __name__ == '__main__':\n    solve_factory_production()", "output_status": [], "success_count": 0, "success_confidence": 0, "fail_to_diagnose": 0, "fail_to_verify": 0, "retrieved_insights": [], "tag": [{"problem_domain": "Production Planning", "modeling_type": "LP", "industry_sector": "Manufacturing", "reason": "The task involves determining the optimal quantities of different products to produce and how to allocate them to various machines to maximize profit, which is a classic production planning problem. The solver program uses continuous variables and linear constraints and objective function, making it a Linear Program (LP). The context of producing goods in a factory directly points to the manufacturing sector."}], "cluster": null, "prompt": "Below is an operations research question. First formulate the problem as an optimization problem. Then according to the formulated problem, write python code that uses 'gurobipy' to solve the optimization problem. You should write a complete python code that can be executed to solve the optimization problem.\n\nIMPORTANT: Your code should follow these requirements:\n1. Create a Gurobi model variable named 'model' (not 'm' or other names)\n2. Include all necessary imports and data setup\n3. Write the complete optimization code that can run independently\n4. Do NOT wrap everything in a function - write the code directly\n5. Make sure the model is created and optimized in the main execution flow\n6. The code should print the optimal objective value when solved successfully\n\nExample format:\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Data setup\ndata = {...}\n\n# Create model\nmodel = gp.Model(\"ProblemName\")\n\n# Decision variables\nx = model.addVars(...)\n\n# Objective\nmodel.setObjective(...)\n\n# Constraints\nmodel.addConstr(...)\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\nelse:\n    print(\"No optimal solution found\")\n```\n\n# Question:\nA factory produces three types of products: I, II, and III. Each product needs to go through two processing procedures, A and B. The factory has two pieces of equipment that can complete process A, denoted as A1 and A2; it has three pieces of equipment that complete process B, denoted as B1, B2, and B3. Product I can be processed on any equipment for A and B; Product II can be processed on any A equipment but only on B1 for process B; Product III can only be processed on A2 and B2. Given the unit processing time on various machines, raw material costs, product sale prices, effective machine hours, and the costs of operating the machines at full capacity as shown in Table 1-4, the task is to arrange the optimal production plan to maximize the factory's profit.\n\nTable 1-4\n| Equipment  | Product I | Product II | Product III | Effective Machine Hours | Operating Costs at Full Capacity (Yuan) |\n|------------|-----------|------------|-------------|--------------------------|------------------------------------------|\n| A1         | 5         | 10         |             | 6000                     | 300                                      |\n| A2         | 7         | 9          | 12          | 10000                    | 321                                      |\n| B1         | 6         | 8          |             | 4000                     | 250                                      |\n| B2         | 4         |            | 11          | 7000                     | 783                                      |\n| B3         | 7         |            |             | 4000                     | 200                                      |\n| Raw Material Cost (Yuan/Unit) | 0.25 | 0.35       | 0.50       |                          |                                          |\n| Unit Price (Yuan/Unit)        | 1.25 | 2.00       | 2.80       |                          |                                          |\n\n# Response:", "generated_output": "```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# =========================\n# Data setup\n# =========================\n\n# Products\nproducts = ['I', 'II', 'III']\n\n# Machines for process A and B\nA_machines = ['A1', 'A2']\nB_machines = ['B1', 'B2', 'B3']\n\n# Processing times (hours per unit) where allowed\n# time_A[machine][product]\ntime_A = {\n    'A1': {'I': 5,  'II': 10},          # III not allowed on A1\n    'A2': {'I': 7,  'II': 9, 'III': 12}\n}\n\n# time_B[machine][product]\ntime_B = {\n    'B1': {'I': 6,  'II': 8},           # III not allowed on B1\n    'B2': {'I': 4,              'III': 11},\n    'B3': {'I': 7}                      # II, III not allowed on B3\n}\n\n# Effective machine hours\nhours_A = {'A1': 6000, 'A2': 10000}\nhours_B = {'B1': 4000, 'B2': 7000, 'B3': 4000}\n\n# Operating costs at full capacity (Yuan)\nopcost_A = {'A1': 300, 'A2': 321}\nopcost_B = {'B1': 250, 'B2': 783, 'B3': 200}\n\n# Raw material cost per unit\nraw_cost = {'I': 0.25, 'II': 0.35, 'III': 0.50}\n\n# Selling price per unit\nprice = {'I': 1.25, 'II': 2.00, 'III': 2.80}\n\n# =========================\n# Model creation\n# =========================\n\nmodel = gp.Model(\"Production_Planning\")\n\n# =========================\n# Decision variables\n# =========================\n\n# xA[m,p]: units of product p processed on A-machine m\nxA = model.addVars(\n    A_machines, products,\n    name=\"xA\",\n    lb=0.0\n)\n\n# xB[m,p]: units of product p processed on B-machine m\nxB = model.addVars(\n    B_machines, products,\n    name=\"xB\",\n    lb=0.0\n)\n\n# y[p]: total units of product p produced (must pass both A and B)\ny = model.addVars(products, name=\"y\", lb=0.0)\n\n# =========================\n# Constraints\n# =========================\n\n# 1) Machine time capacity constraints for A\nfor m in A_machines:\n    model.addConstr(\n        gp.quicksum(\n            time_A[m][p] * xA[m, p]\n            for p in products\n            if p in time_A[m]\n        ) <= hours_A[m],\n        name=f\"Cap_A_{m}\"\n    )\n\n# 2) Machine time capacity constraints for B\nfor m in B_machines:\n    model.addConstr(\n        gp.quicksum(\n            time_B[m][p] * xB[m, p]\n            for p in products\n            if p in time_B[m]\n        ) <= hours_B[m],\n        name=f\"Cap_B_{m}\"\n    )\n\n# 3) Flow balance: units of each product must be consistent across A and B\nfor p in products:\n    # Total units of product p processed on A\n    expr_A = gp.quicksum(\n        xA[m, p] for m in A_machines if p in time_A[m]\n    )\n    # Total units of product p processed on B\n    expr_B = gp.quicksum(\n        xB[m, p] for m in B_machines if p in time_B[m]\n    )\n    # Both must equal total production y[p]\n    model.addConstr(expr_A == y[p], name=f\"FlowA_{p}\")\n    model.addConstr(expr_B == y[p], name=f\"FlowB_{p}\")\n\n# 4) Disallow processing where not permitted (set those x to 0)\n# This is handled implicitly by not including those (m,p) in time_A/time_B\n# but we also explicitly fix them to 0 for clarity.\nfor m in A_machines:\n    for p in products:\n        if p not in time_A[m]:\n            xA[m, p].ub = 0.0\n\nfor m in B_machines:\n    for p in products:\n        if p not in time_B[m]:\n            xB[m, p].ub = 0.0\n\n# =========================\n# Objective: Maximize profit\n# =========================\n\n# Revenue from selling products\nrevenue = gp.quicksum(price[p] * y[p] for p in products)\n\n# Raw material cost\nraw_total = gp.quicksum(raw_cost[p] * y[p] for p in products)\n\n# Operating cost: assume full-capacity cost is incurred if machine is used at all.\n# To keep it linear without binary variables, we approximate by\n# charging operating cost proportionally to used hours / available hours.\n# (If you want exact fixed-charge modeling, you'd add binary variables.)\nop_cost_A_expr = gp.quicksum(\n    opcost_A[m] *\n    (gp.quicksum(time_A[m][p] * xA[m, p] for p in products if p in time_A[m]) / hours_A[m])\n    for m in A_machines\n)\n\nop_cost_B_expr = gp.quicksum(\n    opcost_B[m] *\n    (gp.quicksum(time_B[m][p] * xB[m, p] for p in products if p in time_B[m]) / hours_B[m])\n    for m in B_machines\n)\n\ntotal_profit = revenue - raw_total - op_cost_A_expr - op_cost_B_expr\n\nmodel.setObjective(total_profit, GRB.MAXIMIZE)\n\n# =========================\n# Optimize\n# =========================\n\nmodel.optimize()\n\n# =========================\n# Results\n# =========================\n\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\n    # Optional: print production plan\n    for p in products:\n        print(f\"Product {p}: produce {y[p].X:.2f} units\")\nelse:\n    print(\"No optimal solution found\")\n```", "extracted_code": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# =========================\n# Data setup\n# =========================\n\n# Products\nproducts = ['I', 'II', 'III']\n\n# Machines for process A and B\nA_machines = ['A1', 'A2']\nB_machines = ['B1', 'B2', 'B3']\n\n# Processing times (hours per unit) where allowed\n# time_A[machine][product]\ntime_A = {\n    'A1': {'I': 5,  'II': 10},          # III not allowed on A1\n    'A2': {'I': 7,  'II': 9, 'III': 12}\n}\n\n# time_B[machine][product]\ntime_B = {\n    'B1': {'I': 6,  'II': 8},           # III not allowed on B1\n    'B2': {'I': 4,              'III': 11},\n    'B3': {'I': 7}                      # II, III not allowed on B3\n}\n\n# Effective machine hours\nhours_A = {'A1': 6000, 'A2': 10000}\nhours_B = {'B1': 4000, 'B2': 7000, 'B3': 4000}\n\n# Operating costs at full capacity (Yuan)\nopcost_A = {'A1': 300, 'A2': 321}\nopcost_B = {'B1': 250, 'B2': 783, 'B3': 200}\n\n# Raw material cost per unit\nraw_cost = {'I': 0.25, 'II': 0.35, 'III': 0.50}\n\n# Selling price per unit\nprice = {'I': 1.25, 'II': 2.00, 'III': 2.80}\n\n# =========================\n# Model creation\n# =========================\n\nmodel = gp.Model(\"Production_Planning\")\n\n# =========================\n# Decision variables\n# =========================\n\n# xA[m,p]: units of product p processed on A-machine m\nxA = model.addVars(\n    A_machines, products,\n    name=\"xA\",\n    lb=0.0\n)\n\n# xB[m,p]: units of product p processed on B-machine m\nxB = model.addVars(\n    B_machines, products,\n    name=\"xB\",\n    lb=0.0\n)\n\n# y[p]: total units of product p produced (must pass both A and B)\ny = model.addVars(products, name=\"y\", lb=0.0)\n\n# =========================\n# Constraints\n# =========================\n\n# 1) Machine time capacity constraints for A\nfor m in A_machines:\n    model.addConstr(\n        gp.quicksum(\n            time_A[m][p] * xA[m, p]\n            for p in products\n            if p in time_A[m]\n        ) <= hours_A[m],\n        name=f\"Cap_A_{m}\"\n    )\n\n# 2) Machine time capacity constraints for B\nfor m in B_machines:\n    model.addConstr(\n        gp.quicksum(\n            time_B[m][p] * xB[m, p]\n            for p in products\n            if p in time_B[m]\n        ) <= hours_B[m],\n        name=f\"Cap_B_{m}\"\n    )\n\n# 3) Flow balance: units of each product must be consistent across A and B\nfor p in products:\n    # Total units of product p processed on A\n    expr_A = gp.quicksum(\n        xA[m, p] for m in A_machines if p in time_A[m]\n    )\n    # Total units of product p processed on B\n    expr_B = gp.quicksum(\n        xB[m, p] for m in B_machines if p in time_B[m]\n    )\n    # Both must equal total production y[p]\n    model.addConstr(expr_A == y[p], name=f\"FlowA_{p}\")\n    model.addConstr(expr_B == y[p], name=f\"FlowB_{p}\")\n\n# 4) Disallow processing where not permitted (set those x to 0)\n# This is handled implicitly by not including those (m,p) in time_A/time_B\n# but we also explicitly fix them to 0 for clarity.\nfor m in A_machines:\n    for p in products:\n        if p not in time_A[m]:\n            xA[m, p].ub = 0.0\n\nfor m in B_machines:\n    for p in products:\n        if p not in time_B[m]:\n            xB[m, p].ub = 0.0\n\n# =========================\n# Objective: Maximize profit\n# =========================\n\n# Revenue from selling products\nrevenue = gp.quicksum(price[p] * y[p] for p in products)\n\n# Raw material cost\nraw_total = gp.quicksum(raw_cost[p] * y[p] for p in products)\n\n# Operating cost: assume full-capacity cost is incurred if machine is used at all.\n# To keep it linear without binary variables, we approximate by\n# charging operating cost proportionally to used hours / available hours.\n# (If you want exact fixed-charge modeling, you'd add binary variables.)\nop_cost_A_expr = gp.quicksum(\n    opcost_A[m] *\n    (gp.quicksum(time_A[m][p] * xA[m, p] for p in products if p in time_A[m]) / hours_A[m])\n    for m in A_machines\n)\n\nop_cost_B_expr = gp.quicksum(\n    opcost_B[m] *\n    (gp.quicksum(time_B[m][p] * xB[m, p] for p in products if p in time_B[m]) / hours_B[m])\n    for m in B_machines\n)\n\ntotal_profit = revenue - raw_total - op_cost_A_expr - op_cost_B_expr\n\nmodel.setObjective(total_profit, GRB.MAXIMIZE)\n\n# =========================\n# Optimize\n# =========================\n\nmodel.optimize()\n\n# =========================\n# Results\n# =========================\n\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\n    # Optional: print production plan\n    for p in products:\n        print(f\"Product {p}: produce {y[p].X:.2f} units\")\nelse:\n    print(\"No optimal solution found\")", "execution_success": true, "mathematical_accuracy": true, "execution_result": "Execution Successful", "execution_best_solution": 1146.5665024630541, "execution_state": "Execution Successful"}
{"task_id": "B059", "description": "A traveling salesman must visit 7 customers at 7 different locations, with the (symmetric) distance matrix as follows:\n\n|  | 1 | 2 | 3 | 4 | 5 | 6 | 7 |\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\n| 1 | - | 86 | 49 | 57 | 31 | 69 | 50 |\n| 2 |  | - | 68 | 79 | 93 | 24 | 5 |\n| 3 |  |  | - | 16 | 7 | 72 | 67 |\n| 4 |  |  |  | - | 90 | 69 | 1 |\n| 5 |  |  |  |  | - | 86 | 59 |\n| 6 |  |  |  |  |  | - | 81 |\n\nFormulate a mathematical program to determine the visiting order starting and ending at location 1 to minimize the travel distance, and solve it using COPTPY.", "ground_truth": 153.0, "formulation": null, "correct_program": "def solve_tsp(distance_matrix=None):\n    from gurobipy import Model, GRB, quicksum\n\n    # Default distance matrix based on the provided data\n    if distance_matrix is None:\n        distance_matrix = [[0, 86, 49, 57, 31, 69, 50],\n                           [86, 0, 68, 79, 93, 24, 5],\n                           [49, 68, 0, 16, 7, 72, 67],\n                           [57, 79, 16, 0, 90, 69, 1],\n                           [31, 93, 7, 90, 0, 86, 59],\n                           [69, 24, 72, 69, 86, 0, 81],\n                           [50, 5, 67, 1, 59, 81, 0]]\n\n    n = len(distance_matrix)\n    model = Model()\n\n    # Decision variables: x[i,j] binary\n    x = {}\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                x[i, j] = model.addVar(vtype=GRB.BINARY, name=f\"x_{i}_{j}\")\n\n    # MTZ variables for subtour elimination\n    u = {}\n    for i in range(1, n):\n        u[i] = model.addVar(lb=2, ub=n, vtype=GRB.CONTINUOUS, name=f\"u_{i}\")\n\n    model.update()\n\n    # Objective: minimize total distance\n    model.setObjective(\n        quicksum(distance_matrix[i][j] * x[i, j] for i in range(n)\n                 for j in range(n) if i != j), GRB.MINIMIZE)\n\n    # Constraints:\n\n    # 1. From start location (0), exactly one outgoing edge\n    model.addConstr(quicksum(x[0, j] for j in range(1, n)) == 1,\n                    name=\"start_out\")\n\n    # 2. Each node (except start) has exactly one incoming edge\n    for j in range(1, n):\n        model.addConstr(quicksum(x[i, j] for i in range(n) if i != j) == 1,\n                        name=f\"node_in_{j}\")\n\n    # 3. Each node (except start) has exactly one outgoing edge\n    for i in range(1, n):\n        model.addConstr(quicksum(x[i, j] for j in range(n) if j != i) == 1,\n                        name=f\"node_out_{i}\")\n\n    # 4. Subtour elimination (MTZ)\n    for i in range(1, n):\n        for j in range(1, n):\n            if i != j:\n                model.addConstr(u[i] - u[j] + n * x[i, j] <= n - 1,\n                                name=f\"subtour_{i}_{j}\")\n\n    # Optimize\n    model.optimize()\n\n    # Check feasibility\n    if model.status == GRB.OPTIMAL:\n        return model.objVal\n    else:\n        return None\nif __name__ == \"__main__\":\n    result = solve_tsp()\n    if result is not None:\n        print(f\"Optimal total distance: {result}\")\n    else:\n        print(\"No feasible solution found.\")", "output_status": [], "success_count": 0, "success_confidence": 0, "fail_to_diagnose": 0, "fail_to_verify": 0, "retrieved_insights": [], "tag": [{"problem_domain": "Routing", "modeling_type": "MILP", "industry_sector": "Transportation", "reason": "The problem is a classic Traveling Salesman Problem (TSP), which falls under the Routing domain. The solver uses binary decision variables and linear constraints, including MTZ subtour elimination, making it a Mixed-Integer Linear Program (MILP). The context of a 'traveling salesman' visiting 'customers at different locations' directly relates to the Transportation sector."}], "cluster": null, "prompt": "Below is an operations research question. First formulate the problem as an optimization problem. Then according to the formulated problem, write python code that uses 'gurobipy' to solve the optimization problem. You should write a complete python code that can be executed to solve the optimization problem.\n\nIMPORTANT: Your code should follow these requirements:\n1. Create a Gurobi model variable named 'model' (not 'm' or other names)\n2. Include all necessary imports and data setup\n3. Write the complete optimization code that can run independently\n4. Do NOT wrap everything in a function - write the code directly\n5. Make sure the model is created and optimized in the main execution flow\n6. The code should print the optimal objective value when solved successfully\n\nExample format:\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Data setup\ndata = {...}\n\n# Create model\nmodel = gp.Model(\"ProblemName\")\n\n# Decision variables\nx = model.addVars(...)\n\n# Objective\nmodel.setObjective(...)\n\n# Constraints\nmodel.addConstr(...)\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\nelse:\n    print(\"No optimal solution found\")\n```\n\n# Question:\nA traveling salesman must visit 7 customers at 7 different locations, with the (symmetric) distance matrix as follows:\n\n|  | 1 | 2 | 3 | 4 | 5 | 6 | 7 |\n| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |\n| 1 | - | 86 | 49 | 57 | 31 | 69 | 50 |\n| 2 |  | - | 68 | 79 | 93 | 24 | 5 |\n| 3 |  |  | - | 16 | 7 | 72 | 67 |\n| 4 |  |  |  | - | 90 | 69 | 1 |\n| 5 |  |  |  |  | - | 86 | 59 |\n| 6 |  |  |  |  |  | - | 81 |\n\nFormulate a mathematical program to determine the visiting order starting and ending at location 1 to minimize the travel distance, and solve it using COPTPY.\n\n# Response:", "generated_output": "Below is a standard mixed-integer programming formulation of the Traveling Salesman Problem (TSP) using Miller–Tucker–Zemlin (MTZ) subtour elimination constraints, followed by complete Python code using `gurobipy` (Gurobi’s Python API) to solve it.\n\n---\n\n## Mathematical Formulation (MTZ)\n\n**Sets and indices**\n\n- Let \\( N = \\{1,2,\\dots,7\\} \\) be the set of locations (customers).\n- Location 1 is the depot (start and end).\n\n**Parameters**\n\n- \\( c_{ij} \\): distance from location \\( i \\) to location \\( j \\), for all \\( i,j \\in N, i \\neq j \\).  \n  (Given by the distance matrix; symmetric: \\( c_{ij} = c_{ji} \\), and \\( c_{ii} \\) is not used.)\n\n**Decision variables**\n\n- \\( x_{ij} \\in \\{0,1\\} \\) for all \\( i,j \\in N, i \\neq j \\):  \n  \\( x_{ij} = 1 \\) if the tour goes directly from location \\( i \\) to location \\( j \\), and 0 otherwise.\n- \\( u_i \\in \\mathbb{R} \\) for all \\( i \\in N \\): auxiliary variables for MTZ subtour elimination, representing the position of node \\( i \\) in the tour (only needed for \\( i \\ge 2 \\), but we define for all and fix \\( u_1 \\)).\n\n**Objective**\n\nMinimize total travel distance:\n\\[\n\\min \\sum_{i \\in N} \\sum_{\\substack{j \\in N \\\\ j \\ne i}} c_{ij} x_{ij}\n\\]\n\n**Constraints**\n\n1. **Exactly one outgoing arc from each node:**\n\\[\n\\sum_{\\substack{j \\in N \\\\ j \\ne i}} x_{ij} = 1 \\quad \\forall i \\in N\n\\]\n\n2. **Exactly one incoming arc to each node:**\n\\[\n\\sum_{\\substack{j \\in N \\\\ j \\ne i}} x_{ji} = 1 \\quad \\forall i \\in N\n\\]\n\n3. **MTZ subtour elimination constraints** (for all \\( i \\ne j \\), \\( i,j \\in \\{2,\\dots,7\\} \\)):\n\\[\nu_i - u_j + 7\\, x_{ij} \\le 6 \\quad \\forall i,j \\in N, \\; i \\ne j,\\; i \\ge 2,\\; j \\ge 2\n\\]\nwith\n\\[\n1 \\le u_i \\le 7 \\quad \\forall i \\in N,\\quad u_1 = 1\n\\]\n\nThese constraints prevent subtours that do not include node 1.\n\n---\n\n## Complete Python Code Using Gurobi (`gurobipy`)\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# =========================\n# Data setup\n# =========================\n\n# Set of nodes\nnodes = [1, 2, 3, 4, 5, 6, 7]\nn = len(nodes)\n\n# Distance matrix (symmetric). We'll store as a dict of dicts.\n# Use a large value or simply not define c[i][i] since we never use i == j.\ndist_matrix = {\n    1: {2: 86, 3: 49, 4: 57, 5: 31, 6: 69, 7: 50},\n    2: {1: 86, 3: 68, 4: 79, 5: 93, 6: 24, 7: 5},\n    3: {1: 49, 2: 68, 4: 16, 5: 7,  6: 72, 7: 67},\n    4: {1: 57, 2: 79, 3: 16, 5: 90, 6: 69, 7: 1},\n    5: {1: 31, 2: 93, 3: 7,  4: 90, 6: 86, 7: 59},\n    6: {1: 69, 2: 24, 3: 72, 4: 69, 5: 86, 7: 81},\n    7: {1: 50, 2: 5,  3: 67, 4: 1,  5: 59, 6: 81}\n}\n\n# =========================\n# Create model\n# =========================\n\nmodel = gp.Model(\"TSP_7_nodes\")\n\n# =========================\n# Decision variables\n# =========================\n\n# x[i,j] = 1 if we travel directly from i to j\nx = model.addVars(\n    nodes,\n    nodes,\n    vtype=GRB.BINARY,\n    name=\"x\"\n)\n\n# u[i] = position of node i in the tour (MTZ variables)\nu = model.addVars(\n    nodes,\n    vtype=GRB.CONTINUOUS,\n    lb=1,\n    ub=n,\n    name=\"u\"\n)\n\n# =========================\n# Objective: minimize total distance\n# =========================\n\nmodel.setObjective(\n    gp.quicksum(\n        dist_matrix[i][j] * x[i, j]\n        for i in nodes\n        for j in nodes\n        if i != j\n    ),\n    GRB.MINIMIZE\n)\n\n# =========================\n# Constraints\n# =========================\n\n# 1. Exactly one outgoing arc from each node\nfor i in nodes:\n    model.addConstr(\n        gp.quicksum(x[i, j] for j in nodes if j != i) == 1,\n        name=f\"outgoing_{i}\"\n    )\n\n# 2. Exactly one incoming arc to each node\nfor j in nodes:\n    model.addConstr(\n        gp.quicksum(x[i, j] for i in nodes if i != j) == 1,\n        name=f\"incoming_{j}\"\n    )\n\n# 3. MTZ subtour elimination constraints\n# Fix u[1] = 1 (start node position)\nmodel.addConstr(u[1] == 1, name=\"fix_u1\")\n\n# MTZ constraints for i,j >= 2, i != j\n# u_i - u_j + n * x_ij <= n - 1\nfor i in nodes:\n    for j in nodes:\n        if i != j and i != 1 and j != 1:\n            model.addConstr(\n                u[i] - u[j] + n * x[i, j] <= n - 1,\n                name=f\"mtz_{i}_{j}\"\n            )\n\n# Also, we do not allow self-loops\nfor i in nodes:\n    model.addConstr(x[i, i] == 0, name=f\"no_self_{i}\")\n\n# =========================\n# Optimize\n# =========================\n\nmodel.optimize()\n\n# =========================\n# Results\n# =========================\n\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\n\n    # Optional: print the tour\n    # Extract the tour starting from node 1\n    succ = {}\n    for i in nodes:\n        for j in nodes:\n            if i != j and x[i, j].X > 0.5:\n                succ[i] = j\n\n    tour = [1]\n    current = 1\n    while True:\n        current = succ[current]\n        tour.append(current)\n        if current == 1:\n            break\n\n    print(\"Optimal tour:\", \" -> \".join(map(str, tour)))\nelse:\n    print(\"No optimal solution found\")\n```", "extracted_code": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# =========================\n# Data setup\n# =========================\n\n# Set of nodes\nnodes = [1, 2, 3, 4, 5, 6, 7]\nn = len(nodes)\n\n# Distance matrix (symmetric). We'll store as a dict of dicts.\n# Use a large value or simply not define c[i][i] since we never use i == j.\ndist_matrix = {\n    1: {2: 86, 3: 49, 4: 57, 5: 31, 6: 69, 7: 50},\n    2: {1: 86, 3: 68, 4: 79, 5: 93, 6: 24, 7: 5},\n    3: {1: 49, 2: 68, 4: 16, 5: 7,  6: 72, 7: 67},\n    4: {1: 57, 2: 79, 3: 16, 5: 90, 6: 69, 7: 1},\n    5: {1: 31, 2: 93, 3: 7,  4: 90, 6: 86, 7: 59},\n    6: {1: 69, 2: 24, 3: 72, 4: 69, 5: 86, 7: 81},\n    7: {1: 50, 2: 5,  3: 67, 4: 1,  5: 59, 6: 81}\n}\n\n# =========================\n# Create model\n# =========================\n\nmodel = gp.Model(\"TSP_7_nodes\")\n\n# =========================\n# Decision variables\n# =========================\n\n# x[i,j] = 1 if we travel directly from i to j\nx = model.addVars(\n    nodes,\n    nodes,\n    vtype=GRB.BINARY,\n    name=\"x\"\n)\n\n# u[i] = position of node i in the tour (MTZ variables)\nu = model.addVars(\n    nodes,\n    vtype=GRB.CONTINUOUS,\n    lb=1,\n    ub=n,\n    name=\"u\"\n)\n\n# =========================\n# Objective: minimize total distance\n# =========================\n\nmodel.setObjective(\n    gp.quicksum(\n        dist_matrix[i][j] * x[i, j]\n        for i in nodes\n        for j in nodes\n        if i != j\n    ),\n    GRB.MINIMIZE\n)\n\n# =========================\n# Constraints\n# =========================\n\n# 1. Exactly one outgoing arc from each node\nfor i in nodes:\n    model.addConstr(\n        gp.quicksum(x[i, j] for j in nodes if j != i) == 1,\n        name=f\"outgoing_{i}\"\n    )\n\n# 2. Exactly one incoming arc to each node\nfor j in nodes:\n    model.addConstr(\n        gp.quicksum(x[i, j] for i in nodes if i != j) == 1,\n        name=f\"incoming_{j}\"\n    )\n\n# 3. MTZ subtour elimination constraints\n# Fix u[1] = 1 (start node position)\nmodel.addConstr(u[1] == 1, name=\"fix_u1\")\n\n# MTZ constraints for i,j >= 2, i != j\n# u_i - u_j + n * x_ij <= n - 1\nfor i in nodes:\n    for j in nodes:\n        if i != j and i != 1 and j != 1:\n            model.addConstr(\n                u[i] - u[j] + n * x[i, j] <= n - 1,\n                name=f\"mtz_{i}_{j}\"\n            )\n\n# Also, we do not allow self-loops\nfor i in nodes:\n    model.addConstr(x[i, i] == 0, name=f\"no_self_{i}\")\n\n# =========================\n# Optimize\n# =========================\n\nmodel.optimize()\n\n# =========================\n# Results\n# =========================\n\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\n\n    # Optional: print the tour\n    # Extract the tour starting from node 1\n    succ = {}\n    for i in nodes:\n        for j in nodes:\n            if i != j and x[i, j].X > 0.5:\n                succ[i] = j\n\n    tour = [1]\n    current = 1\n    while True:\n        current = succ[current]\n        tour.append(current)\n        if current == 1:\n            break\n\n    print(\"Optimal tour:\", \" -> \".join(map(str, tour)))\nelse:\n    print(\"No optimal solution found\")", "execution_success": true, "mathematical_accuracy": true, "execution_result": "Execution Successful", "execution_best_solution": 153.0, "execution_state": "Execution Successful"}
{"task_id": "B012", "description": "Tom and Jerry just bought a farm in Sunshine Valley, and they are considering using it to plant corn, wheat, soybeans, and sorghum. The profit per acre for planting corn is $1500, the profit per acre for planting wheat is $1200, the profit per acre for planting soybeans is $1800, and the profit per acre for planting sorghum is $1600. To maximize their profit, how many acres of land should they allocate to each crop? Tom and Jerry’s farm has a total area of 100 acres.\n\nThe land area used for planting corn must be at least twice the land area used for planting wheat.\n\nThe land area used for planting soybeans must be at least half the land area used for planting sorghum.\n\nThe land area used for planting wheat must be three times the land area used for planting sorghum.", "ground_truth": 180000.0, "formulation": null, "correct_program": "def optimize_crop_allocation(total_land=100,\n                             profit_c=1500,\n                             profit_w=1200,\n                             profit_s=1800,\n                             profit_so=1600):\n    import gurobipy as gp\n    from gurobipy import GRB\n\n    # Create a new model\n    model = gp.Model(\"Crop_Profit_Maximization\")\n\n    # Decision variables\n    x_c = model.addVar(name=\"corn\", lb=0)\n    x_w = model.addVar(name=\"wheat\", lb=0)\n    x_s = model.addVar(name=\"soybeans\", lb=0)\n    x_so = model.addVar(name=\"sorghum\", lb=0)\n\n    # Set objective: maximize profit\n    model.setObjective(\n        profit_c * x_c + profit_w * x_w + profit_s * x_s + profit_so * x_so,\n        GRB.MAXIMIZE)\n\n    # Add constraints\n    # Total land constraint\n    model.addConstr(x_c + x_w + x_s + x_so <= total_land, \"TotalLand\")\n    # Wheat equals three times sorghum\n    model.addConstr(x_w == 3 * x_so, \"WheatSorghumRatio\")\n    # Corn at least twice wheat\n    model.addConstr(x_c >= 2 * x_w, \"CornWheatRatio\")\n    # Soybeans at least half sorghum\n    model.addConstr(x_s >= 0.5 * x_so, \"SoySorghumRatio\")\n\n    # Optimize the model\n    model.optimize()\n\n    # Check if a feasible solution was found\n    if model.status == GRB.OPTIMAL:\n        # Return the total profit of the optimal solution\n        return model.objVal\n    else:\n        # No feasible solution found\n        return None\nif __name__ == \"__main__\":\n    result = optimize_crop_allocation()\n    if result is not None:\n        print(f\"Optimal total profit: {result}\")\n    else:\n        print(\"No feasible solution found.\")", "output_status": [], "success_count": 0, "success_confidence": 0, "fail_to_diagnose": 0, "fail_to_verify": 0, "retrieved_insights": [], "tag": [{"problem_domain": "Resource Allocation", "modeling_type": "LP", "industry_sector": "Agriculture", "reason": "The problem involves allocating a limited resource (land) among competing activities (crop planting) to maximize profit, which is a classic resource allocation problem. The model uses linear objective and constraints with continuous variables, making it a Linear Program. The application is directly related to farming and crop production, hence 'Agriculture'."}], "cluster": null, "prompt": "Below is an operations research question. First formulate the problem as an optimization problem. Then according to the formulated problem, write python code that uses 'gurobipy' to solve the optimization problem. You should write a complete python code that can be executed to solve the optimization problem.\n\nIMPORTANT: Your code should follow these requirements:\n1. Create a Gurobi model variable named 'model' (not 'm' or other names)\n2. Include all necessary imports and data setup\n3. Write the complete optimization code that can run independently\n4. Do NOT wrap everything in a function - write the code directly\n5. Make sure the model is created and optimized in the main execution flow\n6. The code should print the optimal objective value when solved successfully\n\nExample format:\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Data setup\ndata = {...}\n\n# Create model\nmodel = gp.Model(\"ProblemName\")\n\n# Decision variables\nx = model.addVars(...)\n\n# Objective\nmodel.setObjective(...)\n\n# Constraints\nmodel.addConstr(...)\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\nelse:\n    print(\"No optimal solution found\")\n```\n\n# Question:\nTom and Jerry just bought a farm in Sunshine Valley, and they are considering using it to plant corn, wheat, soybeans, and sorghum. The profit per acre for planting corn is $1500, the profit per acre for planting wheat is $1200, the profit per acre for planting soybeans is $1800, and the profit per acre for planting sorghum is $1600. To maximize their profit, how many acres of land should they allocate to each crop? Tom and Jerry’s farm has a total area of 100 acres.\n\nThe land area used for planting corn must be at least twice the land area used for planting wheat.\n\nThe land area used for planting soybeans must be at least half the land area used for planting sorghum.\n\nThe land area used for planting wheat must be three times the land area used for planting sorghum.\n\n# Response:", "generated_output": "Below is the mathematical formulation followed by complete Python code using `gurobipy`.\n\n---\n\n## Optimization Model Formulation\n\nLet  \n- \\(x_c\\) = acres of corn  \n- \\(x_w\\) = acres of wheat  \n- \\(x_s\\) = acres of soybeans  \n- \\(x_{sg}\\) = acres of sorghum  \n\nAll decision variables are nonnegative:\n\\[\nx_c, x_w, x_s, x_{sg} \\ge 0\n\\]\n\n**Objective (maximize profit):**\n\\[\n\\max Z = 1500x_c + 1200x_w + 1800x_s + 1600x_{sg}\n\\]\n\n**Constraints:**\n\n1. Total land:\n\\[\nx_c + x_w + x_s + x_{sg} = 100\n\\]\n\n2. Corn at least twice wheat:\n\\[\nx_c \\ge 2x_w\n\\]\n\n3. Soybeans at least half sorghum:\n\\[\nx_s \\ge \\frac{1}{2}x_{sg}\n\\]\n\n4. Wheat is three times sorghum:\n\\[\nx_w = 3x_{sg}\n\\]\n\n---\n\n## Complete Python Code (Gurobi)\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Create model\nmodel = gp.Model(\"Tom_and_Jerry_Farm_Planning\")\n\n# Decision variables: acres of each crop (nonnegative)\nx_c = model.addVar(name=\"corn\", lb=0.0)\nx_w = model.addVar(name=\"wheat\", lb=0.0)\nx_s = model.addVar(name=\"soybeans\", lb=0.0)\nx_sg = model.addVar(name=\"sorghum\", lb=0.0)\n\n# Objective: maximize total profit\n# Profit per acre: corn=1500, wheat=1200, soybeans=1800, sorghum=1600\nmodel.setObjective(\n    1500 * x_c +\n    1200 * x_w +\n    1800 * x_s +\n    1600 * x_sg,\n    GRB.MAXIMIZE\n)\n\n# Constraints\n\n# 1. Total land is 100 acres\nmodel.addConstr(x_c + x_w + x_s + x_sg == 100, name=\"total_land\")\n\n# 2. Corn area at least twice wheat area: x_c >= 2 * x_w\nmodel.addConstr(x_c >= 2 * x_w, name=\"corn_vs_wheat\")\n\n# 3. Soybeans area at least half sorghum area: x_s >= 0.5 * x_sg\nmodel.addConstr(x_s >= 0.5 * x_sg, name=\"soybeans_vs_sorghum\")\n\n# 4. Wheat area is three times sorghum area: x_w = 3 * x_sg\nmodel.addConstr(x_w == 3 * x_sg, name=\"wheat_vs_sorghum\")\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\n    print(\"Optimal planting plan (acres):\")\n    print(f\"  Corn    : {x_c.X}\")\n    print(f\"  Wheat   : {x_w.X}\")\n    print(f\"  Soybeans: {x_s.X}\")\n    print(f\"  Sorghum : {x_sg.X}\")\nelse:\n    print(\"No optimal solution found\")\n```", "extracted_code": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create model\nmodel = gp.Model(\"Tom_and_Jerry_Farm_Planning\")\n\n# Decision variables: acres of each crop (nonnegative)\nx_c = model.addVar(name=\"corn\", lb=0.0)\nx_w = model.addVar(name=\"wheat\", lb=0.0)\nx_s = model.addVar(name=\"soybeans\", lb=0.0)\nx_sg = model.addVar(name=\"sorghum\", lb=0.0)\n\n# Objective: maximize total profit\n# Profit per acre: corn=1500, wheat=1200, soybeans=1800, sorghum=1600\nmodel.setObjective(\n    1500 * x_c +\n    1200 * x_w +\n    1800 * x_s +\n    1600 * x_sg,\n    GRB.MAXIMIZE\n)\n\n# Constraints\n\n# 1. Total land is 100 acres\nmodel.addConstr(x_c + x_w + x_s + x_sg == 100, name=\"total_land\")\n\n# 2. Corn area at least twice wheat area: x_c >= 2 * x_w\nmodel.addConstr(x_c >= 2 * x_w, name=\"corn_vs_wheat\")\n\n# 3. Soybeans area at least half sorghum area: x_s >= 0.5 * x_sg\nmodel.addConstr(x_s >= 0.5 * x_sg, name=\"soybeans_vs_sorghum\")\n\n# 4. Wheat area is three times sorghum area: x_w = 3 * x_sg\nmodel.addConstr(x_w == 3 * x_sg, name=\"wheat_vs_sorghum\")\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\n    print(\"Optimal planting plan (acres):\")\n    print(f\"  Corn    : {x_c.X}\")\n    print(f\"  Wheat   : {x_w.X}\")\n    print(f\"  Soybeans: {x_s.X}\")\n    print(f\"  Sorghum : {x_sg.X}\")\nelse:\n    print(\"No optimal solution found\")", "execution_success": true, "mathematical_accuracy": true, "execution_result": "Execution Successful", "execution_best_solution": 180000.0, "execution_state": "Execution Successful"}
{"task_id": "B084", "description": "A company is producing two products (X and Y). The resources required for the production of X and Y are divided into two parts: machine time for automated processing and craftsman time for manual finishing. The table below shows the number of minutes required for each product:\n\n| Item | Machine Time (minutes) | Craftsman Time (minutes) |\n| :---: | :---: | :---: |\n| X | 13 | 20 |\n| Y | 19 | 29 |\n\nThe company has 40 hours of machine time available in the next working week, but only 35 hours of craftsman time. The cost of machine time is £10 per hour, and the cost of craftsman time is £2 per hour. Idle time for machines and craftsmen incurs no cost. For each product produced (all products produced will be sold), the revenue for product X is £20, and the revenue for product Y is £30. The company has a specific contract that requires 10 units of product X to be produced for a customer each week. Formulate a model for this problem.", "ground_truth": 1861.466666667, "formulation": null, "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_production_profit_maximization():\n    \"\"\"\n    Solves the production planning problem to maximize weekly profit\n    for products X and Y, subject to time and contract constraints.\n    \"\"\"\n    try:\n        # --- Parameters ---\n        products = ['X', 'Y']\n\n        # Time requirements (minutes/unit)\n        machine_time_req = {'X': 13, 'Y': 19}\n        craftsman_time_req = {'X': 20, 'Y': 29}\n\n        # Time availability (minutes/week)\n        avail_machine_time = 40 * 60  # 2400 minutes\n        avail_craftsman_time = 35 * 60  # 2100 minutes\n\n        # Costs (per minute)\n        cost_machine_per_min = 10 / 60\n        cost_craftsman_per_min = 2 / 60\n\n        # Revenue (per unit)\n        revenue = {'X': 20, 'Y': 30}\n\n        # Contract requirement\n        min_production_X = 10\n\n        # Calculate profit per unit\n        profit_per_unit = {}\n        for p in products:\n            cost_machine = machine_time_req[p] * cost_machine_per_min\n            cost_craftsman = craftsman_time_req[p] * cost_craftsman_per_min\n            profit_per_unit[p] = revenue[p] - cost_machine - cost_craftsman\n            # print(f\"Profit per unit {p}: {profit_per_unit[p]:.4f}\") # For verification\n\n        # --- Create Gurobi Model ---\n        model = gp.Model(\"ProductionProfitMaximization\")\n\n        # --- Decision Variables ---\n        # N[p]: Number of units of product p produced per week\n        N = model.addVars(products, name=\"Produce\", vtype=GRB.INTEGER, lb=0)\n\n        # --- Objective Function: Maximize Total Profit ---\n        # Profit = Sum(Profit_per_unit[p] * N[p])\n        model.setObjective(\n            gp.quicksum(profit_per_unit[p] * N[p] for p in products),\n            GRB.MAXIMIZE)\n\n        # --- Constraints ---\n        # 1. Machine Time Constraint\n        model.addConstr(gp.quicksum(machine_time_req[p] * N[p]\n                                    for p in products) <= avail_machine_time,\n                        name=\"MachineTimeLimit\")\n\n        # 2. Craftsman Time Constraint\n        model.addConstr(gp.quicksum(craftsman_time_req[p] * N[p]\n                                    for p in products) <= avail_craftsman_time,\n                        name=\"CraftsmanTimeLimit\")\n\n        # 3. Contract Requirement for Product X\n        model.addConstr(N['X'] >= min_production_X, name=\"ContractX\")\n\n        # Suppress Gurobi output to console if desired\n        # model.setParam('OutputFlag', 0)\n\n        # Optimize the model\n        model.optimize()\n\n        # --- Results ---\n        if model.status == GRB.OPTIMAL:\n            print(\"Optimal production plan found.\")\n            print(f\"Maximum Weekly Profit: £{model.ObjVal:.2f}\")\n\n            print(\"\\nOptimal Production Quantities (units per week):\")\n            for p in products:\n                print(f\"  Product {p}: {N[p].X:.0f} units\")\n\n            print(\"\\nResource Utilization:\")\n            machine_time_used = sum(machine_time_req[p] * N[p].X\n                                    for p in products)\n            craftsman_time_used = sum(craftsman_time_req[p] * N[p].X\n                                      for p in products)\n            print(\n                f\"  Machine Time Used: {machine_time_used:.2f} / {avail_machine_time} minutes \"\n                f\"({(machine_time_used/avail_machine_time*100) if avail_machine_time > 0 else 0:.1f}%)\"\n            )\n            print(\n                f\"  Craftsman Time Used: {craftsman_time_used:.2f} / {avail_craftsman_time} minutes \"\n                f\"({(craftsman_time_used/avail_craftsman_time*100) if avail_craftsman_time > 0 else 0:.1f}%)\"\n            )\n\n            print(\"\\nContract Fulfillment:\")\n            print(\n                f\"  Product X Produced: {N['X'].X:.0f} (Min Required: {min_production_X})\"\n            )\n\n        elif model.status == GRB.INFEASIBLE:\n            print(\"Model is infeasible. Check constraints and requirements.\")\n            # Compute and print IIS (Irreducible Inconsistent Subsystem)\n            # model.computeIIS()\n            # model.write(\"production_profit_iis.ilp\")\n            # print(\"IIS written to production_profit_iis.ilp.\")\n        else:\n            print(f\"Optimization stopped with status: {model.status}\")\n            if model.SolCount == 0:\n                print(\"No feasible solution found.\")\n\n    except gp.GurobiError as e:\n        print(f\"Gurobi error code {e.errno}: {e}\")\n    except Exception as e:\n        print(f\"An unexpected error occurred: {e}\")\n\n\nif __name__ == '__main__':\n    solve_production_profit_maximization()", "output_status": [], "success_count": 0, "success_confidence": 0, "fail_to_diagnose": 0, "fail_to_verify": 0, "retrieved_insights": [], "tag": [{"problem_domain": "Production Planning", "modeling_type": "MILP", "industry_sector": "Manufacturing", "reason": "The problem involves determining optimal production quantities for products given resource constraints and aims to maximize profit, which is characteristic of Production Planning. The model uses integer decision variables and linear constraints and objective, making it a Mixed-Integer Linear Program."}], "cluster": null, "prompt": "Below is an operations research question. First formulate the problem as an optimization problem. Then according to the formulated problem, write python code that uses 'gurobipy' to solve the optimization problem. You should write a complete python code that can be executed to solve the optimization problem.\n\nIMPORTANT: Your code should follow these requirements:\n1. Create a Gurobi model variable named 'model' (not 'm' or other names)\n2. Include all necessary imports and data setup\n3. Write the complete optimization code that can run independently\n4. Do NOT wrap everything in a function - write the code directly\n5. Make sure the model is created and optimized in the main execution flow\n6. The code should print the optimal objective value when solved successfully\n\nExample format:\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Data setup\ndata = {...}\n\n# Create model\nmodel = gp.Model(\"ProblemName\")\n\n# Decision variables\nx = model.addVars(...)\n\n# Objective\nmodel.setObjective(...)\n\n# Constraints\nmodel.addConstr(...)\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\nelse:\n    print(\"No optimal solution found\")\n```\n\n# Question:\nA company is producing two products (X and Y). The resources required for the production of X and Y are divided into two parts: machine time for automated processing and craftsman time for manual finishing. The table below shows the number of minutes required for each product:\n\n| Item | Machine Time (minutes) | Craftsman Time (minutes) |\n| :---: | :---: | :---: |\n| X | 13 | 20 |\n| Y | 19 | 29 |\n\nThe company has 40 hours of machine time available in the next working week, but only 35 hours of craftsman time. The cost of machine time is £10 per hour, and the cost of craftsman time is £2 per hour. Idle time for machines and craftsmen incurs no cost. For each product produced (all products produced will be sold), the revenue for product X is £20, and the revenue for product Y is £30. The company has a specific contract that requires 10 units of product X to be produced for a customer each week. Formulate a model for this problem.\n\n# Response:", "generated_output": "Below is the mathematical formulation followed by a complete Gurobi Python implementation.\n\n---\n\n## Optimization Model Formulation\n\n**Decision variables**\n\n- \\( x \\ge 0 \\): number of units of product X to produce  \n- \\( y \\ge 0 \\): number of units of product Y to produce  \n\n(We will treat them as continuous and nonnegative; if they must be integers, we can make them integer variables.)\n\n**Parameters**\n\n- Machine time per unit:  \n  - Product X: 13 minutes  \n  - Product Y: 19 minutes  \n\n- Craftsman time per unit:  \n  - Product X: 20 minutes  \n  - Product Y: 29 minutes  \n\n- Available time:  \n  - Machine: 40 hours = \\(40 \\times 60 = 2400\\) minutes  \n  - Craftsman: 35 hours = \\(35 \\times 60 = 2100\\) minutes  \n\n- Costs (per hour):  \n  - Machine: £10/hour  \n  - Craftsman: £2/hour  \n\n  Convert to per minute:  \n  - Machine: \\(10/60\\) £/minute  \n  - Craftsman: \\(2/60\\) £/minute  \n\n- Revenues:  \n  - Product X: £20/unit  \n  - Product Y: £30/unit  \n\n- Contract requirement:  \n  - At least 10 units of X must be produced: \\(x \\ge 10\\)\n\n**Total revenue**\n\n\\[\nR = 20x + 30y\n\\]\n\n**Total cost**\n\nMachine time used (minutes): \\(13x + 19y\\)  \nCraftsman time used (minutes): \\(20x + 29y\\)\n\n\\[\nC = \\left(\\frac{10}{60}\\right)(13x + 19y) + \\left(\\frac{2}{60}\\right)(20x + 29y)\n\\]\n\n**Profit (objective)**\n\n\\[\n\\text{Profit} = R - C\n\\]\n\n\\[\n\\max \\; Z = 20x + 30y - \\left[\\left(\\frac{10}{60}\\right)(13x + 19y) + \\left(\\frac{2}{60}\\right)(20x + 29y)\\right]\n\\]\n\n**Constraints**\n\n1. Machine time availability:\n\\[\n13x + 19y \\le 2400\n\\]\n\n2. Craftsman time availability:\n\\[\n20x + 29y \\le 2100\n\\]\n\n3. Contract requirement:\n\\[\nx \\ge 10\n\\]\n\n4. Nonnegativity:\n\\[\nx \\ge 0,\\quad y \\ge 0\n\\]\n\n---\n\n## Gurobi Python Code\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# -----------------------------\n# Data setup\n# -----------------------------\n# Time requirements (minutes per unit)\nmachine_time = {'X': 13, 'Y': 19}\ncraft_time = {'X': 20, 'Y': 29}\n\n# Available time (hours)\nmachine_hours = 40\ncraft_hours = 35\n\n# Convert available time to minutes\nmachine_cap = machine_hours * 60  # 2400\ncraft_cap = craft_hours * 60      # 2100\n\n# Costs per hour\nmachine_cost_per_hour = 10.0\ncraft_cost_per_hour = 2.0\n\n# Convert costs to per minute\nmachine_cost_per_min = machine_cost_per_hour / 60.0\ncraft_cost_per_min = craft_cost_per_hour / 60.0\n\n# Revenues per unit\nrevenue = {'X': 20.0, 'Y': 30.0}\n\n# Contract requirement for product X\nmin_X = 10.0\n\n# -----------------------------\n# Create model\n# -----------------------------\nmodel = gp.Model(\"ProductionPlanning\")\n\n# -----------------------------\n# Decision variables\n# -----------------------------\n# x: units of product X\n# y: units of product Y\nx = model.addVar(name=\"x\", lb=0.0)\ny = model.addVar(name=\"y\", lb=0.0)\n\nmodel.update()\n\n# -----------------------------\n# Objective: maximize profit\n# -----------------------------\n# Revenue\ntotal_revenue = revenue['X'] * x + revenue['Y'] * y\n\n# Machine and craftsman time used\nmachine_used = machine_time['X'] * x + machine_time['Y'] * y\ncraft_used = craft_time['X'] * x + craft_time['Y'] * y\n\n# Total cost\ntotal_cost = machine_cost_per_min * machine_used + craft_cost_per_min * craft_used\n\n# Profit\nprofit = total_revenue - total_cost\n\nmodel.setObjective(profit, GRB.MAXIMIZE)\n\n# -----------------------------\n# Constraints\n# -----------------------------\n# Machine time capacity\nmodel.addConstr(machine_used <= machine_cap, name=\"MachineCapacity\")\n\n# Craftsman time capacity\nmodel.addConstr(craft_used <= craft_cap, name=\"CraftCapacity\")\n\n# Contract requirement: at least 10 units of X\nmodel.addConstr(x >= min_X, name=\"Contract_X\")\n\n# -----------------------------\n# Optimize\n# -----------------------------\nmodel.optimize()\n\n# -----------------------------\n# Results\n# -----------------------------\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value (maximum profit): {model.objVal:.4f}\")\n    print(f\"Optimal production of X: {x.X:.4f}\")\n    print(f\"Optimal production of Y: {y.X:.4f}\")\nelse:\n    print(\"No optimal solution found\")\n```", "extracted_code": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# -----------------------------\n# Data setup\n# -----------------------------\n# Time requirements (minutes per unit)\nmachine_time = {'X': 13, 'Y': 19}\ncraft_time = {'X': 20, 'Y': 29}\n\n# Available time (hours)\nmachine_hours = 40\ncraft_hours = 35\n\n# Convert available time to minutes\nmachine_cap = machine_hours * 60  # 2400\ncraft_cap = craft_hours * 60      # 2100\n\n# Costs per hour\nmachine_cost_per_hour = 10.0\ncraft_cost_per_hour = 2.0\n\n# Convert costs to per minute\nmachine_cost_per_min = machine_cost_per_hour / 60.0\ncraft_cost_per_min = craft_cost_per_hour / 60.0\n\n# Revenues per unit\nrevenue = {'X': 20.0, 'Y': 30.0}\n\n# Contract requirement for product X\nmin_X = 10.0\n\n# -----------------------------\n# Create model\n# -----------------------------\nmodel = gp.Model(\"ProductionPlanning\")\n\n# -----------------------------\n# Decision variables\n# -----------------------------\n# x: units of product X\n# y: units of product Y\nx = model.addVar(name=\"x\", lb=0.0)\ny = model.addVar(name=\"y\", lb=0.0)\n\nmodel.update()\n\n# -----------------------------\n# Objective: maximize profit\n# -----------------------------\n# Revenue\ntotal_revenue = revenue['X'] * x + revenue['Y'] * y\n\n# Machine and craftsman time used\nmachine_used = machine_time['X'] * x + machine_time['Y'] * y\ncraft_used = craft_time['X'] * x + craft_time['Y'] * y\n\n# Total cost\ntotal_cost = machine_cost_per_min * machine_used + craft_cost_per_min * craft_used\n\n# Profit\nprofit = total_revenue - total_cost\n\nmodel.setObjective(profit, GRB.MAXIMIZE)\n\n# -----------------------------\n# Constraints\n# -----------------------------\n# Machine time capacity\nmodel.addConstr(machine_used <= machine_cap, name=\"MachineCapacity\")\n\n# Craftsman time capacity\nmodel.addConstr(craft_used <= craft_cap, name=\"CraftCapacity\")\n\n# Contract requirement: at least 10 units of X\nmodel.addConstr(x >= min_X, name=\"Contract_X\")\n\n# -----------------------------\n# Optimize\n# -----------------------------\nmodel.optimize()\n\n# -----------------------------\n# Results\n# -----------------------------\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value (maximum profit): {model.objVal:.4f}\")\n    print(f\"Optimal production of X: {x.X:.4f}\")\n    print(f\"Optimal production of Y: {y.X:.4f}\")\nelse:\n    print(\"No optimal solution found\")", "execution_success": true, "mathematical_accuracy": true, "execution_result": "Execution Successful", "execution_best_solution": 1866.379310344828, "execution_state": "Execution Successful"}
{"task_id": "B002", "description": "For the manufacturing industry, formulating an appropriate product production plan and human resource management scheme is very important for reducing operating costs, inventory costs, stockout costs, and labor costs. Specifically, for products with large demand fluctuations, companies need to accurately predict demand and formulate corresponding production plans. A certain company produces a type of foldable table, the raw material cost for each product is 90 Yuan, and the labor hours are 5 hours. The unit price of the product is 300 Yuan. The company has 1,000 workers at the beginning of January and holds an inventory of 15,000 units. The regular hourly wage for workers is 30 Yuan, with a normal daily working time of 8 hours. Any extra working time is considered overtime, with an overtime hourly wage of 40 Yuan. The number of working days per month is calculated as 20 days. Suppose the company's available production machines are sufficient, and the capacity is not limited by machine hours. Each worker's overtime hours do not exceed 20 hours per month. Holding inventory will generate corresponding inventory costs. If a stockout occurs due to insufficient capacity, there will be certain stockout costs. Additionally, the company can also make up for the stockout part through outsourcing. The outsourcing cost per product, monthly inventory cost, and monthly stockout cost are 200 Yuan, 15 Yuan, and 35 Yuan, respectively. The company's employees are temporary workers, and the company can flexibly decide the number of people to hire and fire each month. The cost of hiring and firing a single employee is 5,000 Yuan and 8,000 Yuan, respectively. Suppose the company has used the existing forecasting model to predict the demand from January to June, as shown in Table 4.1.\n\nTable 4.1: Demand Forecast\n\n| Month | 1   | 2   | 3   | 4   | 5   | 6   |\n|:-----:|:---:|:---:|:---:|:---:|:---:|:---:|\n| Demand Forecast | 20000 | 40000 | 42000 | 35000 | 19000 | 18500 |\n\nPlease formulate a production plan, worker work schedule, and hire/fire plan for the company to maximize the total net profit over 6 months while ensuring that the company holds at least 10,000 units of products by the end of June.", "ground_truth": 10349920.0, "formulation": null, "correct_program": "from gurobipy import Model, GRB, quicksum\n# import gurobipy # This line is redundant and has been removed\n\n\ndef solve_production_planning_revised():\n    # --- Model Initialization ---\n    # --- 模型初始化 ---\n    m = Model(\"FoldableTableProductionRevised\")\n\n    # --- Time Horizon ---\n    # --- 时间范围 ---\n    months = list(range(6))\n    month_names = [\"January\", \"February\", \"March\", \"April\", \"May\",\n                   \"June\"]  # 月份名称\n\n    # --- Parameters ---\n    # --- 参数 ---\n    raw_material_cost_per_unit = 90  # 原材料成本/单位 (元)\n    regular_hourly_wage = 30  # 正常时薪 (元)\n    overtime_hourly_wage = 40  # 加班时薪 (元)\n    inventory_cost_per_unit_per_month = 15  # 库存成本/单位/月 (元)\n    stockout_penalty_per_unmet_unit = 35  # 最终未满足需求的缺货成本/单位 (元)\n    outsourcing_cost_per_unit = 200  # 外包成本/单位 (元)\n    hiring_cost_per_worker = 5000  # 雇佣成本/人 (元)\n    firing_cost_per_worker = 8000  # 解雇成本/人 (元)\n\n    labor_hours_per_unit = 5  # 单位产品所需工时 (小时)\n    selling_price_per_unit = 300  # 单位产品售价 (元)\n\n    initial_workers = 1000  # 初始工人数\n    normal_daily_working_hours = 8  # 每日正常工作时长 (小时)\n    working_days_per_month = 20  # 每月工作天数\n    normal_hours_per_worker_per_month = normal_daily_working_hours * working_days_per_month  # 每人每月正常工作时长 (小时)\n    max_overtime_hours_per_worker_per_month = 20  # 每人每月最大加班时长 (小时)\n\n    initial_inventory = 15000  # 初始库存 (单位)\n    min_ending_inventory_june = 10000  # 六月底最低期末库存 (单位)\n\n    # Demand Forecast (units per month)\n    # 需求预测 (单位/月)\n    demand_forecast = {\n        0: 20000,  # January  (一月)\n        1: 40000,  # February (二月)\n        2: 42000,  # March    (三月)\n        3: 35000,  # April    (四月)\n        4: 19000,  # May      (五月)\n        5: 18500  # June     (六月)\n    }\n\n    # --- Decision Variables ---\n    # --- 决策变量 ---\n    # P[t]: Production quantity in month t\n    # P[t]: 月份 t 的生产数量\n    P = m.addVars(months, name=\"Production\", vtype=GRB.INTEGER, lb=0)\n    # W[t]: Number of workers during month t (after hiring/firing)\n    # W[t]: 月份 t 的工人数 (雇佣/解雇后)\n    W = m.addVars(months, name=\"Workers\", vtype=GRB.INTEGER, lb=0)\n    # H[t]: Number of workers hired at the start of month t\n    # H[t]: 月份 t 初雇佣的工人数\n    H = m.addVars(months, name=\"Hired\", vtype=GRB.INTEGER, lb=0)\n    # F[t]: Number of workers fired at the start of month t\n    # F[t]: 月份 t 初解雇的工人数\n    F = m.addVars(months, name=\"Fired\", vtype=GRB.INTEGER, lb=0)\n    # OT_total[t]: Total overtime hours in month t\n    # OT_total[t]: 月份 t 的总加班工时\n    OT_total = m.addVars(months,\n                         name=\"OvertimeHours\",\n                         vtype=GRB.CONTINUOUS,\n                         lb=0)\n    OT_total = m.addVars(months, name=\"OvertimeHours\", vtype=GRB.INTEGER, lb=0)\n    # Inv[t]: Inventory at the end of month t\n    # Inv[t]: 月份 t 的期末库存\n    Inv = m.addVars(months, name=\"Inventory\", vtype=GRB.INTEGER, lb=0)\n    # Outsource[t]: Units outsourced in month t\n    # Outsource[t]: 月份 t 的外包数量\n    Outsource = m.addVars(months, name=\"Outsourced\", vtype=GRB.INTEGER, lb=0)\n    # S[t]: Final unmet demand (stockout) in month t\n    # S[t]: 月份 t 的最终未满足需求 (缺货) 数量\n    S = m.addVars(months, name=\"StockoutUnmet\", vtype=GRB.INTEGER, lb=0)\n\n    # --- Objective Function: Maximize Total Net Profit ---\n    # --- 目标函数: 最大化总净利润 ---\n    # Revenue is based on units sold (Demand - Unmet Stockout)\n    # 收入基于销售数量 (需求 - 未满足的缺货)\n    total_revenue = quicksum(\n        (demand_forecast[t] - S[t]) * selling_price_per_unit for t in months)\n\n    total_raw_material_cost = quicksum(P[t] * raw_material_cost_per_unit\n                                       for t in months)\n    total_regular_labor_cost = quicksum(\n        W[t] * normal_hours_per_worker_per_month * regular_hourly_wage\n        for t in months)\n    total_overtime_labor_cost = quicksum(OT_total[t] * overtime_hourly_wage\n                                         for t in months)\n    total_inventory_cost = quicksum(Inv[t] * inventory_cost_per_unit_per_month\n                                    for t in months)\n    # Outsourcing cost is now separate\n    # 外包成本现在是分开的\n    total_outsourcing_cost = quicksum(Outsource[t] * outsourcing_cost_per_unit\n                                      for t in months)\n    # Stockout cost for final unmet demand\n    # 最终未满足需求的缺货成本\n    total_stockout_unmet_cost = quicksum(S[t] * stockout_penalty_per_unmet_unit\n                                         for t in months)\n    total_hiring_cost = quicksum(H[t] * hiring_cost_per_worker for t in months)\n    total_firing_cost = quicksum(F[t] * firing_cost_per_worker for t in months)\n\n    total_costs = (\n        total_raw_material_cost + total_regular_labor_cost +\n        total_overtime_labor_cost + total_inventory_cost +\n        total_outsourcing_cost + total_stockout_unmet_cost\n        +  # Added stockout cost for S[t] # 为S[t]添加了缺货成本\n        total_hiring_cost + total_firing_cost)\n\n    m.setObjective(total_revenue - total_costs, GRB.MAXIMIZE)\n\n    # --- Constraints ---\n    # --- 约束条件 ---\n    for t in months:\n        # 1. Worker Balance Constraint\n        # 1. 工人数量平衡约束\n        if t == 0:\n            m.addConstr(W[t] == initial_workers + H[t] - F[t],\n                        name=f\"WorkerBalance_Month{t}\")\n        else:\n            m.addConstr(W[t] == W[t - 1] + H[t] - F[t],\n                        name=f\"WorkerBalance_Month{t}\")\n\n        # 2. Production Labor Hours Constraint\n        # 2. 生产工时约束\n        m.addConstr(P[t] * labor_hours_per_unit\n                    <= (W[t] * normal_hours_per_worker_per_month) +\n                    OT_total[t],\n                    name=f\"ProductionCapacity_Month{t}\")\n\n        # 3. Overtime Limit Constraint\n        # 3. 加班上限约束\n        m.addConstr(OT_total[t]\n                    <= W[t] * max_overtime_hours_per_worker_per_month,\n                    name=f\"OvertimeLimit_Month{t}\")\n\n        # 4. Inventory Balance Constraint (Revised)\n        # 4. 库存平衡约束 (修订版)\n        # Inv[t] = Previous_Inv + P[t] + Outsource[t] - (Demand[t] - S[t])\n        # This means: Ending_Inv + Sold_Units = Starting_Inv + Produced_Units + Outsourced_Units\n        # 这意味着: 期末库存 + 销售数量 = 期初库存 + 生产数量 + 外包数量\n        sold_units_t = demand_forecast[t] - S[t]\n        if t == 0:\n            m.addConstr(Inv[t] == initial_inventory + P[t] + Outsource[t] -\n                        sold_units_t,\n                        name=f\"InventoryBalance_Month{t}\")\n        else:\n            m.addConstr(Inv[t] == Inv[t - 1] + P[t] + Outsource[t] -\n                        sold_units_t,\n                        name=f\"InventoryBalance_Month{t}\")\n\n        # 5. Stockout (Unmet Demand) Definition Constraints (Linearized max function)\n        # 5. 缺货 (未满足需求) 定义约束 (线性化的max函数)\n        # S[t] >= Demand[t] - Previous_Inv - P[t] - Outsource[t]\n        # S[t] >= 0 (handled by lb=0 on variable S) (通过变量S的lb=0处理)\n        if t == 0:\n            m.addConstr(S[t] >= demand_forecast[t] - initial_inventory - P[t] -\n                        Outsource[t],\n                        name=f\"StockoutDef_Month{t}\")\n        else:\n            m.addConstr(S[t] >= demand_forecast[t] - Inv[t - 1] - P[t] -\n                        Outsource[t],\n                        name=f\"StockoutDef_Month{t}\")\n\n    # 6. Minimum Ending Inventory Constraint (for June - month 5)\n    # 6. 最低期末库存约束 (六月份 - 月份5)\n    m.addConstr(Inv[months[-1]] >= min_ending_inventory_june,\n                name=\"MinEndingInventory\")\n\n    # --- Solve Model ---\n    # --- 求解模型 ---\n    m.optimize()\n\n    # --- Print Results ---\n    # --- 打印结果 ---\n    if m.status == GRB.OPTIMAL:\n        print(\n            f\"\\nOptimal Solution Found. Total Net Profit: {m.objVal:,.2f} Yuan\"\n        )\n        print(\"-\" * 60)\n        print(\"Monthly Plan:\")\n        print(\"-\" * 60)\n        header = (\n            f\"{'Month':<10} | {'Demand':>8} | {'Sold':>8} | {'Unmet (S)':>9} | {'Workers':>7} | {'Hired':>6} | {'Fired':>6} | \"\n            f\"{'Production':>10} | {'Outsourced':>10} | {'OvertimeH':>10} | {'Avg OT/W':>8} | {'End Inv':>10}\"\n        )\n        print(header)\n        print(\"=\" * len(header))\n\n        total_prod = 0\n        total_outs = 0\n        total_hired = 0\n        total_fired = 0\n        total_ot = 0\n        total_unmet_s = 0\n        total_sold = 0\n\n        for t in months:\n            workers_t = W[t].X\n            avg_ot_per_worker = (OT_total[t].X /\n                                 workers_t) if workers_t > 0 else 0\n            sold_t = demand_forecast[t] - S[t].X\n            total_sold += sold_t\n            total_unmet_s += S[t].X\n            print(\n                f\"{month_names[t]:<10} | {demand_forecast[t]:>8,.0f} | {sold_t:>8,.0f} | {S[t].X:>9,.2f} | \"\n                f\"{workers_t:>7,.0f} | {H[t].X:>6,.0f} | {F[t].X:>6,.0f} | \"\n                f\"{P[t].X:>10,.2f} | {Outsource[t].X:>10,.2f} | {OT_total[t].X:>10,.2f} | \"\n                f\"{avg_ot_per_worker:>8,.2f} | {Inv[t].X:>10,.2f}\")\n            total_prod += P[t].X\n            total_outs += Outsource[t].X\n            total_hired += H[t].X\n            total_fired += F[t].X\n            total_ot += OT_total[t].X\n\n        print(\"=\" * len(header))\n        print(\"Summary over 6 months:\")\n        print(f\"Total Demand: {sum(demand_forecast.values()):,.0f} units\")\n        print(f\"Total Sold: {total_sold:,.0f} units\")\n        print(f\"Total Unmet Demand (S): {total_unmet_s:,.2f} units\")\n        print(f\"Total Production: {total_prod:,.2f} units\")\n        print(f\"Total Outsourced: {total_outs:,.2f} units\")\n        print(f\"Total Hired: {total_hired:,.0f} workers\")\n        print(f\"Total Fired: {total_fired:,.0f} workers\")\n        print(f\"Total Overtime Hours: {total_ot:,.2f} hours\")\n        print(\n            f\"Ending Inventory (June): {Inv[months[-1]].X:,.2f} units (Min required: {min_ending_inventory_june:,})\"\n        )\n        print(\"-\" * 60)\n\n        # Recalculate costs and revenue for verification\n        # 重新计算成本和收入以进行验证\n        calc_revenue = sum(\n            (demand_forecast[t] - S[t].X) * selling_price_per_unit\n            for t in months)\n        calc_rm_cost = sum(P[t].X * raw_material_cost_per_unit for t in months)\n        calc_reg_labor_cost = sum(W[t].X * normal_hours_per_worker_per_month *\n                                  regular_hourly_wage for t in months)\n        calc_ot_labor_cost = sum(OT_total[t].X * overtime_hourly_wage\n                                 for t in months)\n        calc_inv_cost = sum(Inv[t].X * inventory_cost_per_unit_per_month\n                            for t in months)\n        calc_outs_cost = sum(Outsource[t].X * outsourcing_cost_per_unit\n                             for t in months)\n        calc_stockout_unmet_cost = sum(S[t].X * stockout_penalty_per_unmet_unit\n                                       for t in months)\n        calc_hir_cost = sum(H[t].X * hiring_cost_per_worker for t in months)\n        calc_fir_cost = sum(F[t].X * firing_cost_per_worker for t in months)\n        calc_total_costs = calc_rm_cost + calc_reg_labor_cost + calc_ot_labor_cost + calc_inv_cost + calc_outs_cost + calc_stockout_unmet_cost + calc_hir_cost + calc_fir_cost\n\n        print(\n            \"\\nBreakdown of Total Revenue and Costs (Calculated from solution):\"\n        )\n        print(f\"  Total Revenue (from sold units): {calc_revenue:,.2f} Yuan\")\n        print(f\"  Total Raw Material Cost: {calc_rm_cost:,.2f} Yuan\")\n        print(f\"  Total Regular Labor Cost: {calc_reg_labor_cost:,.2f} Yuan\")\n        print(f\"  Total Overtime Labor Cost: {calc_ot_labor_cost:,.2f} Yuan\")\n        print(f\"  Total Inventory Cost: {calc_inv_cost:,.2f} Yuan\")\n        print(f\"  Total Outsourcing Cost (base): {calc_outs_cost:,.2f} Yuan\")\n        print(\n            f\"  Total Stockout Unmet Cost (for S>0): {calc_stockout_unmet_cost:,.2f} Yuan\"\n        )\n        print(f\"  Total Hiring Cost: {calc_hir_cost:,.2f} Yuan\")\n        print(f\"  Total Firing Cost: {calc_fir_cost:,.2f} Yuan\")\n        print(f\"  Calculated Total Costs: {calc_total_costs:,.2f} Yuan\")\n        print(\n            f\"  Calculated Net Profit (Revenue - Costs): {calc_revenue - calc_total_costs:,.2f} Yuan (Should match Gurobi's m.objVal)\"\n        )\n\n    elif m.status == GRB.INFEASIBLE:\n        print(\"Model is infeasible. Check constraints.\")  # 模型不可行，请检查约束\n        m.computeIIS()\n        m.write(\"model_revised_iis.ilp\")\n        print(\"IIS written to model_revised_iis.ilp\"\n              )  # IIS已写入model_revised_iis.ilp\n    elif m.status == GRB.UNBOUNDED:\n        print(\"Model is unbounded.\")  # 模型无界\n    else:\n        print(\n            f\"Optimization was stopped with status {m.status}\")  # 优化已停止，状态为...\n\n\nif __name__ == '__main__':\n    solve_production_planning_revised()", "output_status": [], "success_count": 0, "success_confidence": 0, "fail_to_diagnose": 0, "fail_to_verify": 0, "retrieved_insights": [], "tag": [{"problem_domain": "Production Planning", "modeling_type": "MILP", "industry_sector": "Manufacturing", "reason": "The problem involves determining production quantities, workforce levels (hiring/firing), and inventory over multiple periods to maximize profit, which is a classic production planning problem. The solver uses integer variables for production, workers, hiring, firing, inventory, outsourcing, and stockout, along with linear constraints and objective, making it a Mixed-Integer Linear Program."}], "cluster": null, "prompt": "Below is an operations research question. First formulate the problem as an optimization problem. Then according to the formulated problem, write python code that uses 'gurobipy' to solve the optimization problem. You should write a complete python code that can be executed to solve the optimization problem.\n\nIMPORTANT: Your code should follow these requirements:\n1. Create a Gurobi model variable named 'model' (not 'm' or other names)\n2. Include all necessary imports and data setup\n3. Write the complete optimization code that can run independently\n4. Do NOT wrap everything in a function - write the code directly\n5. Make sure the model is created and optimized in the main execution flow\n6. The code should print the optimal objective value when solved successfully\n\nExample format:\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Data setup\ndata = {...}\n\n# Create model\nmodel = gp.Model(\"ProblemName\")\n\n# Decision variables\nx = model.addVars(...)\n\n# Objective\nmodel.setObjective(...)\n\n# Constraints\nmodel.addConstr(...)\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\nelse:\n    print(\"No optimal solution found\")\n```\n\n# Question:\nFor the manufacturing industry, formulating an appropriate product production plan and human resource management scheme is very important for reducing operating costs, inventory costs, stockout costs, and labor costs. Specifically, for products with large demand fluctuations, companies need to accurately predict demand and formulate corresponding production plans. A certain company produces a type of foldable table, the raw material cost for each product is 90 Yuan, and the labor hours are 5 hours. The unit price of the product is 300 Yuan. The company has 1,000 workers at the beginning of January and holds an inventory of 15,000 units. The regular hourly wage for workers is 30 Yuan, with a normal daily working time of 8 hours. Any extra working time is considered overtime, with an overtime hourly wage of 40 Yuan. The number of working days per month is calculated as 20 days. Suppose the company's available production machines are sufficient, and the capacity is not limited by machine hours. Each worker's overtime hours do not exceed 20 hours per month. Holding inventory will generate corresponding inventory costs. If a stockout occurs due to insufficient capacity, there will be certain stockout costs. Additionally, the company can also make up for the stockout part through outsourcing. The outsourcing cost per product, monthly inventory cost, and monthly stockout cost are 200 Yuan, 15 Yuan, and 35 Yuan, respectively. The company's employees are temporary workers, and the company can flexibly decide the number of people to hire and fire each month. The cost of hiring and firing a single employee is 5,000 Yuan and 8,000 Yuan, respectively. Suppose the company has used the existing forecasting model to predict the demand from January to June, as shown in Table 4.1.\n\nTable 4.1: Demand Forecast\n\n| Month | 1   | 2   | 3   | 4   | 5   | 6   |\n|:-----:|:---:|:---:|:---:|:---:|:---:|:---:|\n| Demand Forecast | 20000 | 40000 | 42000 | 35000 | 19000 | 18500 |\n\nPlease formulate a production plan, worker work schedule, and hire/fire plan for the company to maximize the total net profit over 6 months while ensuring that the company holds at least 10,000 units of products by the end of June.\n\n# Response:", "generated_output": "Below is a mathematical formulation followed by complete Gurobi Python code.\n\n---\n\n## 1. Optimization Model Formulation\n\n### Indices\n- \\( t \\in \\{1,2,3,4,5,6\\} \\): months (January–June)\n\n### Parameters\n- \\( D_t \\): demand in month \\( t \\)  \n  \\( D = [20000, 40000, 42000, 35000, 19000, 18500] \\)\n- Selling price per unit: \\( p = 300 \\)\n- Raw material cost per unit: \\( c_m = 90 \\)\n- Regular wage per hour: \\( w_r = 30 \\)\n- Overtime wage per hour: \\( w_o = 40 \\)\n- Working days per month: \\( d = 20 \\)\n- Regular hours per worker per month: \\( H_r = 8 \\times d = 160 \\)\n- Max overtime hours per worker per month: \\( H_o^{\\max} = 20 \\)\n- Labor hours per unit: \\( h = 5 \\)\n- Outsourcing cost per unit: \\( c_{out} = 200 \\)\n- Inventory holding cost per unit per month: \\( c_{inv} = 15 \\)\n- Stockout cost per unit per month: \\( c_{short} = 35 \\)\n- Hiring cost per worker: \\( c_{hire} = 5000 \\)\n- Firing cost per worker: \\( c_{fire} = 8000 \\)\n- Initial workers: \\( W_0 = 1000 \\)\n- Initial inventory: \\( I_0 = 15000 \\)\n- Required ending inventory at end of month 6: \\( I_6 \\ge 10000 \\)\n\n### Decision Variables (for each month \\( t \\))\n- \\( W_t \\ge 0 \\): number of workers at end of month \\( t \\)\n- \\( H_t \\ge 0 \\): number of workers hired in month \\( t \\)\n- \\( F_t \\ge 0 \\): number of workers fired in month \\( t \\)\n- \\( P_t \\ge 0 \\): units produced in-house in month \\( t \\)\n- \\( O_t \\ge 0 \\): total overtime hours in month \\( t \\)\n- \\( X_t \\ge 0 \\): units outsourced in month \\( t \\)\n- \\( I_t \\ge 0 \\): inventory at end of month \\( t \\)\n- \\( B_t \\ge 0 \\): backorders (stockouts) carried from month \\( t \\) to \\( t+1 \\)\n\n### Relationships and Constraints\n\n1. **Workforce balance**\n\\[\nW_t = W_{t-1} + H_t - F_t, \\quad t=1,\\dots,6\n\\]\nwith \\( W_0 = 1000 \\).\n\n2. **Production capacity (labor hours)**\nTotal available labor hours in month \\( t \\):\n\\[\n\\text{Regular hours} = W_t \\cdot H_r\n\\]\n\\[\n\\text{Overtime hours} = O_t\n\\]\nTotal hours used for production:\n\\[\nh \\cdot P_t \\le W_t \\cdot H_r + O_t, \\quad t=1,\\dots,6\n\\]\n\n3. **Overtime limit**\n\\[\nO_t \\le W_t \\cdot H_o^{\\max}, \\quad t=1,\\dots,6\n\\]\n\n4. **Inventory–backorder balance**\nLet \\( I_0 = 15000 \\) and \\( B_0 = 0 \\). For each month \\( t \\):\n\\[\nI_{t-1} + P_t + X_t + B_t = D_t + I_t + B_{t-1}, \\quad t=1,\\dots,6\n\\]\nThis ensures that starting inventory plus production plus outsourcing plus new backorders equals demand plus ending inventory plus previous backorders.\n\n5. **Ending inventory requirement**\n\\[\nI_6 \\ge 10000\n\\]\n\n6. **Non-negativity**\nAll decision variables are non-negative.\n\n### Objective Function\n\nMaximize total net profit over 6 months:\n\nRevenue:\n\\[\n\\text{Revenue} = \\sum_{t=1}^{6} p \\cdot D_t\n\\]\n\nCosts:\n- Raw material: \\( \\sum_{t=1}^{6} c_m \\cdot P_t \\)\n- Regular wages: \\( \\sum_{t=1}^{6} w_r \\cdot W_t \\cdot H_r \\)\n- Overtime wages: \\( \\sum_{t=1}^{6} w_o \\cdot O_t \\)\n- Outsourcing: \\( \\sum_{t=1}^{6} c_{out} \\cdot X_t \\)\n- Inventory holding: \\( \\sum_{t=1}^{6} c_{inv} \\cdot I_t \\)\n- Stockout (backorder) cost: \\( \\sum_{t=1}^{6} c_{short} \\cdot B_t \\)\n- Hiring: \\( \\sum_{t=1}^{6} c_{hire} \\cdot H_t \\)\n- Firing: \\( \\sum_{t=1}^{6} c_{fire} \\cdot F_t \\)\n\nObjective:\n\\[\n\\max \\; Z = \\sum_{t=1}^{6} p D_t\n- \\sum_{t=1}^{6} \\Big(\nc_m P_t + w_r W_t H_r + w_o O_t + c_{out} X_t\n+ c_{inv} I_t + c_{short} B_t + c_{hire} H_t + c_{fire} F_t\n\\Big)\n\\]\n\n---\n\n## 2. Complete Gurobi Python Code\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# -----------------------------\n# Data setup\n# -----------------------------\nmonths = range(1, 7)  # 1..6\n\ndemand = {\n    1: 20000,\n    2: 40000,\n    3: 42000,\n    4: 35000,\n    5: 19000,\n    6: 18500\n}\n\n# Parameters\nprice = 300          # selling price per unit\nraw_cost = 90        # raw material cost per unit\nwage_regular = 30    # regular wage per hour\nwage_overtime = 40   # overtime wage per hour\ndays_per_month = 20\nregular_hours_per_day = 8\nH_r = days_per_month * regular_hours_per_day  # 160 hours/month\nH_o_max = 20          # max overtime hours per worker per month\nlabor_hours_per_unit = 5\n\noutsourcing_cost = 200\ninventory_cost = 15\nstockout_cost = 35\nhire_cost = 5000\nfire_cost = 8000\n\ninitial_workers = 1000\ninitial_inventory = 15000\nrequired_final_inventory = 10000\n\n# -----------------------------\n# Create model\n# -----------------------------\nmodel = gp.Model(\"Production_Workforce_Planning\")\n\n# -----------------------------\n# Decision variables\n# -----------------------------\n# Workforce\nW = model.addVars(months, name=\"Workers\", lb=0)      # workers at end of month t\nH = model.addVars(months, name=\"Hired\", lb=0)        # workers hired in month t\nF = model.addVars(months, name=\"Fired\", lb=0)        # workers fired in month t\n\n# Production and capacity\nP = model.addVars(months, name=\"Production\", lb=0)   # in-house production units\nO = model.addVars(months, name=\"OvertimeHours\", lb=0)  # total overtime hours\n\n# Outsourcing\nX = model.addVars(months, name=\"Outsourced\", lb=0)   # outsourced units\n\n# Inventory and backorders\nI = model.addVars(months, name=\"Inventory\", lb=0)    # end-of-month inventory\nB = model.addVars(months, name=\"Backorder\", lb=0)    # backorders carried to next month\n\n# -----------------------------\n# Constraints\n# -----------------------------\n\n# Workforce balance\nfor t in months:\n    if t == 1:\n        model.addConstr(W[t] == initial_workers + H[t] - F[t],\n                        name=f\"WorkforceBalance_{t}\")\n    else:\n        model.addConstr(W[t] == W[t-1] + H[t] - F[t],\n                        name=f\"WorkforceBalance_{t}\")\n\n# Production capacity (labor hours)\nfor t in months:\n    model.addConstr(\n        labor_hours_per_unit * P[t] <= W[t] * H_r + O[t],\n        name=f\"Capacity_{t}\"\n    )\n\n# Overtime limit\nfor t in months:\n    model.addConstr(\n        O[t] <= W[t] * H_o_max,\n        name=f\"OvertimeLimit_{t}\"\n    )\n\n# Inventory and backorder balance\nfor t in months:\n    if t == 1:\n        prev_inventory = initial_inventory\n        prev_backorder = 0\n    else:\n        prev_inventory = I[t-1]\n        prev_backorder = B[t-1]\n\n    # I_{t-1} + P_t + X_t + B_t = D_t + I_t + B_{t-1}\n    model.addConstr(\n        prev_inventory + P[t] + X[t] + B[t] ==\n        demand[t] + I[t] + prev_backorder,\n        name=f\"InvBackorderBalance_{t}\"\n    )\n\n# Ending inventory requirement\nmodel.addConstr(I[6] >= required_final_inventory, name=\"FinalInventoryRequirement\")\n\n# -----------------------------\n# Objective: Maximize total net profit\n# -----------------------------\n\n# Revenue is fixed given demand\ntotal_revenue = sum(price * demand[t] for t in months)\n\n# Costs\ntotal_raw_cost = gp.quicksum(raw_cost * P[t] for t in months)\ntotal_regular_wage = gp.quicksum(wage_regular * W[t] * H_r for t in months)\ntotal_overtime_wage = gp.quicksum(wage_overtime * O[t] for t in months)\ntotal_outsourcing_cost = gp.quicksum(outsourcing_cost * X[t] for t in months)\ntotal_inventory_cost = gp.quicksum(inventory_cost * I[t] for t in months)\ntotal_stockout_cost = gp.quicksum(stockout_cost * B[t] for t in months)\ntotal_hire_cost = gp.quicksum(hire_cost * H[t] for t in months)\ntotal_fire_cost = gp.quicksum(fire_cost * F[t] for t in months)\n\ntotal_cost = (total_raw_cost + total_regular_wage + total_overtime_wage +\n              total_outsourcing_cost + total_inventory_cost + total_stockout_cost +\n              total_hire_cost + total_fire_cost)\n\nmodel.setObjective(total_revenue - total_cost, GRB.MAXIMIZE)\n\n# -----------------------------\n# Optimize\n# -----------------------------\nmodel.optimize()\n\n# -----------------------------\n# Results\n# -----------------------------\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\nelse:\n    print(\"No optimal solution found\")\n```", "extracted_code": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# -----------------------------\n# Data setup\n# -----------------------------\nmonths = range(1, 7)  # 1..6\n\ndemand = {\n    1: 20000,\n    2: 40000,\n    3: 42000,\n    4: 35000,\n    5: 19000,\n    6: 18500\n}\n\n# Parameters\nprice = 300          # selling price per unit\nraw_cost = 90        # raw material cost per unit\nwage_regular = 30    # regular wage per hour\nwage_overtime = 40   # overtime wage per hour\ndays_per_month = 20\nregular_hours_per_day = 8\nH_r = days_per_month * regular_hours_per_day  # 160 hours/month\nH_o_max = 20          # max overtime hours per worker per month\nlabor_hours_per_unit = 5\n\noutsourcing_cost = 200\ninventory_cost = 15\nstockout_cost = 35\nhire_cost = 5000\nfire_cost = 8000\n\ninitial_workers = 1000\ninitial_inventory = 15000\nrequired_final_inventory = 10000\n\n# -----------------------------\n# Create model\n# -----------------------------\nmodel = gp.Model(\"Production_Workforce_Planning\")\n\n# -----------------------------\n# Decision variables\n# -----------------------------\n# Workforce\nW = model.addVars(months, name=\"Workers\", lb=0)      # workers at end of month t\nH = model.addVars(months, name=\"Hired\", lb=0)        # workers hired in month t\nF = model.addVars(months, name=\"Fired\", lb=0)        # workers fired in month t\n\n# Production and capacity\nP = model.addVars(months, name=\"Production\", lb=0)   # in-house production units\nO = model.addVars(months, name=\"OvertimeHours\", lb=0)  # total overtime hours\n\n# Outsourcing\nX = model.addVars(months, name=\"Outsourced\", lb=0)   # outsourced units\n\n# Inventory and backorders\nI = model.addVars(months, name=\"Inventory\", lb=0)    # end-of-month inventory\nB = model.addVars(months, name=\"Backorder\", lb=0)    # backorders carried to next month\n\n# -----------------------------\n# Constraints\n# -----------------------------\n\n# Workforce balance\nfor t in months:\n    if t == 1:\n        model.addConstr(W[t] == initial_workers + H[t] - F[t],\n                        name=f\"WorkforceBalance_{t}\")\n    else:\n        model.addConstr(W[t] == W[t-1] + H[t] - F[t],\n                        name=f\"WorkforceBalance_{t}\")\n\n# Production capacity (labor hours)\nfor t in months:\n    model.addConstr(\n        labor_hours_per_unit * P[t] <= W[t] * H_r + O[t],\n        name=f\"Capacity_{t}\"\n    )\n\n# Overtime limit\nfor t in months:\n    model.addConstr(\n        O[t] <= W[t] * H_o_max,\n        name=f\"OvertimeLimit_{t}\"\n    )\n\n# Inventory and backorder balance\nfor t in months:\n    if t == 1:\n        prev_inventory = initial_inventory\n        prev_backorder = 0\n    else:\n        prev_inventory = I[t-1]\n        prev_backorder = B[t-1]\n\n    # I_{t-1} + P_t + X_t + B_t = D_t + I_t + B_{t-1}\n    model.addConstr(\n        prev_inventory + P[t] + X[t] + B[t] ==\n        demand[t] + I[t] + prev_backorder,\n        name=f\"InvBackorderBalance_{t}\"\n    )\n\n# Ending inventory requirement\nmodel.addConstr(I[6] >= required_final_inventory, name=\"FinalInventoryRequirement\")\n\n# -----------------------------\n# Objective: Maximize total net profit\n# -----------------------------\n\n# Revenue is fixed given demand\ntotal_revenue = sum(price * demand[t] for t in months)\n\n# Costs\ntotal_raw_cost = gp.quicksum(raw_cost * P[t] for t in months)\ntotal_regular_wage = gp.quicksum(wage_regular * W[t] * H_r for t in months)\ntotal_overtime_wage = gp.quicksum(wage_overtime * O[t] for t in months)\ntotal_outsourcing_cost = gp.quicksum(outsourcing_cost * X[t] for t in months)\ntotal_inventory_cost = gp.quicksum(inventory_cost * I[t] for t in months)\ntotal_stockout_cost = gp.quicksum(stockout_cost * B[t] for t in months)\ntotal_hire_cost = gp.quicksum(hire_cost * H[t] for t in months)\ntotal_fire_cost = gp.quicksum(fire_cost * F[t] for t in months)\n\ntotal_cost = (total_raw_cost + total_regular_wage + total_overtime_wage +\n              total_outsourcing_cost + total_inventory_cost + total_stockout_cost +\n              total_hire_cost + total_fire_cost)\n\nmodel.setObjective(total_revenue - total_cost, GRB.MAXIMIZE)\n\n# -----------------------------\n# Optimize\n# -----------------------------\nmodel.optimize()\n\n# -----------------------------\n# Results\n# -----------------------------\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\nelse:\n    print(\"No optimal solution found\")", "execution_success": true, "mathematical_accuracy": false, "execution_result": "Execution Successful", "execution_best_solution": 24317500.0, "execution_state": "Execution Successful"}
{"task_id": "B063", "description": "A company needs to decide whether to hire some of the five candidates to join their R&D team. The salary requirements for candidates F, G, H, I, and J are $12,000, $15,000, $18,000, $5,000, and $10,000 respectively. The company wants to minimize the total amount paid to candidates without exceeding the budget.\n\nThe company's budget is $40,000 and they wish to hire a maximum of 4 new employees.\n\nThe skill levels of the candidates are as follows:\nCandidate F: Level 2\nCandidate G: Level 3\nCandidate H: Level 4\nCandidate I: Level 1\nCandidate J: Level 2\n\nThe company needs to ensure that the total skill level of the hired employees is at least 8.\n\nThe project management experience years of each candidate are as follows:\nCandidate F: 1 year\nCandidate G: 2 years\nCandidate H: 2 years\nCandidate I: 5 years\nCandidate J: 4 years\n\nThey hope the total project management experience of the team is at least 8 years.\n\nDue to the similar technical background of candidates G and J, the company can choose at most one of them.", "ground_truth": 38000.0, "formulation": null, "correct_program": "def optimize_candidate_selection(salaries={\n    'F': 12000,\n    'G': 15000,\n    'H': 18000,\n    'I': 5000,\n    'J': 10000\n},\n                                 skills={\n                                     'F': 2,\n                                     'G': 3,\n                                     'H': 4,\n                                     'I': 1,\n                                     'J': 2\n                                 },\n                                 experiences={\n                                     'F': 1,\n                                     'G': 2,\n                                     'H': 2,\n                                     'I': 5,\n                                     'J': 4\n                                 },\n                                 budget=40000,\n                                 max_candidates=4,\n                                 min_skill=8,\n                                 min_experience=8):\n    import gurobipy as gp\n    from gurobipy import GRB\n\n    # Initialize model\n    model = gp.Model(\"Candidate_Selection\")\n\n    # Decision variables\n    candidates = ['F', 'G', 'H', 'I', 'J']\n    y = model.addVars(candidates, vtype=GRB.BINARY, name='hire')\n\n    # Objective: Minimize total salary\n    model.setObjective(gp.quicksum(salaries[c] * y[c] for c in candidates),\n                       GRB.MINIMIZE)\n\n    # Budget constraint\n    model.addConstr(gp.quicksum(salaries[c] * y[c] for c in candidates)\n                    <= budget,\n                    name='Budget')\n\n    # Team size constraint\n    model.addConstr(gp.quicksum(y[c] for c in candidates) <= max_candidates,\n                    name='MaxTeamSize')\n\n    # Skill level constraint\n    model.addConstr(gp.quicksum(skills[c] * y[c] for c in candidates)\n                    >= min_skill,\n                    name='SkillLevel')\n\n    # Experience constraint\n    model.addConstr(gp.quicksum(experiences[c] * y[c] for c in candidates)\n                    >= min_experience,\n                    name='Experience')\n\n    # Mutual exclusivity of G and J\n    model.addConstr(y['G'] + y['J'] <= 1, name='G_J_Exclusion')\n\n    # Optimize the model\n    model.optimize()\n\n    # Check if a feasible solution was found\n    if model.status == GRB.OPTIMAL:\n        total_salary = model.objVal\n        return total_salary\n    else:\n        return None\n    \nif __name__ == \"__main__\":\n    result = optimize_candidate_selection()\n    if result is not None:\n        print(f\"Optimal total salary: {result}\")\n    else:\n        print(\"No feasible solution found.\")", "output_status": [], "success_count": 0, "success_confidence": 0, "fail_to_diagnose": 0, "fail_to_verify": 0, "retrieved_insights": [], "tag": [{"problem_domain": "Selection", "modeling_type": "MILP", "industry_sector": "Human Resources", "reason": "The problem involves selecting a subset of candidates based on various criteria and constraints, which is a classic selection problem. The use of binary decision variables and linear constraints with a linear objective function indicates a Mixed-Integer Linear Programming (MILP) model. The application is directly related to hiring decisions within a company, falling under Human Resources."}], "cluster": null, "prompt": "Below is an operations research question. First formulate the problem as an optimization problem. Then according to the formulated problem, write python code that uses 'gurobipy' to solve the optimization problem. You should write a complete python code that can be executed to solve the optimization problem.\n\nIMPORTANT: Your code should follow these requirements:\n1. Create a Gurobi model variable named 'model' (not 'm' or other names)\n2. Include all necessary imports and data setup\n3. Write the complete optimization code that can run independently\n4. Do NOT wrap everything in a function - write the code directly\n5. Make sure the model is created and optimized in the main execution flow\n6. The code should print the optimal objective value when solved successfully\n\nExample format:\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Data setup\ndata = {...}\n\n# Create model\nmodel = gp.Model(\"ProblemName\")\n\n# Decision variables\nx = model.addVars(...)\n\n# Objective\nmodel.setObjective(...)\n\n# Constraints\nmodel.addConstr(...)\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\nelse:\n    print(\"No optimal solution found\")\n```\n\n# Question:\nA company needs to decide whether to hire some of the five candidates to join their R&D team. The salary requirements for candidates F, G, H, I, and J are $12,000, $15,000, $18,000, $5,000, and $10,000 respectively. The company wants to minimize the total amount paid to candidates without exceeding the budget.\n\nThe company's budget is $40,000 and they wish to hire a maximum of 4 new employees.\n\nThe skill levels of the candidates are as follows:\nCandidate F: Level 2\nCandidate G: Level 3\nCandidate H: Level 4\nCandidate I: Level 1\nCandidate J: Level 2\n\nThe company needs to ensure that the total skill level of the hired employees is at least 8.\n\nThe project management experience years of each candidate are as follows:\nCandidate F: 1 year\nCandidate G: 2 years\nCandidate H: 2 years\nCandidate I: 5 years\nCandidate J: 4 years\n\nThey hope the total project management experience of the team is at least 8 years.\n\nDue to the similar technical background of candidates G and J, the company can choose at most one of them.\n\n# Response:", "generated_output": "Below is the mathematical formulation followed by a complete Gurobi Python code.\n\n---\n\n## Optimization Model Formulation\n\n**Decision variables**\n\nFor each candidate \\( k \\in \\{F, G, H, I, J\\} \\):\n\n\\[\nx_k = \n\\begin{cases}\n1 & \\text{if candidate } k \\text{ is hired} \\\\\n0 & \\text{otherwise}\n\\end{cases}\n\\]\n\n**Parameters**\n\n- Salaries (in \\$1,000):  \n  \\( c_F = 12,\\ c_G = 15,\\ c_H = 18,\\ c_I = 5,\\ c_J = 10 \\)\n- Skill levels:  \n  \\( s_F = 2,\\ s_G = 3,\\ s_H = 4,\\ s_I = 1,\\ s_J = 2 \\)\n- Experience (years):  \n  \\( e_F = 1,\\ e_G = 2,\\ e_H = 2,\\ e_I = 5,\\ e_J = 4 \\)\n- Budget: \\( B = 40 \\)\n- Max hires: \\( H_{\\max} = 4 \\)\n- Min total skill: \\( S_{\\min} = 8 \\)\n- Min total experience: \\( E_{\\min} = 8 \\)\n\n**Objective**\n\nMinimize total salary:\n\n\\[\n\\min \\; 12x_F + 15x_G + 18x_H + 5x_I + 10x_J\n\\]\n\n**Constraints**\n\n1. Budget constraint:\n\\[\n12x_F + 15x_G + 18x_H + 5x_I + 10x_J \\le 40\n\\]\n\n2. Maximum number of hires:\n\\[\nx_F + x_G + x_H + x_I + x_J \\le 4\n\\]\n\n3. Minimum total skill:\n\\[\n2x_F + 3x_G + 4x_H + 1x_I + 2x_J \\ge 8\n\\]\n\n4. Minimum total experience:\n\\[\n1x_F + 2x_G + 2x_H + 5x_I + 4x_J \\ge 8\n\\]\n\n5. At most one of G and J:\n\\[\nx_G + x_J \\le 1\n\\]\n\n6. Binary variables:\n\\[\nx_k \\in \\{0,1\\} \\quad \\forall k \\in \\{F,G,H,I,J\\}\n\\]\n\n---\n\n## Gurobi Python Code\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# -------------------------\n# Data setup\n# -------------------------\n\ncandidates = ['F', 'G', 'H', 'I', 'J']\n\nsalary = {\n    'F': 12000,\n    'G': 15000,\n    'H': 18000,\n    'I': 5000,\n    'J': 10000\n}\n\nskill = {\n    'F': 2,\n    'G': 3,\n    'H': 4,\n    'I': 1,\n    'J': 2\n}\n\nexperience = {\n    'F': 1,\n    'G': 2,\n    'H': 2,\n    'I': 5,\n    'J': 4\n}\n\nbudget = 40000\nmax_hires = 4\nmin_skill = 8\nmin_experience = 8\n\n# -------------------------\n# Create model\n# -------------------------\n\nmodel = gp.Model(\"HiringProblem\")\n\n# -------------------------\n# Decision variables\n# -------------------------\n\n# x[i] = 1 if candidate i is hired, 0 otherwise\nx = model.addVars(candidates, vtype=GRB.BINARY, name=\"x\")\n\n# -------------------------\n# Objective: minimize total salary\n# -------------------------\n\nmodel.setObjective(\n    gp.quicksum(salary[i] * x[i] for i in candidates),\n    GRB.MINIMIZE\n)\n\n# -------------------------\n# Constraints\n# -------------------------\n\n# Budget constraint\nmodel.addConstr(\n    gp.quicksum(salary[i] * x[i] for i in candidates) <= budget,\n    name=\"Budget\"\n)\n\n# Maximum number of hires\nmodel.addConstr(\n    gp.quicksum(x[i] for i in candidates) <= max_hires,\n    name=\"MaxHires\"\n)\n\n# Minimum total skill\nmodel.addConstr(\n    gp.quicksum(skill[i] * x[i] for i in candidates) >= min_skill,\n    name=\"MinSkill\"\n)\n\n# Minimum total experience\nmodel.addConstr(\n    gp.quicksum(experience[i] * x[i] for i in candidates) >= min_experience,\n    name=\"MinExperience\"\n)\n\n# At most one of G and J\nmodel.addConstr(\n    x['G'] + x['J'] <= 1,\n    name=\"AtMostOne_G_J\"\n)\n\n# -------------------------\n# Optimize\n# -------------------------\n\nmodel.optimize()\n\n# -------------------------\n# Results\n# -------------------------\n\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\n    print(\"Hiring decisions:\")\n    for i in candidates:\n        if x[i].X > 0.5:\n            print(f\"  Hire candidate {i}\")\nelse:\n    print(\"No optimal solution found\")\n```", "extracted_code": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# -------------------------\n# Data setup\n# -------------------------\n\ncandidates = ['F', 'G', 'H', 'I', 'J']\n\nsalary = {\n    'F': 12000,\n    'G': 15000,\n    'H': 18000,\n    'I': 5000,\n    'J': 10000\n}\n\nskill = {\n    'F': 2,\n    'G': 3,\n    'H': 4,\n    'I': 1,\n    'J': 2\n}\n\nexperience = {\n    'F': 1,\n    'G': 2,\n    'H': 2,\n    'I': 5,\n    'J': 4\n}\n\nbudget = 40000\nmax_hires = 4\nmin_skill = 8\nmin_experience = 8\n\n# -------------------------\n# Create model\n# -------------------------\n\nmodel = gp.Model(\"HiringProblem\")\n\n# -------------------------\n# Decision variables\n# -------------------------\n\n# x[i] = 1 if candidate i is hired, 0 otherwise\nx = model.addVars(candidates, vtype=GRB.BINARY, name=\"x\")\n\n# -------------------------\n# Objective: minimize total salary\n# -------------------------\n\nmodel.setObjective(\n    gp.quicksum(salary[i] * x[i] for i in candidates),\n    GRB.MINIMIZE\n)\n\n# -------------------------\n# Constraints\n# -------------------------\n\n# Budget constraint\nmodel.addConstr(\n    gp.quicksum(salary[i] * x[i] for i in candidates) <= budget,\n    name=\"Budget\"\n)\n\n# Maximum number of hires\nmodel.addConstr(\n    gp.quicksum(x[i] for i in candidates) <= max_hires,\n    name=\"MaxHires\"\n)\n\n# Minimum total skill\nmodel.addConstr(\n    gp.quicksum(skill[i] * x[i] for i in candidates) >= min_skill,\n    name=\"MinSkill\"\n)\n\n# Minimum total experience\nmodel.addConstr(\n    gp.quicksum(experience[i] * x[i] for i in candidates) >= min_experience,\n    name=\"MinExperience\"\n)\n\n# At most one of G and J\nmodel.addConstr(\n    x['G'] + x['J'] <= 1,\n    name=\"AtMostOne_G_J\"\n)\n\n# -------------------------\n# Optimize\n# -------------------------\n\nmodel.optimize()\n\n# -------------------------\n# Results\n# -------------------------\n\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\n    print(\"Hiring decisions:\")\n    for i in candidates:\n        if x[i].X > 0.5:\n            print(f\"  Hire candidate {i}\")\nelse:\n    print(\"No optimal solution found\")", "execution_success": true, "mathematical_accuracy": true, "execution_result": "Execution Successful", "execution_best_solution": 38000.0, "execution_state": "Execution Successful"}
{"task_id": "B050", "description": "The number of nurses required in each time period over 24 hours at a certain hospital is as follows: 2:00-6:00 - 10 people, 6:00-10:00 - 15 people, 10:00-14:00 - 25 people, 14:00-18:00 - 20 people, 18:00-22:00 - 18 people, 22:00-2:00 - 12 people. Nurses start shifts in 6 batches at 2:00, 6:00, 10:00, 14:00, 18:00, and 22:00 and work continuously for 8 hours. Please determine: If the hospital can hire contract nurses with the same working hours as regular nurses, and if the pay for regular nurses is 10 yuan/hour and for contract nurses is 15 yuan/hour, should the hospital hire contract nurses and if so, how many?", "ground_truth": 4240.0, "formulation": null, "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_nurse_staffing_with_contract():\n    \"\"\"\n    Solves the nurse staffing problem with regular and contract nurses\n    to minimize total daily wage costs.\n    \"\"\"\n    try:\n        # Create a new model\n        model = gp.Model(\"NurseStaffingContract\")\n\n        # --- Data ---\n        # Demands for each 4-hour period (0 to 5)\n        # P0: 2:00-6:00, P1: 6:00-10:00, ..., P5: 22:00-2:00\n        demands = {\n            0: 10,  # 2:00 - 6:00\n            1: 15,  # 6:00 - 10:00\n            2: 25,  # 10:00 - 14:00\n            3: 20,  # 14:00 - 18:00\n            4: 18,  # 18:00 - 22:00\n            5: 12  # 22:00 - 2:00 (next day)\n        }\n        num_periods = len(demands)  # Should be 6\n\n        # Shift start times (represented by an index for variables)\n        # t=0 starts at 2:00, t=1 at 6:00, ..., t=5 at 22:00\n        shift_start_times_desc = [\n            \"2:00\", \"6:00\", \"10:00\", \"14:00\", \"18:00\", \"22:00\"\n        ]\n\n        # Costs\n        cost_regular_nurse_shift = 10 * 8  # 10 yuan/hour * 8 hours\n        cost_contract_nurse_shift = 15 * 8  # 15 yuan/hour * 8 hours\n\n        # --- Decision Variables ---\n        # xR[t]: number of regular nurses starting shift at time t\n        xR = model.addVars(num_periods, vtype=GRB.INTEGER, name=\"xR\", lb=0)\n        # xC[t]: number of contract nurses starting shift at time t\n        xC = model.addVars(num_periods, vtype=GRB.INTEGER, name=\"xC\", lb=0)\n\n        # --- Objective Function ---\n        # Minimize the total daily wage cost\n        total_cost = gp.quicksum(cost_regular_nurse_shift * xR[t] +\n                                 cost_contract_nurse_shift * xC[t]\n                                 for t in range(num_periods))\n        model.setObjective(total_cost, GRB.MINIMIZE)\n\n        # --- Constraints ---\n        # Demand coverage for each period.\n        # Each nurse works for 8 hours, covering two 4-hour periods.\n\n        # Period 0 (2:00-6:00): Covered by staff starting at 22:00 (t=5) and 2:00 (t=0)\n        model.addConstr((xR[5] + xC[5]) + (xR[0] + xC[0]) >= demands[0],\n                        \"Demand_P0\")\n\n        # Period 1 (6:00-10:00): Covered by staff starting at 2:00 (t=0) and 6:00 (t=1)\n        model.addConstr((xR[0] + xC[0]) + (xR[1] + xC[1]) >= demands[1],\n                        \"Demand_P1\")\n\n        # Period 2 (10:00-14:00): Covered by staff starting at 6:00 (t=1) and 10:00 (t=2)\n        model.addConstr((xR[1] + xC[1]) + (xR[2] + xC[2]) >= demands[2],\n                        \"Demand_P2\")\n\n        # Period 3 (14:00-18:00): Covered by staff starting at 10:00 (t=2) and 14:00 (t=3)\n        model.addConstr((xR[2] + xC[2]) + (xR[3] + xC[3]) >= demands[3],\n                        \"Demand_P3\")\n\n        # Period 4 (18:00-22:00): Covered by staff starting at 14:00 (t=3) and 18:00 (t=4)\n        model.addConstr((xR[3] + xC[3]) + (xR[4] + xC[4]) >= demands[4],\n                        \"Demand_P4\")\n\n        # Period 5 (22:00-2:00): Covered by staff starting at 18:00 (t=4) and 22:00 (t=5)\n        model.addConstr((xR[4] + xC[4]) + (xR[5] + xC[5]) >= demands[5],\n                        \"Demand_P5\")\n\n        # Suppress Gurobi output to console\n        # model.setParam('OutputFlag', 0)\n\n        # Optimize the model\n        model.optimize()\n\n        # --- Results ---\n        if model.status == GRB.OPTIMAL:\n            print(\"Optimal staffing plan found.\")\n            print(f\"Minimum Total Daily Wage Cost: {model.objVal:.2f} Yuan\")\n\n            total_regular_nurses = sum(xR[t].X for t in range(num_periods))\n            total_contract_nurses = sum(xC[t].X for t in range(num_periods))\n\n            print(\n                f\"\\nTotal Regular Nurses to Hire: {total_regular_nurses:.0f}\")\n            print(\n                f\"Total Contract Nurses to Hire: {total_contract_nurses:.0f}\")\n\n            if total_contract_nurses > 0:\n                print(\"\\nDecision: The hospital SHOULD hire contract nurses.\")\n            else:\n                print(\n                    \"\\nDecision: The hospital does NOT need to hire contract nurses based on cost minimization.\"\n                )\n\n            print(\"\\nNumber of Nurses Starting at Each Shift:\")\n            print(f\"{'Start Time':<12} | {'Regular':<10} | {'Contract':<10}\")\n            print(\"-\" * 40)\n            for t in range(num_periods):\n                print(\n                    f\"{shift_start_times_desc[t]:<12} | {xR[t].X:<10.0f} | {xC[t].X:<10.0f}\"\n                )\n\n            print(\"\\nVerification of Coverage per Period:\")\n            coverage = [0] * num_periods\n            coverage[0] = (xR[5].X + xC[5].X) + (xR[0].X + xC[0].X)\n            coverage[1] = (xR[0].X + xC[0].X) + (xR[1].X + xC[1].X)\n            coverage[2] = (xR[1].X + xC[1].X) + (xR[2].X + xC[2].X)\n            coverage[3] = (xR[2].X + xC[2].X) + (xR[3].X + xC[3].X)\n            coverage[4] = (xR[3].X + xC[3].X) + (xR[4].X + xC[4].X)\n            coverage[5] = (xR[4].X + xC[4].X) + (xR[5].X + xC[5].X)\n\n            period_desc = [\n                \"2:00-6:00\", \"6:00-10:00\", \"10:00-14:00\", \"14:00-18:00\",\n                \"18:00-22:00\", \"22:00-2:00\"\n            ]\n            for p in range(num_periods):\n                print(\n                    f\"  Period {period_desc[p]} (Demand: {demands[p]}): Covered by {coverage[p]:.0f} nurses\"\n                )\n\n        else:\n            print(\"No optimal solution found. Status code:\", model.status)\n\n    except gp.GurobiError as e:\n        print(f\"Error code {e.errno}: {e}\")\n    except AttributeError:\n        print(\n            \"Encountered an attribute error, Gurobi might not be installed or licensed correctly.\"\n        )\n\n\nif __name__ == '__main__':\n    solve_nurse_staffing_with_contract()", "output_status": [], "success_count": 0, "success_confidence": 0, "fail_to_diagnose": 0, "fail_to_verify": 0, "retrieved_insights": [], "tag": [{"problem_domain": "Scheduling", "modeling_type": "MILP", "industry_sector": "Health", "reason": "The problem involves determining the optimal number of nurses to start shifts at different times to meet demand, which is a classic scheduling problem. The model uses integer variables for the number of nurses and linear constraints, making it a Mixed-Integer Linear Program. The application is clearly within a hospital setting, hence 'Health'."}], "cluster": null, "prompt": "Below is an operations research question. First formulate the problem as an optimization problem. Then according to the formulated problem, write python code that uses 'gurobipy' to solve the optimization problem. You should write a complete python code that can be executed to solve the optimization problem.\n\nIMPORTANT: Your code should follow these requirements:\n1. Create a Gurobi model variable named 'model' (not 'm' or other names)\n2. Include all necessary imports and data setup\n3. Write the complete optimization code that can run independently\n4. Do NOT wrap everything in a function - write the code directly\n5. Make sure the model is created and optimized in the main execution flow\n6. The code should print the optimal objective value when solved successfully\n\nExample format:\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Data setup\ndata = {...}\n\n# Create model\nmodel = gp.Model(\"ProblemName\")\n\n# Decision variables\nx = model.addVars(...)\n\n# Objective\nmodel.setObjective(...)\n\n# Constraints\nmodel.addConstr(...)\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\nelse:\n    print(\"No optimal solution found\")\n```\n\n# Question:\nThe number of nurses required in each time period over 24 hours at a certain hospital is as follows: 2:00-6:00 - 10 people, 6:00-10:00 - 15 people, 10:00-14:00 - 25 people, 14:00-18:00 - 20 people, 18:00-22:00 - 18 people, 22:00-2:00 - 12 people. Nurses start shifts in 6 batches at 2:00, 6:00, 10:00, 14:00, 18:00, and 22:00 and work continuously for 8 hours. Please determine: If the hospital can hire contract nurses with the same working hours as regular nurses, and if the pay for regular nurses is 10 yuan/hour and for contract nurses is 15 yuan/hour, should the hospital hire contract nurses and if so, how many?\n\n# Response:", "generated_output": "Below is a complete formulation and corresponding Gurobi code.\n\n---\n\n## 1. Optimization Model Formulation\n\n### Sets\n- Time periods (4-hour blocks):  \n  \\( T = \\{1,2,3,4,5,6\\} \\)  \n  Corresponding to:\n  1. 2:00–6:00  \n  2. 6:00–10:00  \n  3. 10:00–14:00  \n  4. 14:00–18:00  \n  5. 18:00–22:00  \n  6. 22:00–2:00  \n\n- Shift start times (each shift is 8 hours, i.e., covers 2 consecutive periods):  \n  \\( S = \\{1,2,3,4,5,6\\} \\)  \n  Where shift \\(s\\) starts at:\n  1. 2:00 (covers periods 1 and 2)  \n  2. 6:00 (covers periods 2 and 3)  \n  3. 10:00 (covers periods 3 and 4)  \n  4. 14:00 (covers periods 4 and 5)  \n  5. 18:00 (covers periods 5 and 6)  \n  6. 22:00 (covers periods 6 and 1, wrapping around)\n\n### Parameters\nRequired nurses per period:\n- \\( d_1 = 10 \\) (2:00–6:00)  \n- \\( d_2 = 15 \\) (6:00–10:00)  \n- \\( d_3 = 25 \\) (10:00–14:00)  \n- \\( d_4 = 20 \\) (14:00–18:00)  \n- \\( d_5 = 18 \\) (18:00–22:00)  \n- \\( d_6 = 12 \\) (22:00–2:00)\n\nCosts per 8-hour shift:\n- Regular nurse: 10 yuan/hour → \\( 10 \\times 8 = 80 \\) yuan/shift  \n- Contract nurse: 15 yuan/hour → \\( 15 \\times 8 = 120 \\) yuan/shift  \n\nLet:\n- \\( c^R = 80 \\) (regular shift cost)  \n- \\( c^C = 120 \\) (contract shift cost)\n\n### Decision Variables\nFor each shift start \\( s \\in S \\):\n- \\( R_s \\ge 0 \\): number of regular nurses starting at shift \\( s \\)  \n- \\( C_s \\ge 0 \\): number of contract nurses starting at shift \\( s \\)\n\n(We treat them as continuous nonnegative variables; in practice they should be integers, so we will model them as integer variables in the code.)\n\n### Coverage Structure\nEach shift covers two periods:\n- Shift 1 (2:00): covers periods 1 and 2  \n- Shift 2 (6:00): covers periods 2 and 3  \n- Shift 3 (10:00): covers periods 3 and 4  \n- Shift 4 (14:00): covers periods 4 and 5  \n- Shift 5 (18:00): covers periods 5 and 6  \n- Shift 6 (22:00): covers periods 6 and 1  \n\nThus, for each period \\( t \\), the covering shifts are:\n- Period 1: shifts 1 and 6  \n- Period 2: shifts 1 and 2  \n- Period 3: shifts 2 and 3  \n- Period 4: shifts 3 and 4  \n- Period 5: shifts 4 and 5  \n- Period 6: shifts 5 and 6  \n\n### Objective\nMinimize total daily wage cost:\n\\[\n\\min \\sum_{s \\in S} \\left( c^R R_s + c^C C_s \\right)\n\\]\n\n### Constraints\nCoverage constraints for each period \\( t \\in T \\):\n\n1. Period 1 (2:00–6:00):\n\\[\nR_1 + C_1 + R_6 + C_6 \\ge d_1 = 10\n\\]\n\n2. Period 2 (6:00–10:00):\n\\[\nR_1 + C_1 + R_2 + C_2 \\ge d_2 = 15\n\\]\n\n3. Period 3 (10:00–14:00):\n\\[\nR_2 + C_2 + R_3 + C_3 \\ge d_3 = 25\n\\]\n\n4. Period 4 (14:00–18:00):\n\\[\nR_3 + C_3 + R_4 + C_4 \\ge d_4 = 20\n\\]\n\n5. Period 5 (18:00–22:00):\n\\[\nR_4 + C_4 + R_5 + C_5 \\ge d_5 = 18\n\\]\n\n6. Period 6 (22:00–2:00):\n\\[\nR_5 + C_5 + R_6 + C_6 \\ge d_6 = 12\n\\]\n\nNonnegativity and integrality:\n\\[\nR_s, C_s \\in \\mathbb{Z}_{\\ge 0}, \\quad \\forall s \\in S\n\\]\n\nAfter solving, if any \\( C_s > 0 \\), then the hospital should hire contract nurses; the total number of contract nurses is \\(\\sum_{s} C_s\\).\n\n---\n\n## 2. Complete Gurobi Python Code\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# =========================\n# Data setup\n# =========================\n\n# Periods 1..6\nperiods = [1, 2, 3, 4, 5, 6]\n\n# Required nurses per 4-hour period\ndemand = {\n    1: 10,  # 2:00-6:00\n    2: 15,  # 6:00-10:00\n    3: 25,  # 10:00-14:00\n    4: 20,  # 14:00-18:00\n    5: 18,  # 18:00-22:00\n    6: 12   # 22:00-2:00\n}\n\n# Shifts 1..6 (each 8 hours, covering 2 consecutive periods)\nshifts = [1, 2, 3, 4, 5, 6]\n\n# For each shift, which periods it covers\n# Shift 1: periods 1 and 2\n# Shift 2: periods 2 and 3\n# Shift 3: periods 3 and 4\n# Shift 4: periods 4 and 5\n# Shift 5: periods 5 and 6\n# Shift 6: periods 6 and 1 (wrap-around)\nshift_covers = {\n    1: [1, 2],\n    2: [2, 3],\n    3: [3, 4],\n    4: [4, 5],\n    5: [5, 6],\n    6: [6, 1]\n}\n\n# Cost per 8-hour shift\nregular_hourly = 10\ncontract_hourly = 15\nshift_length_hours = 8\n\ncost_regular = regular_hourly * shift_length_hours   # 80\ncost_contract = contract_hourly * shift_length_hours # 120\n\n# =========================\n# Create model\n# =========================\n\nmodel = gp.Model(\"Nurse_Scheduling_Regular_Contract\")\n\n# =========================\n# Decision variables\n# =========================\n\n# Number of regular nurses starting at each shift (integer)\nR = model.addVars(shifts, vtype=GRB.INTEGER, name=\"R\", lb=0)\n\n# Number of contract nurses starting at each shift (integer)\nC = model.addVars(shifts, vtype=GRB.INTEGER, name=\"C\", lb=0)\n\n# =========================\n# Objective: minimize total cost\n# =========================\n\nmodel.setObjective(\n    gp.quicksum(cost_regular * R[s] + cost_contract * C[s] for s in shifts),\n    GRB.MINIMIZE\n)\n\n# =========================\n# Constraints: coverage for each period\n# =========================\n\nfor t in periods:\n    # All shifts that cover period t\n    covering_shifts = [s for s in shifts if t in shift_covers[s]]\n    model.addConstr(\n        gp.quicksum(R[s] + C[s] for s in covering_shifts) >= demand[t],\n        name=f\"Coverage_p{t}\"\n    )\n\n# =========================\n# Optimize\n# =========================\n\nmodel.optimize()\n\n# =========================\n# Results\n# =========================\n\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\n\n    total_regular = sum(R[s].X for s in shifts)\n    total_contract = sum(C[s].X for s in shifts)\n\n    print(\"Shift-wise regular nurses:\")\n    for s in shifts:\n        print(f\"  Shift {s}: {R[s].X:.0f}\")\n\n    print(\"Shift-wise contract nurses:\")\n    for s in shifts:\n        print(f\"  Shift {s}: {C[s].X:.0f}\")\n\n    print(f\"Total regular nurses (sum over shifts): {total_regular:.0f}\")\n    print(f\"Total contract nurses (sum over shifts): {total_contract:.0f}\")\n\n    if total_contract > 0.5:  # small tolerance\n        print(\"Conclusion: The hospital should hire contract nurses.\")\n    else:\n        print(\"Conclusion: The hospital does not need to hire contract nurses.\")\nelse:\n    print(\"No optimal solution found\")\n```", "extracted_code": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# =========================\n# Data setup\n# =========================\n\n# Periods 1..6\nperiods = [1, 2, 3, 4, 5, 6]\n\n# Required nurses per 4-hour period\ndemand = {\n    1: 10,  # 2:00-6:00\n    2: 15,  # 6:00-10:00\n    3: 25,  # 10:00-14:00\n    4: 20,  # 14:00-18:00\n    5: 18,  # 18:00-22:00\n    6: 12   # 22:00-2:00\n}\n\n# Shifts 1..6 (each 8 hours, covering 2 consecutive periods)\nshifts = [1, 2, 3, 4, 5, 6]\n\n# For each shift, which periods it covers\n# Shift 1: periods 1 and 2\n# Shift 2: periods 2 and 3\n# Shift 3: periods 3 and 4\n# Shift 4: periods 4 and 5\n# Shift 5: periods 5 and 6\n# Shift 6: periods 6 and 1 (wrap-around)\nshift_covers = {\n    1: [1, 2],\n    2: [2, 3],\n    3: [3, 4],\n    4: [4, 5],\n    5: [5, 6],\n    6: [6, 1]\n}\n\n# Cost per 8-hour shift\nregular_hourly = 10\ncontract_hourly = 15\nshift_length_hours = 8\n\ncost_regular = regular_hourly * shift_length_hours   # 80\ncost_contract = contract_hourly * shift_length_hours # 120\n\n# =========================\n# Create model\n# =========================\n\nmodel = gp.Model(\"Nurse_Scheduling_Regular_Contract\")\n\n# =========================\n# Decision variables\n# =========================\n\n# Number of regular nurses starting at each shift (integer)\nR = model.addVars(shifts, vtype=GRB.INTEGER, name=\"R\", lb=0)\n\n# Number of contract nurses starting at each shift (integer)\nC = model.addVars(shifts, vtype=GRB.INTEGER, name=\"C\", lb=0)\n\n# =========================\n# Objective: minimize total cost\n# =========================\n\nmodel.setObjective(\n    gp.quicksum(cost_regular * R[s] + cost_contract * C[s] for s in shifts),\n    GRB.MINIMIZE\n)\n\n# =========================\n# Constraints: coverage for each period\n# =========================\n\nfor t in periods:\n    # All shifts that cover period t\n    covering_shifts = [s for s in shifts if t in shift_covers[s]]\n    model.addConstr(\n        gp.quicksum(R[s] + C[s] for s in covering_shifts) >= demand[t],\n        name=f\"Coverage_p{t}\"\n    )\n\n# =========================\n# Optimize\n# =========================\n\nmodel.optimize()\n\n# =========================\n# Results\n# =========================\n\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\n\n    total_regular = sum(R[s].X for s in shifts)\n    total_contract = sum(C[s].X for s in shifts)\n\n    print(\"Shift-wise regular nurses:\")\n    for s in shifts:\n        print(f\"  Shift {s}: {R[s].X:.0f}\")\n\n    print(\"Shift-wise contract nurses:\")\n    for s in shifts:\n        print(f\"  Shift {s}: {C[s].X:.0f}\")\n\n    print(f\"Total regular nurses (sum over shifts): {total_regular:.0f}\")\n    print(f\"Total contract nurses (sum over shifts): {total_contract:.0f}\")\n\n    if total_contract > 0.5:  # small tolerance\n        print(\"Conclusion: The hospital should hire contract nurses.\")\n    else:\n        print(\"Conclusion: The hospital does not need to hire contract nurses.\")\nelse:\n    print(\"No optimal solution found\")", "execution_success": true, "mathematical_accuracy": true, "execution_result": "Execution Successful", "execution_best_solution": 4240.0, "execution_state": "Execution Successful"}
{"task_id": "B036", "description": "A factory produces two types of microcomputers, A and B. Each type of microcomputer requires the same two production processes. The processing time, profit from sales, and the maximum weekly processing capacity for each type are shown in Table 3.1.\n\nTable 3.1\n\n| Process | Model |  | Maximum Weekly Processing Capacity |\n| :---: | :---: | :---: | :---: |\n|  | $\\\\mathrm{A}$ | $\\\\mathrm{B}$ |  |\n| I (hours / unit) | 4 | 6 | 150 |\n| II (hours / unit) | 3 | 2 | 70 |\n| Profit ($ per unit) | 300 | 450 |  |\n\nThe expected values for the factory's operational goals are as follows:\n\n$p_{1}$: The total weekly profit must not be less than $10,000.\n\n$p_{2}$: Due to contractual requirements, at least 10 units of Model A and at least 15 units of Model B must be produced per week.\n\n$p_{3}$: The weekly production time for Process I should be exactly 150 hours, and the production time for Process II should be fully utilized, with potential overtime if necessary.\n\nTry to establish the mathematical programming model for this problem.", "ground_truth": 11250.0, "formulation": null, "correct_program": "def optimize_microcomputers():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"Microcomputers_Production\")\n\n    # Decision variables\n    x_A = m.addVar(name=\"x_A\", lb=10, ub=150)  # at least 10, at most 150\n    x_B = m.addVar(name=\"x_B\", lb=15, ub=70)  # at least 15, at most 70\n\n    # Set the objective: maximize profit\n    m.setObjective(300 * x_A + 450 * x_B, GRB.MAXIMIZE)\n\n    # Add constraints\n    # Process I: exactly 150 hours\n    m.addConstr(4 * x_A + 6 * x_B == 150, name=\"Process_I\")\n    # Process II: exactly 70 hours\n    m.addConstr(3 * x_A + 2 * x_B == 70, name=\"Process_II\")\n    # Profit constraint: at least $10,000\n    m.addConstr(300 * x_A + 450 * x_B >= 10000, name=\"Profit_minimum\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        return m.objVal\n    else:\n        return None\nif __name__ == \"__main__\":\n    result = optimize_microcomputers()\n    if result is not None:\n        print(f\"Optimal total profit: {result}\")\n    else:\n        print(\"No feasible solution found.\")", "output_status": [], "success_count": 0, "success_confidence": 0, "fail_to_diagnose": 0, "fail_to_verify": 0, "retrieved_insights": [], "tag": [{"problem_domain": "Production Planning", "modeling_type": "LP", "industry_sector": "Manufacturing", "reason": "The problem involves determining the optimal production quantities of two microcomputer models to maximize profit, subject to resource capacity and demand constraints, which is a classic production planning scenario. The model uses linear objective and constraints with continuous variables, fitting the Linear Programming (LP) paradigm. The context of producing microcomputers in a factory clearly places it within the manufacturing sector."}], "cluster": null, "prompt": "Below is an operations research question. First formulate the problem as an optimization problem. Then according to the formulated problem, write python code that uses 'gurobipy' to solve the optimization problem. You should write a complete python code that can be executed to solve the optimization problem.\n\nIMPORTANT: Your code should follow these requirements:\n1. Create a Gurobi model variable named 'model' (not 'm' or other names)\n2. Include all necessary imports and data setup\n3. Write the complete optimization code that can run independently\n4. Do NOT wrap everything in a function - write the code directly\n5. Make sure the model is created and optimized in the main execution flow\n6. The code should print the optimal objective value when solved successfully\n\nExample format:\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Data setup\ndata = {...}\n\n# Create model\nmodel = gp.Model(\"ProblemName\")\n\n# Decision variables\nx = model.addVars(...)\n\n# Objective\nmodel.setObjective(...)\n\n# Constraints\nmodel.addConstr(...)\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\nelse:\n    print(\"No optimal solution found\")\n```\n\n# Question:\nA factory produces two types of microcomputers, A and B. Each type of microcomputer requires the same two production processes. The processing time, profit from sales, and the maximum weekly processing capacity for each type are shown in Table 3.1.\n\nTable 3.1\n\n| Process | Model |  | Maximum Weekly Processing Capacity |\n| :---: | :---: | :---: | :---: |\n|  | $\\\\mathrm{A}$ | $\\\\mathrm{B}$ |  |\n| I (hours / unit) | 4 | 6 | 150 |\n| II (hours / unit) | 3 | 2 | 70 |\n| Profit ($ per unit) | 300 | 450 |  |\n\nThe expected values for the factory's operational goals are as follows:\n\n$p_{1}$: The total weekly profit must not be less than $10,000.\n\n$p_{2}$: Due to contractual requirements, at least 10 units of Model A and at least 15 units of Model B must be produced per week.\n\n$p_{3}$: The weekly production time for Process I should be exactly 150 hours, and the production time for Process II should be fully utilized, with potential overtime if necessary.\n\nTry to establish the mathematical programming model for this problem.\n\n# Response:", "generated_output": "Below is one reasonable interpretation as a **goal programming** model, then a corresponding Gurobi implementation.\n\n---\n\n## 1. Mathematical Formulation (Goal Programming)\n\n### Decision variables\n- \\(x_A \\ge 0\\): number of units of Model A produced per week  \n- \\(x_B \\ge 0\\): number of units of Model B produced per week  \n\nGoal deviation variables (all \\(\\ge 0\\)):\n\n- Profit goal:\n  - \\(d_1^- \\ge 0\\): underachievement of profit goal\n  - \\(d_1^+ \\ge 0\\): overachievement of profit goal  \n\n- Contractual production goals:\n  - \\(d_{2A}^- \\ge 0\\): underachievement of minimum production of A\n  - \\(d_{2A}^+ \\ge 0\\): overachievement of minimum production of A  \n  - \\(d_{2B}^- \\ge 0\\): underachievement of minimum production of B\n  - \\(d_{2B}^+ \\ge 0\\): overachievement of minimum production of B  \n\n- Process I time goal (exactly 150 hours):\n  - \\(d_{3I}^- \\ge 0\\): underutilization of Process I time\n  - \\(d_{3I}^+ \\ge 0\\): overutilization of Process I time  \n\n- Process II time goal (fully utilized, overtime allowed):\n  - \\(d_{3II}^- \\ge 0\\): underutilization of regular Process II capacity (70 hours)\n  - \\(d_{3II}^+ \\ge 0\\): overtime beyond 70 hours  \n\n### Goal constraints\n\n1. **Profit goal** (must not be less than 10,000):\n\\[\n300x_A + 450x_B + d_1^- - d_1^+ = 10000\n\\]\n\n2. **Contractual production goals**:\n\\[\nx_A + d_{2A}^- - d_{2A}^+ = 10\n\\]\n\\[\nx_B + d_{2B}^- - d_{2B}^+ = 15\n\\]\n\n3. **Process I time goal** (exactly 150 hours):\n\\[\n4x_A + 6x_B + d_{3I}^- - d_{3I}^+ = 150\n\\]\n\n4. **Process II time goal** (fully utilize 70 hours, overtime allowed):\n\\[\n3x_A + 2x_B + d_{3II}^- - d_{3II}^+ = 70\n\\]\n\nAll decision and deviation variables are nonnegative.\n\n### Objective (preemptive goal programming)\n\nAssume the goals are prioritized as:\n\n1. Satisfy contractual production (no underachievement of A and B minimums)\n2. Achieve at least the profit target (no underachievement)\n3. Meet the process time goals (minimize deviations)\n\nA common single-objective weighted formulation (without explicit priority levels coded) is:\n\n\\[\n\\min Z = \n1000(d_{2A}^- + d_{2B}^-) \n+ 100(d_1^-) \n+ (d_{3I}^- + d_{3I}^+ + d_{3II}^- + d_{3II}^+)\n\\]\n\nHere, large weights on \\(d_{2A}^-, d_{2B}^-\\) and \\(d_1^-\\) reflect higher priority of those goals. Overachievement deviations \\(d^+\\) for profit and production are not penalized.\n\n---\n\n## 2. Complete Gurobi Python Code\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# =========================\n# Data setup\n# =========================\n\n# Processing times (hours per unit)\ntI_A = 4\ntI_B = 6\ntII_A = 3\ntII_B = 2\n\n# Capacities / targets\ncap_I = 150      # Process I target hours\ncap_II = 70      # Process II regular capacity (target to fully utilize)\n\n# Profit per unit\np_A = 300\np_B = 450\n\n# Goals\nprofit_goal = 10000\nmin_A = 10\nmin_B = 15\n\n# =========================\n# Create model\n# =========================\nmodel = gp.Model(\"Microcomputer_Goal_Programming\")\n\n# =========================\n# Decision variables\n# =========================\n\n# Production quantities\nxA = model.addVar(lb=0, vtype=GRB.CONTINUOUS, name=\"xA\")\nxB = model.addVar(lb=0, vtype=GRB.CONTINUOUS, name=\"xB\")\n\n# Deviation variables (all nonnegative)\n# Profit goal\nd1_minus = model.addVar(lb=0, vtype=GRB.CONTINUOUS, name=\"d1_minus\")\nd1_plus  = model.addVar(lb=0, vtype=GRB.CONTINUOUS, name=\"d1_plus\")\n\n# Contractual production goals\nd2A_minus = model.addVar(lb=0, vtype=GRB.CONTINUOUS, name=\"d2A_minus\")\nd2A_plus  = model.addVar(lb=0, vtype=GRB.CONTINUOUS, name=\"d2A_plus\")\nd2B_minus = model.addVar(lb=0, vtype=GRB.CONTINUOUS, name=\"d2B_minus\")\nd2B_plus  = model.addVar(lb=0, vtype=GRB.CONTINUOUS, name=\"d2B_plus\")\n\n# Process I time goal (exactly 150)\nd3I_minus = model.addVar(lb=0, vtype=GRB.CONTINUOUS, name=\"d3I_minus\")\nd3I_plus  = model.addVar(lb=0, vtype=GRB.CONTINUOUS, name=\"d3I_plus\")\n\n# Process II time goal (fully utilize 70, overtime allowed)\nd3II_minus = model.addVar(lb=0, vtype=GRB.CONTINUOUS, name=\"d3II_minus\")\nd3II_plus  = model.addVar(lb=0, vtype=GRB.CONTINUOUS, name=\"d3II_plus\")\n\nmodel.update()\n\n# =========================\n# Goal constraints\n# =========================\n\n# 1) Profit goal: 300 xA + 450 xB >= 10000\n#    Represented as equality with deviations\nmodel.addConstr(\n    p_A * xA + p_B * xB + d1_minus - d1_plus == profit_goal,\n    name=\"ProfitGoal\"\n)\n\n# 2) Contractual production goals\n#    xA >= 10\nmodel.addConstr(\n    xA + d2A_minus - d2A_plus == min_A,\n    name=\"MinA\"\n)\n\n#    xB >= 15\nmodel.addConstr(\n    xB + d2B_minus - d2B_plus == min_B,\n    name=\"MinB\"\n)\n\n# 3) Process I time goal: exactly 150 hours\nmodel.addConstr(\n    tI_A * xA + tI_B * xB + d3I_minus - d3I_plus == cap_I,\n    name=\"ProcessI_Time\"\n)\n\n# 4) Process II time goal: fully utilize 70 hours (overtime allowed)\nmodel.addConstr(\n    tII_A * xA + tII_B * xB + d3II_minus - d3II_plus == cap_II,\n    name=\"ProcessII_Time\"\n)\n\n# =========================\n# Objective: weighted goal programming\n# =========================\n\n# Large weights for higher-priority underachievement deviations\nw_contract = 1000.0  # for d2A_minus, d2B_minus\nw_profit   = 100.0   # for d1_minus\nw_time     = 1.0     # for process time deviations\n\nobjective = (\n    w_contract * (d2A_minus + d2B_minus) +\n    w_profit   * d1_minus +\n    w_time     * (d3I_minus + d3I_plus + d3II_minus + d3II_plus)\n)\n\n# Overachievement deviations for profit and production are not penalized\n# (d1_plus, d2A_plus, d2B_plus) appear with zero weight.\n\nmodel.setObjective(objective, GRB.MINIMIZE)\n\n# =========================\n# Optimize\n# =========================\nmodel.optimize()\n\n# =========================\n# Results\n# =========================\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal objective value: {model.objVal}\")\n    print(f\"xA (Model A units): {xA.X}\")\n    print(f\"xB (Model B units): {xB.X}\")\n    print(f\"Profit underachievement d1_minus: {d1_minus.X}\")\n    print(f\"Profit overachievement d1_plus: {d1_plus.X}\")\n    print(f\"Process I time used: {tI_A * xA.X + tI_B * xB.X}\")\n    print(f\"Process II time used: {tII_A * xA.X + tII_B * xB.X}\")\nelse:\n    print(\"No optimal solution found\")\n```", "extracted_code": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# =========================\n# Data setup\n# =========================\n\n# Processing times (hours per unit)\ntI_A = 4\ntI_B = 6\ntII_A = 3\ntII_B = 2\n\n# Capacities / targets\ncap_I = 150      # Process I target hours\ncap_II = 70      # Process II regular capacity (target to fully utilize)\n\n# Profit per unit\np_A = 300\np_B = 450\n\n# Goals\nprofit_goal = 10000\nmin_A = 10\nmin_B = 15\n\n# =========================\n# Create model\n# =========================\nmodel = gp.Model(\"Microcomputer_Goal_Programming\")\n\n# =========================\n# Decision variables\n# =========================\n\n# Production quantities\nxA = model.addVar(lb=0, vtype=GRB.CONTINUOUS, name=\"xA\")\nxB = model.addVar(lb=0, vtype=GRB.CONTINUOUS, name=\"xB\")\n\n# Deviation variables (all nonnegative)\n# Profit goal\nd1_minus = model.addVar(lb=0, vtype=GRB.CONTINUOUS, name=\"d1_minus\")\nd1_plus  = model.addVar(lb=0, vtype=GRB.CONTINUOUS, name=\"d1_plus\")\n\n# Contractual production goals\nd2A_minus = model.addVar(lb=0, vtype=GRB.CONTINUOUS, name=\"d2A_minus\")\nd2A_plus  = model.addVar(lb=0, vtype=GRB.CONTINUOUS, name=\"d2A_plus\")\nd2B_minus = model.addVar(lb=0, vtype=GRB.CONTINUOUS, name=\"d2B_minus\")\nd2B_plus  = model.addVar(lb=0, vtype=GRB.CONTINUOUS, name=\"d2B_plus\")\n\n# Process I time goal (exactly 150)\nd3I_minus = model.addVar(lb=0, vtype=GRB.CONTINUOUS, name=\"d3I_minus\")\nd3I_plus  = model.addVar(lb=0, vtype=GRB.CONTINUOUS, name=\"d3I_plus\")\n\n# Process II time goal (fully utilize 70, overtime allowed)\nd3II_minus = model.addVar(lb=0, vtype=GRB.CONTINUOUS, name=\"d3II_minus\")\nd3II_plus  = model.addVar(lb=0, vtype=GRB.CONTINUOUS, name=\"d3II_plus\")\n\nmodel.update()\n\n# =========================\n# Goal constraints\n# =========================\n\n# 1) Profit goal: 300 xA + 450 xB >= 10000\n#    Represented as equality with deviations\nmodel.addConstr(\n    p_A * xA + p_B * xB + d1_minus - d1_plus == profit_goal,\n    name=\"ProfitGoal\"\n)\n\n# 2) Contractual production goals\n#    xA >= 10\nmodel.addConstr(\n    xA + d2A_minus - d2A_plus == min_A,\n    name=\"MinA\"\n)\n\n#    xB >= 15\nmodel.addConstr(\n    xB + d2B_minus - d2B_plus == min_B,\n    name=\"MinB\"\n)\n\n# 3) Process I time goal: exactly 150 hours\nmodel.addConstr(\n    tI_A * xA + tI_B * xB + d3I_minus - d3I_plus == cap_I,\n    name=\"ProcessI_Time\"\n)\n\n# 4) Process II time goal: fully utilize 70 hours (overtime allowed)\nmodel.addConstr(\n    tII_A * xA + tII_B * xB + d3II_minus - d3II_plus == cap_II,\n    name=\"ProcessII_Time\"\n)\n\n# =========================\n# Objective: weighted goal programming\n# =========================\n\n# Large weights for higher-priority underachievement deviations\nw_contract = 1000.0  # for d2A_minus, d2B_minus\nw_profit   = 100.0   # for d1_minus\nw_time     = 1.0     # for process time deviations\n\nobjective = (\n    w_contract * (d2A_minus + d2B_minus) +\n    w_profit   * d1_minus +\n    w_time     * (d3I_minus + d3I_plus + d3II_minus + d3II_plus)\n)\n\n# Overachievement deviations for profit and production are not penalized\n# (d1_plus, d2A_plus, d2B_plus) appear with zero weight.\n\nmodel.setObjective(objective, GRB.MINIMIZE)\n\n# =========================\n# Optimize\n# =========================\nmodel.optimize()\n\n# =========================\n# Results\n# =========================\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal objective value: {model.objVal}\")\n    print(f\"xA (Model A units): {xA.X}\")\n    print(f\"xB (Model B units): {xB.X}\")\n    print(f\"Profit underachievement d1_minus: {d1_minus.X}\")\n    print(f\"Profit overachievement d1_plus: {d1_plus.X}\")\n    print(f\"Process I time used: {tI_A * xA.X + tI_B * xB.X}\")\n    print(f\"Process II time used: {tII_A * xA.X + tII_B * xB.X}\")\nelse:\n    print(\"No optimal solution found\")", "execution_success": true, "mathematical_accuracy": false, "execution_result": "Execution Successful", "execution_best_solution": 0.0, "execution_state": "Execution Successful"}
{"task_id": "B085", "description": "Healthy Pet Foods Company produces two types of dog food: Meaties and Yummies. Each pack of Meaties contains 2 pounds of grains and 3 pounds of meat; each pack of Yummies contains 3 pounds of grains and 1.5 pounds of meat. The company believes it can sell any quantity of dog food that it can produce. Meaties sell for $2.80 per pack, and Yummies sell for $2.00 per pack. The company's production is subject to several constraints. First, a maximum of 400,000 pounds of grains can be purchased each month at a price of $0.20 per pound of grains. A maximum of 300,000 pounds of meat can be purchased each month at a price of $0.50 per pound of meat. Additionally, a special machine is required to produce Meaties, with a monthly capacity of 90,000 packs. The variable costs for mixing and packaging dog food are $0.25 per pack (Meaties) and $0.20 per pack (Yummies). Detailed information is provided in Table B-1.\n\n**Table B-1 Healthy Pet Foods Data**\n\n|                    | Meaties      | Yummies    |\n|--------------------|--------------|------------|\n| Price per pack     | $2.80        | $2.00      |\n| Raw materials      |              |            |\n| - Grains           | 2.0 lbs      | 3.0 lbs    |\n| - Meat             | 3.0 lbs      | 1.5 lbs    |\n| Variable cost      | $0.25/pack   | $0.20/pack |\n| Resources          |              |            |\n| Meaties capacity   | 90,000 packs/month |       |\n| Monthly available grains | 400,000 lbs |      |\n| Monthly available meat | 300,000 lbs |        |\n\nAssume you are the manager of the dog food department at Healthy Pet Foods Company. Your salary is based on the department's profit, so you will try to maximize profit. How should you operate the department to maximize both the profit and your salary?", "ground_truth": 77500.0, "formulation": null, "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_healthy_pet_foods():\n    \"\"\"\n    Solves the production planning problem for Healthy Pet Foods\n    to maximize monthly profit.\n    \"\"\"\n    try:\n        # --- Parameters ---\n        products = ['Meaties', 'Yummies']\n\n        # Selling Price ($/pack)\n        selling_price = {'Meaties': 2.80, 'Yummies': 2.00}\n\n        # Raw Material Requirements (lbs/pack)\n        grains_req = {'Meaties': 2.0, 'Yummies': 3.0}\n        meat_req = {'Meaties': 3.0, 'Yummies': 1.5}\n\n        # Variable Costs ($/pack) - Mixing and Packaging\n        variable_cost = {'Meaties': 0.25, 'Yummies': 0.20}\n\n        # Raw Material Costs ($/lb)\n        cost_grains = 0.20\n        cost_meat = 0.50\n\n        # Resource Availability (per month)\n        max_grains = 400000  # lbs\n        max_meat = 300000  # lbs\n        max_meaties_capacity = 90000  # packs\n\n        # --- Calculate Profit per Pack ---\n        # Profit = Selling Price - Grain Cost - Meat Cost - Variable Cost\n        profit_per_pack = {}\n        for p in products:\n            cost_of_grains = grains_req[p] * cost_grains\n            cost_of_meat = meat_req[p] * cost_meat\n            profit_per_pack[p] = selling_price[\n                p] - cost_of_grains - cost_of_meat - variable_cost[p]\n            # print(f\"Calculated profit for {p}: ${profit_per_pack[p]:.2f}\") # For verification\n\n        # --- Create Gurobi Model ---\n        model = gp.Model(\"HealthyPetFoodsProfit\")\n\n        # --- Decision Variables ---\n        # Produce[p]: Number of packs of product p produced per month\n        Produce = model.addVars(products,\n                                name=\"Produce\",\n                                vtype=GRB.CONTINUOUS,\n                                lb=0)\n\n        # --- Objective Function: Maximize Total Profit ---\n        model.setObjective(\n            gp.quicksum(profit_per_pack[p] * Produce[p] for p in products),\n            GRB.MAXIMIZE)\n\n        # --- Constraints ---\n        # 1. Grain Availability Constraint\n        model.addConstr(gp.quicksum(grains_req[p] * Produce[p]\n                                    for p in products) <= max_grains,\n                        name=\"GrainLimit\")\n\n        # 2. Meat Availability Constraint\n        model.addConstr(gp.quicksum(meat_req[p] * Produce[p] for p in products)\n                        <= max_meat,\n                        name=\"MeatLimit\")\n\n        # 3. Meaties Production Capacity Constraint\n        model.addConstr(Produce['Meaties'] <= max_meaties_capacity,\n                        name=\"MeatiesCapacity\")\n\n        # Suppress Gurobi output to console if desired\n        # model.setParam('OutputFlag', 0)\n\n        # Optimize the model\n        model.optimize()\n\n        # --- Results ---\n        if model.status == GRB.OPTIMAL:\n            print(\"Optimal production plan found.\")\n            print(f\"Maximum Monthly Profit: ${model.ObjVal:.2f}\")\n\n            print(\"\\nOptimal Production Quantities (packs per month):\")\n            for p in products:\n                print(f\"  {p}: {Produce[p].X:.2f} packs\")\n\n            print(\"\\nResource Utilization:\")\n            grains_used = sum(grains_req[p] * Produce[p].X for p in products)\n            meat_used = sum(meat_req[p] * Produce[p].X for p in products)\n            meaties_produced = Produce['Meaties'].X\n\n            print(\n                f\"  Grains Used: {grains_used:.2f} / {max_grains} lbs \"\n                f\"({(grains_used/max_grains*100) if max_grains > 0 else 0:.1f}%)\"\n            )\n            print(f\"  Meat Used: {meat_used:.2f} / {max_meat} lbs \"\n                  f\"({(meat_used/max_meat*100) if max_meat > 0 else 0:.1f}%)\")\n            print(\n                f\"  Meaties Production: {meaties_produced:.2f} / {max_meaties_capacity} packs \"\n                f\"({(meaties_produced/max_meaties_capacity*100) if max_meaties_capacity > 0 else 0:.1f}%)\"\n            )\n\n        elif model.status == GRB.INFEASIBLE:\n            print(\"Model is infeasible. Check constraints and data.\")\n            # Compute and print IIS (Irreducible Inconsistent Subsystem)\n            # model.computeIIS()\n            # model.write(\"healthy_pet_foods_iis.ilp\")\n            # print(\"IIS written to healthy_pet_foods_iis.ilp.\")\n        else:\n            print(f\"Optimization stopped with status: {model.status}\")\n            if model.SolCount == 0:\n                print(\"No feasible solution found.\")\n\n    except gp.GurobiError as e:\n        print(f\"Gurobi error code {e.errno}: {e}\")\n    except Exception as e:\n        print(f\"An unexpected error occurred: {e}\")\n\n\nif __name__ == '__main__':\n    solve_healthy_pet_foods()", "output_status": [], "success_count": 0, "success_confidence": 0, "fail_to_diagnose": 0, "fail_to_verify": 0, "retrieved_insights": [], "tag": [{"problem_domain": "Production Planning", "modeling_type": "LP", "industry_sector": "Manufacturing", "reason": "The task involves determining optimal production quantities of dog food types to maximize profit, subject to resource constraints (grains, meat, machine capacity). This is a classic production planning problem. The solver uses continuous variables and linear objective/constraints, fitting the Linear Programming (LP) paradigm. The context of producing physical goods (dog food) places it squarely in the manufacturing sector."}], "cluster": null, "prompt": "Below is an operations research question. First formulate the problem as an optimization problem. Then according to the formulated problem, write python code that uses 'gurobipy' to solve the optimization problem. You should write a complete python code that can be executed to solve the optimization problem.\n\nIMPORTANT: Your code should follow these requirements:\n1. Create a Gurobi model variable named 'model' (not 'm' or other names)\n2. Include all necessary imports and data setup\n3. Write the complete optimization code that can run independently\n4. Do NOT wrap everything in a function - write the code directly\n5. Make sure the model is created and optimized in the main execution flow\n6. The code should print the optimal objective value when solved successfully\n\nExample format:\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Data setup\ndata = {...}\n\n# Create model\nmodel = gp.Model(\"ProblemName\")\n\n# Decision variables\nx = model.addVars(...)\n\n# Objective\nmodel.setObjective(...)\n\n# Constraints\nmodel.addConstr(...)\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\nelse:\n    print(\"No optimal solution found\")\n```\n\n# Question:\nHealthy Pet Foods Company produces two types of dog food: Meaties and Yummies. Each pack of Meaties contains 2 pounds of grains and 3 pounds of meat; each pack of Yummies contains 3 pounds of grains and 1.5 pounds of meat. The company believes it can sell any quantity of dog food that it can produce. Meaties sell for $2.80 per pack, and Yummies sell for $2.00 per pack. The company's production is subject to several constraints. First, a maximum of 400,000 pounds of grains can be purchased each month at a price of $0.20 per pound of grains. A maximum of 300,000 pounds of meat can be purchased each month at a price of $0.50 per pound of meat. Additionally, a special machine is required to produce Meaties, with a monthly capacity of 90,000 packs. The variable costs for mixing and packaging dog food are $0.25 per pack (Meaties) and $0.20 per pack (Yummies). Detailed information is provided in Table B-1.\n\n**Table B-1 Healthy Pet Foods Data**\n\n|                    | Meaties      | Yummies    |\n|--------------------|--------------|------------|\n| Price per pack     | $2.80        | $2.00      |\n| Raw materials      |              |            |\n| - Grains           | 2.0 lbs      | 3.0 lbs    |\n| - Meat             | 3.0 lbs      | 1.5 lbs    |\n| Variable cost      | $0.25/pack   | $0.20/pack |\n| Resources          |              |            |\n| Meaties capacity   | 90,000 packs/month |       |\n| Monthly available grains | 400,000 lbs |      |\n| Monthly available meat | 300,000 lbs |        |\n\nAssume you are the manager of the dog food department at Healthy Pet Foods Company. Your salary is based on the department's profit, so you will try to maximize profit. How should you operate the department to maximize both the profit and your salary?\n\n# Response:", "generated_output": "Below is the formulation and then the complete Python code using `gurobipy`.\n\n---\n\n## 1. Optimization Model Formulation\n\n**Decision variables**\n\n- \\( x_M \\ge 0 \\): number of Meaties packs produced per month  \n- \\( x_Y \\ge 0 \\): number of Yummies packs produced per month  \n\n**Parameters**\n\n- Selling prices:  \n  - Meaties: \\( p_M = 2.80 \\) \\$/pack  \n  - Yummies: \\( p_Y = 2.00 \\) \\$/pack  \n\n- Variable mixing/packaging costs:  \n  - Meaties: \\( c_M^{mix} = 0.25 \\) \\$/pack  \n  - Yummies: \\( c_Y^{mix} = 0.20 \\) \\$/pack  \n\n- Raw material usage per pack:  \n  - Meaties: 2.0 lbs grains, 3.0 lbs meat  \n  - Yummies: 3.0 lbs grains, 1.5 lbs meat  \n\n- Raw material purchase costs:  \n  - Grains: \\( c_G = 0.20 \\) \\$/lb  \n  - Meat: \\( c_{Meat} = 0.50 \\) \\$/lb  \n\n- Resource limits:  \n  - Meaties machine capacity: \\( x_M \\le 90{,}000 \\) packs/month  \n  - Grains availability: at most 400,000 lbs/month  \n  - Meat availability: at most 300,000 lbs/month  \n\n**Profit per pack**\n\n- Meaties:\n  - Revenue: 2.80  \n  - Grain cost: \\(2.0 \\times 0.20 = 0.40\\)  \n  - Meat cost: \\(3.0 \\times 0.50 = 1.50\\)  \n  - Mixing/packaging: 0.25  \n  - Profit per Meaties pack:  \n    \\[\n    \\pi_M = 2.80 - (0.40 + 1.50 + 0.25) = 0.65\n    \\]\n\n- Yummies:\n  - Revenue: 2.00  \n  - Grain cost: \\(3.0 \\times 0.20 = 0.60\\)  \n  - Meat cost: \\(1.5 \\times 0.50 = 0.75\\)  \n  - Mixing/packaging: 0.20  \n  - Profit per Yummies pack:  \n    \\[\n    \\pi_Y = 2.00 - (0.60 + 0.75 + 0.20) = 0.45\n    \\]\n\n**Objective: maximize monthly profit**\n\n\\[\n\\max \\; Z = 0.65 x_M + 0.45 x_Y\n\\]\n\n**Constraints**\n\n1. Meaties machine capacity:\n   \\[\n   x_M \\le 90{,}000\n   \\]\n\n2. Grain availability:\n   \\[\n   2.0 x_M + 3.0 x_Y \\le 400{,}000\n   \\]\n\n3. Meat availability:\n   \\[\n   3.0 x_M + 1.5 x_Y \\le 300{,}000\n   \\]\n\n4. Nonnegativity:\n   \\[\n   x_M \\ge 0,\\quad x_Y \\ge 0\n   \\]\n\n---\n\n## 2. Complete Python Code with Gurobi\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# -----------------------------\n# Data setup\n# -----------------------------\n\n# Profit per pack (revenue - raw material cost - variable mixing/packaging cost)\nprofit_meaties = 0.65  # $/pack\nprofit_yummies = 0.45  # $/pack\n\n# Resource limits\nmax_meaties_capacity = 90000      # packs/month\nmax_grains = 400000               # lbs/month\nmax_meat = 300000                 # lbs/month\n\n# Raw material usage per pack\ngrains_meaties = 2.0              # lbs per Meaties pack\nmeat_meaties = 3.0                # lbs per Meaties pack\ngrains_yummies = 3.0              # lbs per Yummies pack\nmeat_yummies = 1.5                # lbs per Yummies pack\n\n# -----------------------------\n# Create model\n# -----------------------------\nmodel = gp.Model(\"HealthyPetFoods\")\n\n# -----------------------------\n# Decision variables\n# -----------------------------\n# x_M: number of Meaties packs\n# x_Y: number of Yummies packs\nx_M = model.addVar(name=\"Meaties\", lb=0.0)\nx_Y = model.addVar(name=\"Yummies\", lb=0.0)\n\n# -----------------------------\n# Objective: maximize profit\n# -----------------------------\nmodel.setObjective(\n    profit_meaties * x_M + profit_yummies * x_Y,\n    GRB.MAXIMIZE\n)\n\n# -----------------------------\n# Constraints\n# -----------------------------\n\n# 1. Meaties machine capacity\nmodel.addConstr(x_M <= max_meaties_capacity, name=\"MeatiesCapacity\")\n\n# 2. Grain availability\nmodel.addConstr(\n    grains_meaties * x_M + grains_yummies * x_Y <= max_grains,\n    name=\"GrainLimit\"\n)\n\n# 3. Meat availability\nmodel.addConstr(\n    meat_meaties * x_M + meat_yummies * x_Y <= max_meat,\n    name=\"MeatLimit\"\n)\n\n# -----------------------------\n# Optimize\n# -----------------------------\nmodel.optimize()\n\n# -----------------------------\n# Results\n# -----------------------------\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\n    print(f\"Optimal Meaties production: {x_M.X}\")\n    print(f\"Optimal Yummies production: {x_Y.X}\")\nelse:\n    print(\"No optimal solution found\")\n```", "extracted_code": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# -----------------------------\n# Data setup\n# -----------------------------\n\n# Profit per pack (revenue - raw material cost - variable mixing/packaging cost)\nprofit_meaties = 0.65  # $/pack\nprofit_yummies = 0.45  # $/pack\n\n# Resource limits\nmax_meaties_capacity = 90000      # packs/month\nmax_grains = 400000               # lbs/month\nmax_meat = 300000                 # lbs/month\n\n# Raw material usage per pack\ngrains_meaties = 2.0              # lbs per Meaties pack\nmeat_meaties = 3.0                # lbs per Meaties pack\ngrains_yummies = 3.0              # lbs per Yummies pack\nmeat_yummies = 1.5                # lbs per Yummies pack\n\n# -----------------------------\n# Create model\n# -----------------------------\nmodel = gp.Model(\"HealthyPetFoods\")\n\n# -----------------------------\n# Decision variables\n# -----------------------------\n# x_M: number of Meaties packs\n# x_Y: number of Yummies packs\nx_M = model.addVar(name=\"Meaties\", lb=0.0)\nx_Y = model.addVar(name=\"Yummies\", lb=0.0)\n\n# -----------------------------\n# Objective: maximize profit\n# -----------------------------\nmodel.setObjective(\n    profit_meaties * x_M + profit_yummies * x_Y,\n    GRB.MAXIMIZE\n)\n\n# -----------------------------\n# Constraints\n# -----------------------------\n\n# 1. Meaties machine capacity\nmodel.addConstr(x_M <= max_meaties_capacity, name=\"MeatiesCapacity\")\n\n# 2. Grain availability\nmodel.addConstr(\n    grains_meaties * x_M + grains_yummies * x_Y <= max_grains,\n    name=\"GrainLimit\"\n)\n\n# 3. Meat availability\nmodel.addConstr(\n    meat_meaties * x_M + meat_yummies * x_Y <= max_meat,\n    name=\"MeatLimit\"\n)\n\n# -----------------------------\n# Optimize\n# -----------------------------\nmodel.optimize()\n\n# -----------------------------\n# Results\n# -----------------------------\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\n    print(f\"Optimal Meaties production: {x_M.X}\")\n    print(f\"Optimal Yummies production: {x_Y.X}\")\nelse:\n    print(\"No optimal solution found\")", "execution_success": true, "mathematical_accuracy": true, "execution_result": "Execution Successful", "execution_best_solution": 77500.0, "execution_state": "Execution Successful"}
{"task_id": "B054", "description": "A master's student in Operations Research at a certain university is required to select two courses in mathematics, two in operations research, and two in computer science from a total of seven courses: Calculus, Operations Research, Data Structures, Management Statistics, Computer Simulation, Computer Programming, and Forecasting. Some courses belong to only one category: Calculus falls under Mathematics, Computer Programming under Computer Science. However, some courses fall under multiple categories: Operations Research can be considered both Operations Research and Mathematics, Data Structures both Computer Science and Mathematics, Management Statistics both Mathematics and Operations Research, Computer Simulation both Computer Science and Operations Research, and Forecasting both Operations Research and Mathematics. Courses that fall under multiple categories can fulfill the requirement of both categories simultaneously. Additionally, some courses have prerequisites: Computer Simulation or Data Structures requires Computer Programming first, Management Statistics requires Calculus first, and Forecasting requires Management Statistics first. The question is: What is the minimum number of courses a master's student must take, and which specific courses, to meet the above requirements?", "ground_truth": 4.0, "formulation": null, "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_course_selection():\n    \"\"\"\n    Solves the course selection problem to minimize the number of courses taken\n    while satisfying category and prerequisite requirements.\n    \"\"\"\n    try:\n        # --- Data ---\n        courses = ['Calc', 'OR', 'DS', 'MS', 'Sim', 'Prog', 'Fcst']\n        categories = ['Math', 'OpRes', 'CompSci']\n\n        # Requirements per category\n        category_requirements = {'Math': 2, 'OpRes': 2, 'CompSci': 2}\n\n        # Course-to-category mapping: course_category[course][category] = 1 if belongs, else 0 or not present\n        course_category_map = {\n            'Calc': {\n                'Math': 1\n            },\n            'OR': {\n                'OpRes': 1,\n                'Math': 1\n            },\n            'DS': {\n                'CompSci': 1,\n                'Math': 1\n            },\n            'MS': {\n                'Math': 1,\n                'OpRes': 1\n            },\n            'Sim': {\n                'CompSci': 1,\n                'OpRes': 1\n            },\n            'Prog': {\n                'CompSci': 1\n            },\n            'Fcst': {\n                'OpRes': 1,\n                'Math': 1\n            }\n        }\n\n        # Prerequisites: prereqs[course_requiring_prereq] = [list_of_prereqs]\n        prerequisites = {\n            'Sim': ['Prog'],\n            'DS': ['Prog'],\n            'MS': ['Calc'],\n            'Fcst': ['MS']\n        }\n\n        # --- Create Gurobi Model ---\n        model = gp.Model(\"CourseSelectionOptimization\")\n\n        # --- Decision Variables ---\n        # x[c]: 1 if course c is selected, 0 otherwise\n        x = model.addVars(courses, vtype=GRB.BINARY, name=\"x\")\n\n        # --- Objective Function: Minimize the total number of courses selected ---\n        model.setObjective(gp.quicksum(x[c] for c in courses), GRB.MINIMIZE)\n\n        # --- Constraints ---\n        # 1. Category Requirements\n        for cat in categories:\n            model.addConstr(gp.quicksum(\n                x[c] * course_category_map[c].get(cat, 0) for c in courses)\n                            >= category_requirements[cat],\n                            name=f\"Req_{cat}\")\n\n        # 2. Prerequisite Constraints\n        # If x[course_with_prereq] = 1, then x[prereq_course] must be 1.\n        # So, x[course_with_prereq] <= x[prereq_course]\n        for course, prereq_list in prerequisites.items():\n            for prereq_course in prereq_list:\n                if course in x and prereq_course in x:  # Ensure both courses are valid keys\n                    model.addConstr(\n                        x[course] <= x[prereq_course],\n                        name=f\"Prereq_{prereq_course}_for_{course}\")\n\n        # Suppress Gurobi output to console if desired\n        # model.setParam('OutputFlag', 0)\n\n        # Optimize the model\n        model.optimize()\n\n        # --- Results ---\n        if model.status == GRB.OPTIMAL:\n            print(\"Optimal course selection found.\")\n            print(f\"Minimum number of courses to take: {model.ObjVal:.0f}\")\n\n            print(\"\\nSelected Courses:\")\n            selected_courses_list = []\n            for c in courses:\n                if x[c].X > 0.5:  # If x[c] is 1\n                    selected_courses_list.append(c)\n                    print(f\"  - {c}\")\n\n            print(\"\\nVerification of Category Requirements:\")\n            for cat in categories:\n                courses_for_cat = 0\n                cat_courses_taken = []\n                for c_taken in selected_courses_list:\n                    if course_category_map[c_taken].get(cat, 0) == 1:\n                        courses_for_cat += 1\n                        cat_courses_taken.append(c_taken)\n                print(\n                    f\"  Category '{cat}': Required={category_requirements[cat]}, Taken={courses_for_cat} ({', '.join(cat_courses_taken)})\"\n                )\n\n            print(\"\\nVerification of Prerequisites:\")\n            all_prereqs_met = True\n            for course_taken in selected_courses_list:\n                if course_taken in prerequisites:\n                    for prereq_c in prerequisites[course_taken]:\n                        if prereq_c not in selected_courses_list:\n                            print(\n                                f\"  ERROR: Course '{course_taken}' taken, but its prerequisite '{prereq_c}' is NOT taken.\"\n                            )\n                            all_prereqs_met = False\n            if all_prereqs_met:\n                print(\n                    \"  All prerequisite conditions are met for the selected courses.\"\n                )\n\n        elif model.status == GRB.INFEASIBLE:\n            print(\n                \"Model is infeasible. The requirements cannot be met with the given courses and constraints.\"\n            )\n            # Compute and print IIS (Irreducible Inconsistent Subsystem)\n            # model.computeIIS()\n            # model.write(\"course_selection_iis.ilp\")\n            # print(\"IIS written to course_selection_iis.ilp.\")\n        else:\n            print(f\"Optimization stopped with status: {model.status}\")\n\n    except gp.GurobiError as e:\n        print(f\"Gurobi error code {e.errno}: {e}\")\n    except Exception as e:\n        print(f\"An unexpected error occurred: {e}\")\n\n\nif __name__ == '__main__':\n    solve_course_selection()", "output_status": [], "success_count": 0, "success_confidence": 0, "fail_to_diagnose": 0, "fail_to_verify": 0, "retrieved_insights": [], "tag": [{"problem_domain": "Selection", "modeling_type": "MILP", "industry_sector": "Education", "reason": "The problem involves selecting a subset of courses to satisfy various requirements (category counts, prerequisites) while minimizing the total number of selected courses. The solver uses binary decision variables and linear constraints, making it a Mixed-Integer Linear Program (specifically, an Integer Program since all variables are binary)."}], "cluster": null, "prompt": "Below is an operations research question. First formulate the problem as an optimization problem. Then according to the formulated problem, write python code that uses 'gurobipy' to solve the optimization problem. You should write a complete python code that can be executed to solve the optimization problem.\n\nIMPORTANT: Your code should follow these requirements:\n1. Create a Gurobi model variable named 'model' (not 'm' or other names)\n2. Include all necessary imports and data setup\n3. Write the complete optimization code that can run independently\n4. Do NOT wrap everything in a function - write the code directly\n5. Make sure the model is created and optimized in the main execution flow\n6. The code should print the optimal objective value when solved successfully\n\nExample format:\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Data setup\ndata = {...}\n\n# Create model\nmodel = gp.Model(\"ProblemName\")\n\n# Decision variables\nx = model.addVars(...)\n\n# Objective\nmodel.setObjective(...)\n\n# Constraints\nmodel.addConstr(...)\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\nelse:\n    print(\"No optimal solution found\")\n```\n\n# Question:\nA master's student in Operations Research at a certain university is required to select two courses in mathematics, two in operations research, and two in computer science from a total of seven courses: Calculus, Operations Research, Data Structures, Management Statistics, Computer Simulation, Computer Programming, and Forecasting. Some courses belong to only one category: Calculus falls under Mathematics, Computer Programming under Computer Science. However, some courses fall under multiple categories: Operations Research can be considered both Operations Research and Mathematics, Data Structures both Computer Science and Mathematics, Management Statistics both Mathematics and Operations Research, Computer Simulation both Computer Science and Operations Research, and Forecasting both Operations Research and Mathematics. Courses that fall under multiple categories can fulfill the requirement of both categories simultaneously. Additionally, some courses have prerequisites: Computer Simulation or Data Structures requires Computer Programming first, Management Statistics requires Calculus first, and Forecasting requires Management Statistics first. The question is: What is the minimum number of courses a master's student must take, and which specific courses, to meet the above requirements?\n\n# Response:", "generated_output": "```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# =========================\n# Data setup\n# =========================\n\n# List of all courses\ncourses = [\n    \"Calculus\",\n    \"Operations Research\",\n    \"Data Structures\",\n    \"Management Statistics\",\n    \"Computer Simulation\",\n    \"Computer Programming\",\n    \"Forecasting\"\n]\n\n# Category sets\nmath_courses = [\n    \"Calculus\",\n    \"Operations Research\",\n    \"Data Structures\",\n    \"Management Statistics\",\n    \"Forecasting\"\n]\n\nor_courses = [\n    \"Operations Research\",\n    \"Management Statistics\",\n    \"Computer Simulation\",\n    \"Forecasting\"\n]\n\ncs_courses = [\n    \"Data Structures\",\n    \"Computer Simulation\",\n    \"Computer Programming\"\n]\n\n# Prerequisites: if key is taken, then value must also be taken\nprereq = {\n    \"Data Structures\": \"Computer Programming\",\n    \"Computer Simulation\": \"Computer Programming\",\n    \"Management Statistics\": \"Calculus\",\n    \"Forecasting\": \"Management Statistics\"\n}\n\n# =========================\n# Create model\n# =========================\n\nmodel = gp.Model(\"Course_Selection\")\n\n# =========================\n# Decision variables\n# =========================\n\n# x[c] = 1 if course c is taken, 0 otherwise\nx = model.addVars(courses, vtype=GRB.BINARY, name=\"x\")\n\n# =========================\n# Objective\n# =========================\n\n# Minimize total number of courses taken\nmodel.setObjective(gp.quicksum(x[c] for c in courses), GRB.MINIMIZE)\n\n# =========================\n# Constraints\n# =========================\n\n# At least 2 math courses\nmodel.addConstr(gp.quicksum(x[c] for c in math_courses) >= 2, name=\"MathRequirement\")\n\n# At least 2 OR courses\nmodel.addConstr(gp.quicksum(x[c] for c in or_courses) >= 2, name=\"ORRequirement\")\n\n# At least 2 CS courses\nmodel.addConstr(gp.quicksum(x[c] for c in cs_courses) >= 2, name=\"CSRequirement\")\n\n# Prerequisite constraints\nfor c, p in prereq.items():\n    # If course c is taken, prerequisite p must also be taken: x[c] <= x[p]\n    model.addConstr(x[c] <= x[p], name=f\"Prereq_{c}_requires_{p}\")\n\n# =========================\n# Optimize\n# =========================\n\nmodel.optimize()\n\n# =========================\n# Results\n# =========================\n\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value (minimum number of courses): {model.objVal}\")\n    print(\"Courses to take:\")\n    for c in courses:\n        if x[c].X > 0.5:\n            print(f\"  - {c}\")\nelse:\n    print(\"No optimal solution found\")\n```", "extracted_code": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# =========================\n# Data setup\n# =========================\n\n# List of all courses\ncourses = [\n    \"Calculus\",\n    \"Operations Research\",\n    \"Data Structures\",\n    \"Management Statistics\",\n    \"Computer Simulation\",\n    \"Computer Programming\",\n    \"Forecasting\"\n]\n\n# Category sets\nmath_courses = [\n    \"Calculus\",\n    \"Operations Research\",\n    \"Data Structures\",\n    \"Management Statistics\",\n    \"Forecasting\"\n]\n\nor_courses = [\n    \"Operations Research\",\n    \"Management Statistics\",\n    \"Computer Simulation\",\n    \"Forecasting\"\n]\n\ncs_courses = [\n    \"Data Structures\",\n    \"Computer Simulation\",\n    \"Computer Programming\"\n]\n\n# Prerequisites: if key is taken, then value must also be taken\nprereq = {\n    \"Data Structures\": \"Computer Programming\",\n    \"Computer Simulation\": \"Computer Programming\",\n    \"Management Statistics\": \"Calculus\",\n    \"Forecasting\": \"Management Statistics\"\n}\n\n# =========================\n# Create model\n# =========================\n\nmodel = gp.Model(\"Course_Selection\")\n\n# =========================\n# Decision variables\n# =========================\n\n# x[c] = 1 if course c is taken, 0 otherwise\nx = model.addVars(courses, vtype=GRB.BINARY, name=\"x\")\n\n# =========================\n# Objective\n# =========================\n\n# Minimize total number of courses taken\nmodel.setObjective(gp.quicksum(x[c] for c in courses), GRB.MINIMIZE)\n\n# =========================\n# Constraints\n# =========================\n\n# At least 2 math courses\nmodel.addConstr(gp.quicksum(x[c] for c in math_courses) >= 2, name=\"MathRequirement\")\n\n# At least 2 OR courses\nmodel.addConstr(gp.quicksum(x[c] for c in or_courses) >= 2, name=\"ORRequirement\")\n\n# At least 2 CS courses\nmodel.addConstr(gp.quicksum(x[c] for c in cs_courses) >= 2, name=\"CSRequirement\")\n\n# Prerequisite constraints\nfor c, p in prereq.items():\n    # If course c is taken, prerequisite p must also be taken: x[c] <= x[p]\n    model.addConstr(x[c] <= x[p], name=f\"Prereq_{c}_requires_{p}\")\n\n# =========================\n# Optimize\n# =========================\n\nmodel.optimize()\n\n# =========================\n# Results\n# =========================\n\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value (minimum number of courses): {model.objVal}\")\n    print(\"Courses to take:\")\n    for c in courses:\n        if x[c].X > 0.5:\n            print(f\"  - {c}\")\nelse:\n    print(\"No optimal solution found\")", "execution_success": true, "mathematical_accuracy": true, "execution_result": "Execution Successful", "execution_best_solution": 4.0, "execution_state": "Execution Successful"}
{"task_id": "B038", "description": "A company plans to transport goods between the city and the suburb and needs to choose the most environmentally friendly transportation method. The company can choose from the following three methods: motorcycle, small truck, and large truck. Each motorcycle trip produces 40 units of pollution, each small truck trip produces 70 units of pollution, and each large truck trip produces 100 units of pollution. The company's goal is to minimize total pollution.\n\nThe company can only choose two out of these three transportation methods.\n\nDue to certain road restrictions, the number of motorcycle trips cannot exceed 8.\n\nEach motorcycle trip can transport 10 units of products, each small truck trip can transport 20 units of products, and each large truck trip can transport 50 units of products. The company needs to transport at least 300 units of products.\n\nThe total number of trips must be less than or equal to 20.", "ground_truth": 600.0, "formulation": null, "correct_program": "def minimize_pollution(M=20):\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    model = Model(\"Minimize Pollution\")\n\n    # Decision variables\n    y_m = model.addVar(vtype=GRB.BINARY, name=\"motorcycle_method\")\n    y_s = model.addVar(vtype=GRB.BINARY, name=\"small_truck_method\")\n    y_l = model.addVar(vtype=GRB.BINARY, name=\"large_truck_method\")\n\n    x_m = model.addVar(vtype=GRB.INTEGER, lb=0, name=\"motorcycle_trips\")\n    x_s = model.addVar(vtype=GRB.INTEGER, lb=0, name=\"small_truck_trips\")\n    x_l = model.addVar(vtype=GRB.INTEGER, lb=0, name=\"large_truck_trips\")\n\n    # Set objective: minimize total pollution\n    model.setObjective(40 * x_m + 70 * x_s + 100 * x_l, GRB.MINIMIZE)\n\n    # Constraints\n    model.addConstr(y_m + y_s + y_l == 2, \"Method_Selection\")\n    model.addConstr(x_m <= 8, \"Motorcycle_Trip_Limit\")\n    model.addConstr(x_m <= M * y_m, \"Motorcycle_Method_Activation\")\n    model.addConstr(x_s <= M * y_s, \"SmallTruck_Method_Activation\")\n    model.addConstr(x_l <= M * y_l, \"LargeTruck_Method_Activation\")\n    model.addConstr(10 * x_m + 20 * x_s + 50 * x_l >= 300,\n                    \"Transport_Requirement\")\n    model.addConstr(x_m + x_s + x_l <= 20, \"Total_Trips_Limit\")\n\n    # Optimize the model\n    model.optimize()\n\n    # Check if a feasible solution was found\n    if model.status == GRB.OPTIMAL:\n        return model.objVal\n    else:\n        return None\nif __name__ == \"__main__\":\n    result = minimize_pollution()\n    if result is not None:\n        print(f\"Optimal total pollution: {result}\")\n    else:\n        print(\"No feasible solution found.\")", "output_status": [], "success_count": 0, "success_confidence": 0, "fail_to_diagnose": 0, "fail_to_verify": 0, "retrieved_insights": [], "tag": [{"problem_domain": "Transportation Planning", "modeling_type": "MILP", "industry_sector": "Logistics", "reason": "The problem involves selecting transportation methods and determining trip quantities to minimize pollution while meeting demand and capacity constraints, which falls under transportation planning. The use of both integer and binary variables, along with linear constraints and objective, indicates a Mixed-Integer Linear Programming (MILP) model. The application context of moving goods between locations for a company clearly places it in the logistics sector."}], "cluster": null, "prompt": "Below is an operations research question. First formulate the problem as an optimization problem. Then according to the formulated problem, write python code that uses 'gurobipy' to solve the optimization problem. You should write a complete python code that can be executed to solve the optimization problem.\n\nIMPORTANT: Your code should follow these requirements:\n1. Create a Gurobi model variable named 'model' (not 'm' or other names)\n2. Include all necessary imports and data setup\n3. Write the complete optimization code that can run independently\n4. Do NOT wrap everything in a function - write the code directly\n5. Make sure the model is created and optimized in the main execution flow\n6. The code should print the optimal objective value when solved successfully\n\nExample format:\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Data setup\ndata = {...}\n\n# Create model\nmodel = gp.Model(\"ProblemName\")\n\n# Decision variables\nx = model.addVars(...)\n\n# Objective\nmodel.setObjective(...)\n\n# Constraints\nmodel.addConstr(...)\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\nelse:\n    print(\"No optimal solution found\")\n```\n\n# Question:\nA company plans to transport goods between the city and the suburb and needs to choose the most environmentally friendly transportation method. The company can choose from the following three methods: motorcycle, small truck, and large truck. Each motorcycle trip produces 40 units of pollution, each small truck trip produces 70 units of pollution, and each large truck trip produces 100 units of pollution. The company's goal is to minimize total pollution.\n\nThe company can only choose two out of these three transportation methods.\n\nDue to certain road restrictions, the number of motorcycle trips cannot exceed 8.\n\nEach motorcycle trip can transport 10 units of products, each small truck trip can transport 20 units of products, and each large truck trip can transport 50 units of products. The company needs to transport at least 300 units of products.\n\nThe total number of trips must be less than or equal to 20.\n\n# Response:", "generated_output": "Below is the mathematical formulation followed by a complete Gurobi Python code.\n\n---\n\n## 1. Optimization Model Formulation\n\n**Decision variables**\n\n- \\( x_M \\ge 0 \\): number of motorcycle trips  \n- \\( x_S \\ge 0 \\): number of small truck trips  \n- \\( x_L \\ge 0 \\): number of large truck trips  \n\nTo model the choice of transportation methods (only 2 out of 3), introduce binary variables:\n\n- \\( y_M \\in \\{0,1\\} \\): 1 if motorcycles are used, 0 otherwise  \n- \\( y_S \\in \\{0,1\\} \\): 1 if small trucks are used, 0 otherwise  \n- \\( y_L \\in \\{0,1\\} \\): 1 if large trucks are used, 0 otherwise  \n\n**Objective**\n\nMinimize total pollution:\n\\[\n\\min Z = 40 x_M + 70 x_S + 100 x_L\n\\]\n\n**Constraints**\n\n1. Use exactly two transportation methods:\n\\[\ny_M + y_S + y_L = 2\n\\]\n\n2. Link trip variables to method selection (big-M constraints). Let \\(M = 20\\) (max total trips):\n\\[\nx_M \\le 20\\, y_M\n\\]\n\\[\nx_S \\le 20\\, y_S\n\\]\n\\[\nx_L \\le 20\\, y_L\n\\]\n\n3. Motorcycle trip limit:\n\\[\nx_M \\le 8\n\\]\n\n4. Demand satisfaction (at least 300 units transported):\n\\[\n10 x_M + 20 x_S + 50 x_L \\ge 300\n\\]\n\n5. Total number of trips limit:\n\\[\nx_M + x_S + x_L \\le 20\n\\]\n\n6. Variable domains:\n\\[\nx_M, x_S, x_L \\ge 0,\\quad y_M, y_S, y_L \\in \\{0,1\\}\n\\]\n\n---\n\n## 2. Complete Gurobi Python Code\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# -----------------------------\n# Data setup\n# -----------------------------\npollution = {\n    \"M\": 40,   # Motorcycle\n    \"S\": 70,   # Small truck\n    \"L\": 100   # Large truck\n}\n\ncapacity = {\n    \"M\": 10,\n    \"S\": 20,\n    \"L\": 50\n}\n\nmax_motorcycle_trips = 8\nmin_demand = 300\nmax_total_trips = 20\n\nmethods = [\"M\", \"S\", \"L\"]\n\n# Big-M for linking x and y (max possible trips per method)\nM_big = max_total_trips\n\n# -----------------------------\n# Create model\n# -----------------------------\nmodel = gp.Model(\"Transport_Min_Pollution\")\n\n# -----------------------------\n# Decision variables\n# -----------------------------\n# Number of trips (continuous, nonnegative)\nx = model.addVars(methods, name=\"x\", lb=0.0, vtype=GRB.CONTINUOUS)\n\n# Method selection (binary)\ny = model.addVars(methods, name=\"y\", vtype=GRB.BINARY)\n\n# -----------------------------\n# Objective: Minimize total pollution\n# -----------------------------\nmodel.setObjective(\n    gp.quicksum(pollution[m] * x[m] for m in methods),\n    GRB.MINIMIZE\n)\n\n# -----------------------------\n# Constraints\n# -----------------------------\n\n# 1) Exactly two transportation methods must be chosen\nmodel.addConstr(gp.quicksum(y[m] for m in methods) == 2, name=\"choose_two_methods\")\n\n# 2) Link trips to method selection (x[m] <= M_big * y[m])\nfor m in methods:\n    model.addConstr(x[m] <= M_big * y[m], name=f\"link_{m}\")\n\n# 3) Motorcycle trip limit\nmodel.addConstr(x[\"M\"] <= max_motorcycle_trips, name=\"motorcycle_limit\")\n\n# 4) Demand satisfaction\nmodel.addConstr(\n    gp.quicksum(capacity[m] * x[m] for m in methods) >= min_demand,\n    name=\"demand\"\n)\n\n# 5) Total number of trips limit\nmodel.addConstr(\n    gp.quicksum(x[m] for m in methods) <= max_total_trips,\n    name=\"total_trips_limit\"\n)\n\n# -----------------------------\n# Optimize\n# -----------------------------\nmodel.optimize()\n\n# -----------------------------\n# Results\n# -----------------------------\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\n    print(\"Optimal trips:\")\n    for m in methods:\n        print(f\"  {m}: {x[m].X:.4f} trips, selected: {int(y[m].X)}\")\nelse:\n    print(\"No optimal solution found\")\n```", "extracted_code": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# -----------------------------\n# Data setup\n# -----------------------------\npollution = {\n    \"M\": 40,   # Motorcycle\n    \"S\": 70,   # Small truck\n    \"L\": 100   # Large truck\n}\n\ncapacity = {\n    \"M\": 10,\n    \"S\": 20,\n    \"L\": 50\n}\n\nmax_motorcycle_trips = 8\nmin_demand = 300\nmax_total_trips = 20\n\nmethods = [\"M\", \"S\", \"L\"]\n\n# Big-M for linking x and y (max possible trips per method)\nM_big = max_total_trips\n\n# -----------------------------\n# Create model\n# -----------------------------\nmodel = gp.Model(\"Transport_Min_Pollution\")\n\n# -----------------------------\n# Decision variables\n# -----------------------------\n# Number of trips (continuous, nonnegative)\nx = model.addVars(methods, name=\"x\", lb=0.0, vtype=GRB.CONTINUOUS)\n\n# Method selection (binary)\ny = model.addVars(methods, name=\"y\", vtype=GRB.BINARY)\n\n# -----------------------------\n# Objective: Minimize total pollution\n# -----------------------------\nmodel.setObjective(\n    gp.quicksum(pollution[m] * x[m] for m in methods),\n    GRB.MINIMIZE\n)\n\n# -----------------------------\n# Constraints\n# -----------------------------\n\n# 1) Exactly two transportation methods must be chosen\nmodel.addConstr(gp.quicksum(y[m] for m in methods) == 2, name=\"choose_two_methods\")\n\n# 2) Link trips to method selection (x[m] <= M_big * y[m])\nfor m in methods:\n    model.addConstr(x[m] <= M_big * y[m], name=f\"link_{m}\")\n\n# 3) Motorcycle trip limit\nmodel.addConstr(x[\"M\"] <= max_motorcycle_trips, name=\"motorcycle_limit\")\n\n# 4) Demand satisfaction\nmodel.addConstr(\n    gp.quicksum(capacity[m] * x[m] for m in methods) >= min_demand,\n    name=\"demand\"\n)\n\n# 5) Total number of trips limit\nmodel.addConstr(\n    gp.quicksum(x[m] for m in methods) <= max_total_trips,\n    name=\"total_trips_limit\"\n)\n\n# -----------------------------\n# Optimize\n# -----------------------------\nmodel.optimize()\n\n# -----------------------------\n# Results\n# -----------------------------\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\n    print(\"Optimal trips:\")\n    for m in methods:\n        print(f\"  {m}: {x[m].X:.4f} trips, selected: {int(y[m].X)}\")\nelse:\n    print(\"No optimal solution found\")", "execution_success": true, "mathematical_accuracy": true, "execution_result": "Execution Successful", "execution_best_solution": 600.0, "execution_state": "Execution Successful"}
{"task_id": "B051", "description": "For a certain 24-hour bus service, the number of drivers and crew members required during different time periods each day is shown in Table 1-2:\nTable 1-2\n\\begin{tabular}{|c|c|c||c|c|c|}\n\\hline Shift & Time & Required number & Shift & Time & Required number \\\\\n\\hline 1 & $6: 00 \\sim 10: 00$ & 60 & 4 & $18 ; 00 \\sim 22 ; 00$ & 50 \\\\\n\\hline 2 & $10 ; 00 \\sim 14 ; 00$ & 70 & 5 & $22 ; 00 \\sim 2 ; 00$ & 20 \\\\\n\\hline 3 & $14 ; 00 \\sim 18 ; 00$ & 60 & 6 & $2: 00 \\sim 6 ; 00$ & 30 \\\\\n\\hline\n\\end{tabular}\n\nAssuming that drivers and crew members start their shifts at the beginning of each time period and work continuously for 8 hours, determine the minimum number of drivers and crew members needed for this bus route. Formulate the linear programming model for this problem.", "ground_truth": 150.0, "formulation": null, "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_bus_staffing():\n    \"\"\"\n    Solves the bus service staffing problem to minimize the total number of\n    drivers and crew members needed.\n    \"\"\"\n    try:\n        # Create a new model\n        model = gp.Model(\"BusStaffingOptimization\")\n\n        # --- Data ---\n        # Demands for each 4-hour period, re-ordered chronologically\n        # Period 0: 2:00-6:00 (Original Shift 6)\n        # Period 1: 6:00-10:00 (Original Shift 1)\n        # Period 2: 10:00-14:00 (Original Shift 2)\n        # Period 3: 14:00-18:00 (Original Shift 3)\n        # Period 4: 18:00-22:00 (Original Shift 4)\n        # Period 5: 22:00-2:00 (Original Shift 5)\n        demands = {\n            0: 30,  # 2:00 - 6:00\n            1: 60,  # 6:00 - 10:00\n            2: 70,  # 10:00 - 14:00\n            3: 60,  # 14:00 - 18:00\n            4: 50,  # 18:00 - 22:00\n            5: 20  # 22:00 - 2:00 (next day)\n        }\n        num_periods = len(demands)  # Should be 6\n\n        # Shift start times descriptions for output\n        shift_start_times_desc = [\n            \"2:00\", \"6:00\", \"10:00\", \"14:00\", \"18:00\", \"22:00\"\n        ]\n        period_desc = [\n            \"2:00-6:00\", \"6:00-10:00\", \"10:00-14:00\", \"14:00-18:00\",\n            \"18:00-22:00\", \"22:00-2:00\"\n        ]\n\n        # --- Decision Variables ---\n        # x[t]: number of staff starting their 8-hour shift at the beginning of period t\n        x = model.addVars(num_periods, vtype=GRB.INTEGER, name=\"x\", lb=0)\n\n        # --- Objective Function ---\n        # Minimize the total number of staff members hired\n        model.setObjective(gp.quicksum(x[t] for t in range(num_periods)),\n                           GRB.MINIMIZE)\n\n        # --- Constraints ---\n        # Demand coverage for each period.\n        # Each staff member works for 8 hours, covering two 4-hour periods.\n\n        # Period 0 (2:00-6:00): Covered by staff starting at 22:00 (x[5]) and 2:00 (x[0])\n        model.addConstr(x[5] + x[0] >= demands[0], \"Demand_P0\")\n\n        # Period 1 (6:00-10:00): Covered by staff starting at 2:00 (x[0]) and 6:00 (x[1])\n        model.addConstr(x[0] + x[1] >= demands[1], \"Demand_P1\")\n\n        # Period 2 (10:00-14:00): Covered by staff starting at 6:00 (x[1]) and 10:00 (x[2])\n        model.addConstr(x[1] + x[2] >= demands[2], \"Demand_P2\")\n\n        # Period 3 (14:00-18:00): Covered by staff starting at 10:00 (x[2]) and 14:00 (x[3])\n        model.addConstr(x[2] + x[3] >= demands[3], \"Demand_P3\")\n\n        # Period 4 (18:00-22:00): Covered by staff starting at 14:00 (x[3]) and 18:00 (x[4])\n        model.addConstr(x[3] + x[4] >= demands[4], \"Demand_P4\")\n\n        # Period 5 (22:00-2:00): Covered by staff starting at 18:00 (x[4]) and 22:00 (x[5])\n        model.addConstr(x[4] + x[5] >= demands[5], \"Demand_P5\")\n\n        # Suppress Gurobi output to console\n        model.setParam('OutputFlag', 0)\n\n        # Optimize the model\n        model.optimize()\n\n        # --- Results ---\n        if model.status == GRB.OPTIMAL:\n            print(\"Optimal staffing plan found.\")\n            print(\n                f\"Minimum total staff (drivers and crew) needed: {model.objVal:.0f}\"\n            )\n\n            print(\"\\nNumber of Staff Starting at Each Shift:\")\n            print(f\"{'Start Time':<12} | {'Number of Staff':<15}\")\n            print(\"-\" * 30)\n            for t in range(num_periods):\n                print(f\"{shift_start_times_desc[t]:<12} | {x[t].X:<15.0f}\")\n\n            print(\"\\nVerification of Coverage per Period:\")\n            coverage = [0] * num_periods\n            coverage[0] = x[5].X + x[0].X\n            coverage[1] = x[0].X + x[1].X\n            coverage[2] = x[1].X + x[2].X\n            coverage[3] = x[2].X + x[3].X\n            coverage[4] = x[3].X + x[4].X\n            coverage[5] = x[4].X + x[5].X\n\n            for p_idx in range(num_periods):\n                print(\n                    f\"  Period {period_desc[p_idx]} (Demand: {demands[p_idx]}): Covered by {coverage[p_idx]:.0f} staff\"\n                )\n\n        else:\n            print(\"No optimal solution found. Status code:\", model.status)\n\n    except gp.GurobiError as e:\n        print(f\"Error code {e.errno}: {e}\")\n    except AttributeError:\n        print(\n            \"Encountered an attribute error, Gurobi might not be installed or licensed correctly.\"\n        )\n\n\nif __name__ == '__main__':\n    solve_bus_staffing()", "output_status": [], "success_count": 0, "success_confidence": 0, "fail_to_diagnose": 0, "fail_to_verify": 0, "retrieved_insights": [], "tag": [{"problem_domain": "Staffing", "modeling_type": "IP", "industry_sector": "Transportation", "reason": "The problem aims to determine the minimum number of drivers and crew members required for a bus service, which is a classic staffing problem. The solver uses integer variables and linear constraints to minimize the total staff, fitting the Integer Programming (IP) modeling type. The application context is a bus service, placing it in the transportation sector."}], "cluster": null, "prompt": "Below is an operations research question. First formulate the problem as an optimization problem. Then according to the formulated problem, write python code that uses 'gurobipy' to solve the optimization problem. You should write a complete python code that can be executed to solve the optimization problem.\n\nIMPORTANT: Your code should follow these requirements:\n1. Create a Gurobi model variable named 'model' (not 'm' or other names)\n2. Include all necessary imports and data setup\n3. Write the complete optimization code that can run independently\n4. Do NOT wrap everything in a function - write the code directly\n5. Make sure the model is created and optimized in the main execution flow\n6. The code should print the optimal objective value when solved successfully\n\nExample format:\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Data setup\ndata = {...}\n\n# Create model\nmodel = gp.Model(\"ProblemName\")\n\n# Decision variables\nx = model.addVars(...)\n\n# Objective\nmodel.setObjective(...)\n\n# Constraints\nmodel.addConstr(...)\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\nelse:\n    print(\"No optimal solution found\")\n```\n\n# Question:\nFor a certain 24-hour bus service, the number of drivers and crew members required during different time periods each day is shown in Table 1-2:\nTable 1-2\n\\begin{tabular}{|c|c|c||c|c|c|}\n\\hline Shift & Time & Required number & Shift & Time & Required number \\\\\n\\hline 1 & $6: 00 \\sim 10: 00$ & 60 & 4 & $18 ; 00 \\sim 22 ; 00$ & 50 \\\\\n\\hline 2 & $10 ; 00 \\sim 14 ; 00$ & 70 & 5 & $22 ; 00 \\sim 2 ; 00$ & 20 \\\\\n\\hline 3 & $14 ; 00 \\sim 18 ; 00$ & 60 & 6 & $2: 00 \\sim 6 ; 00$ & 30 \\\\\n\\hline\n\\end{tabular}\n\nAssuming that drivers and crew members start their shifts at the beginning of each time period and work continuously for 8 hours, determine the minimum number of drivers and crew members needed for this bus route. Formulate the linear programming model for this problem.\n\n# Response:", "generated_output": "Below is the formulation and then a complete Gurobi Python code.\n\n---\n\n## 1. Optimization model formulation\n\n**Decision variables**\n\nLet  \n- \\(x_i\\) = number of drivers/crew who start work at the beginning of shift \\(i\\), for \\(i = 1,\\dots,6\\).\n\nShifts (each is 4 hours, workers work 8 hours = 2 consecutive shifts):\n\n1. Shift 1: 06:00–10:00, requirement = 60  \n2. Shift 2: 10:00–14:00, requirement = 70  \n3. Shift 3: 14:00–18:00, requirement = 60  \n4. Shift 4: 18:00–22:00, requirement = 50  \n5. Shift 5: 22:00–02:00, requirement = 20  \n6. Shift 6: 02:00–06:00, requirement = 30  \n\nEach worker works 8 hours, i.e., covers the shift they start in and the next shift (modulo 6 over 24 hours).\n\n**Coverage relationships**\n\n- Workers starting in shift 1 cover shifts 1 and 2  \n- Workers starting in shift 2 cover shifts 2 and 3  \n- Workers starting in shift 3 cover shifts 3 and 4  \n- Workers starting in shift 4 cover shifts 4 and 5  \n- Workers starting in shift 5 cover shifts 5 and 6  \n- Workers starting in shift 6 cover shifts 6 and 1  \n\n**Objective**\n\nMinimize the total number of workers:\n\n\\[\n\\min \\; Z = x_1 + x_2 + x_3 + x_4 + x_5 + x_6\n\\]\n\n**Constraints (coverage)**\n\nFor each shift, the sum of workers who cover that shift must be at least the requirement:\n\n- Shift 1 (covered by \\(x_1\\) and \\(x_6\\)):\n  \\[\n  x_1 + x_6 \\ge 60\n  \\]\n- Shift 2 (covered by \\(x_1\\) and \\(x_2\\)):\n  \\[\n  x_1 + x_2 \\ge 70\n  \\]\n- Shift 3 (covered by \\(x_2\\) and \\(x_3\\)):\n  \\[\n  x_2 + x_3 \\ge 60\n  \\]\n- Shift 4 (covered by \\(x_3\\) and \\(x_4\\)):\n  \\[\n  x_3 + x_4 \\ge 50\n  \\]\n- Shift 5 (covered by \\(x_4\\) and \\(x_5\\)):\n  \\[\n  x_4 + x_5 \\ge 20\n  \\]\n- Shift 6 (covered by \\(x_5\\) and \\(x_6\\)):\n  \\[\n  x_5 + x_6 \\ge 30\n  \\]\n\n**Non-negativity and integrality**\n\n\\[\nx_i \\ge 0,\\quad x_i \\in \\mathbb{Z},\\quad i = 1,\\dots,6\n\\]\n\n---\n\n## 2. Complete Python code using Gurobi (`gurobipy`)\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Data setup\nshifts = [1, 2, 3, 4, 5, 6]\nrequirements = {\n    1: 60,  # 06:00-10:00\n    2: 70,  # 10:00-14:00\n    3: 60,  # 14:00-18:00\n    4: 50,  # 18:00-22:00\n    5: 20,  # 22:00-02:00\n    6: 30   # 02:00-06:00\n}\n\n# For each shift, determine which start-times (shifts) cover it.\n# Each worker works 2 consecutive shifts (8 hours).\n# Coverage pattern (mod 6):\n# start i covers shift i and shift i+1 (with wrap-around)\ncovers = {s: [] for s in shifts}\nfor i in shifts:\n    s1 = i\n    s2 = 1 if i == 6 else i + 1\n    covers[s1].append(i)\n    covers[s2].append(i)\n\n# Create model\nmodel = gp.Model(\"BusCrewScheduling\")\n\n# Decision variables: x[i] = number of workers starting at shift i\nx = model.addVars(shifts, vtype=GRB.INTEGER, name=\"x\")\n\n# Objective: minimize total number of workers\nmodel.setObjective(gp.quicksum(x[i] for i in shifts), GRB.MINIMIZE)\n\n# Constraints: coverage for each shift\nfor s in shifts:\n    model.addConstr(\n        gp.quicksum(x[i] for i in covers[s]) >= requirements[s],\n        name=f\"cover_shift_{s}\"\n    )\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\n    print(\"Optimal number of workers starting each shift:\")\n    for i in shifts:\n        print(f\"  Shift {i}: {x[i].X}\")\nelse:\n    print(\"No optimal solution found\")\n```", "extracted_code": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Data setup\nshifts = [1, 2, 3, 4, 5, 6]\nrequirements = {\n    1: 60,  # 06:00-10:00\n    2: 70,  # 10:00-14:00\n    3: 60,  # 14:00-18:00\n    4: 50,  # 18:00-22:00\n    5: 20,  # 22:00-02:00\n    6: 30   # 02:00-06:00\n}\n\n# For each shift, determine which start-times (shifts) cover it.\n# Each worker works 2 consecutive shifts (8 hours).\n# Coverage pattern (mod 6):\n# start i covers shift i and shift i+1 (with wrap-around)\ncovers = {s: [] for s in shifts}\nfor i in shifts:\n    s1 = i\n    s2 = 1 if i == 6 else i + 1\n    covers[s1].append(i)\n    covers[s2].append(i)\n\n# Create model\nmodel = gp.Model(\"BusCrewScheduling\")\n\n# Decision variables: x[i] = number of workers starting at shift i\nx = model.addVars(shifts, vtype=GRB.INTEGER, name=\"x\")\n\n# Objective: minimize total number of workers\nmodel.setObjective(gp.quicksum(x[i] for i in shifts), GRB.MINIMIZE)\n\n# Constraints: coverage for each shift\nfor s in shifts:\n    model.addConstr(\n        gp.quicksum(x[i] for i in covers[s]) >= requirements[s],\n        name=f\"cover_shift_{s}\"\n    )\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\n    print(\"Optimal number of workers starting each shift:\")\n    for i in shifts:\n        print(f\"  Shift {i}: {x[i].X}\")\nelse:\n    print(\"No optimal solution found\")", "execution_success": true, "mathematical_accuracy": true, "execution_result": "Execution Successful", "execution_best_solution": 150.0, "execution_state": "Execution Successful"}
{"task_id": "B098", "description": "An electronic system is composed of 3 types of components. The system operates normally if all three components function properly. By installing one or more spare parts for any of the components, the reliability of the components can be improved. The system's operational reliability is the product of the reliabilities of each component, and the reliability of each component is a function of the number of spare parts installed. The first half of the table below shows the function relationship between the number of spare parts and the reliability of a specific component. The prices and weights of the 3 types of components are shown in rows 8 to 9 of the table. Given that the total budget for all spare parts is limited to 150 yuan, and the weight limit is 20 kg, how should spare parts be installed to maximize the system's operational reliability? \n\n\\begin{table}[h]\n\\centering\n\\begin{tabular}{|c|c|c|c|}\n\\hline\n\\textbf{Component Number} & \\textbf{1} & \\textbf{2} & \\textbf{3} \\\\ \\hline\n\\textbf{Number of Spares} &             &             &             \\\\ \\hline\n0                & 0.5         & 0.6         & 0.7         \\\\ \\hline\n1                & 0.6         & 0.75        & 0.9         \\\\ \\hline\n2                & 0.7         & 0.95        & 1.0         \\\\ \\hline\n3                & 0.8         & 1.0         & 1.0         \\\\ \\hline\n4                & 0.9         & 1.0         & 1.0         \\\\ \\hline\n5                & 1.0         & 1.0         & 1.0         \\\\ \\hline\n\\textbf{Unit Price (yuan)}  & 20           & 30           & 40           \\\\ \\hline\n\\textbf{Unit Weight (kg)}  & 2            & 4            & 6            \\\\ \\hline\n\\end{tabular}\n\\caption{Spare Component Data Table}\n\\end{table}", "ground_truth": 0.6075, "formulation": null, "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\nimport math  # For math.exp in results if needed\n\n\ndef solve_system_reliability():\n    \"\"\"\n    Solves the system reliability optimization problem to determine the optimal\n    number of spare parts for each component to maximize overall system reliability,\n    subject to budget and weight constraints.\n    Uses a log-transformed objective for Gurobi.\n    \"\"\"\n    try:\n        # --- Data ---\n        num_components = 3\n        components = range(\n            num_components)  # Indices 0, 1, 2 for Components 1, 2, 3\n\n        max_spares_per_component = 5\n        num_spare_options = max_spares_per_component + 1\n        spare_counts_options = range(num_spare_options)\n\n        reliability_data = [\n            [0.5, 0.6, 0.7, 0.8, 0.9, 1.0],  # Component 1\n            [0.6, 0.75, 0.95, 1.0, 1.0, 1.0],  # Component 2\n            [0.7, 0.9, 1.0, 1.0, 1.0, 1.0]  # Component 3\n        ]\n\n        prices = [20, 30, 40]  # yuan\n        weights = [2, 4, 6]  # kg\n\n        max_budget = 150  # yuan\n        max_weight = 20  # kg\n\n        # --- Create Gurobi Model ---\n        model = gp.Model(\"SystemReliabilityOptimization\")\n\n        # --- Decision Variables ---\n        # x[c,s]: 1 if component c has s spares installed, 0 otherwise\n        x = model.addVars(components,\n                          spare_counts_options,\n                          vtype=GRB.BINARY,\n                          name=\"x_spares_selection\")\n\n        # Rel[c]: Achieved reliability of component c\n        # Ensure Rel[c] is strictly positive for log function. Smallest reliability is 0.5.\n        Rel = model.addVars(components,\n                            name=\"Rel_component\",\n                            lb=0.0001,\n                            ub=1.0,\n                            vtype=GRB.CONTINUOUS)\n\n        # log_Rel[c]: Natural logarithm of Rel[c]\n        # Gurobi's log is natural log. The bounds for log_Rel depend on Rel's bounds.\n        # log(0.0001) approx -9.21, log(1) = 0\n        log_Rel = model.addVars(components,\n                                name=\"log_Rel_component\",\n                                lb=-10,\n                                ub=0.0,\n                                vtype=GRB.CONTINUOUS)\n\n        # --- Objective Function: Maximize Sum of Log(Reliabilities) ---\n        # This is equivalent to maximizing the product of reliabilities.\n        # Gurobi needs NonConvex=2 for general constraints like log.\n        model.Params.NonConvex = 2\n        model.setObjective(gp.quicksum(log_Rel[c] for c in components),\n                           GRB.MAXIMIZE)\n\n        # --- Constraints ---\n        # 1. Unique Spare Count Selection: For each component c, exactly one x[c,s] is 1\n        for c in components:\n            model.addConstr(gp.quicksum(\n                x[c, s_option] for s_option in spare_counts_options) == 1,\n                            name=f\"UniqueSpares_Comp{c+1}\")\n\n        # 2. Component Reliability Definition: Rel[c] = sum(Reliability_data[c][s_option] * x[c,s_option])\n        for c in components:\n            model.addConstr(Rel[c] == gp.quicksum(\n                reliability_data[c][s_option] * x[c, s_option]\n                for s_option in spare_counts_options),\n                            name=f\"DefineRel_Comp{c+1}\")\n\n        # 3. Link Rel[c] and log_Rel[c]: log_Rel[c] = log(Rel[c])\n        for c in components:\n            model.addGenConstrLog(Rel[c],\n                                  log_Rel[c],\n                                  name=f\"LogConstraint_Comp{c+1}\")\n\n        # 4. Budget Constraint: sum_c sum_s (price[c] * s * x[c,s]) <= max_budget\n        total_cost = gp.quicksum(prices[c] * s_option * x[c, s_option]\n                                 for c in components\n                                 for s_option in spare_counts_options)\n        model.addConstr(total_cost <= max_budget, name=\"BudgetLimit\")\n\n        # 5. Weight Constraint: sum_c sum_s (weight[c] * s * x[c,s]) <= max_weight\n        total_weight = gp.quicksum(weights[c] * s_option * x[c, s_option]\n                                   for c in components\n                                   for s_option in spare_counts_options)\n        model.addConstr(total_weight <= max_weight, name=\"WeightLimit\")\n\n        # Suppress Gurobi output to console if desired\n        # model.setParam('OutputFlag', 0)\n        model.setParam('MIPGap', 0.001)\n\n        # Optimize the model\n        model.optimize()\n\n        # --- Results ---\n        if model.status == GRB.OPTIMAL:\n            print(\"Optimal spare parts installation plan found.\")\n            # Calculate the actual system reliability (product of individual reliabilities)\n            actual_system_reliability = 1.0\n            for c in components:\n                actual_system_reliability *= Rel[c].X\n\n            print(\n                f\"Maximum System Operational Reliability: {actual_system_reliability:.4f} (or {actual_system_reliability*100:.2f}%)\"\n            )\n            print(\n                f\"Objective Function Value (Sum of Log Reliabilities): {model.ObjVal:.4f}\"\n            )\n\n            print(\"\\nOptimal Number of Spare Parts for Each Component:\")\n            num_spares_chosen = {}\n            for c in components:\n                for s_option_val in spare_counts_options:\n                    if x[c, s_option_val].X > 0.5:\n                        num_spares_chosen[c] = s_option_val\n                        print(\n                            f\"  Component {c+1}: Install {s_option_val} spare part(s)\"\n                        )\n                        break\n\n            print(\"\\nAchieved Component Reliabilities:\")\n            for c in components:\n                print(\n                    f\"  Component {c+1}: {Rel[c].X:.4f} (Reliability with {num_spares_chosen[c]} spares, log(Rel): {log_Rel[c].X:.4f})\"\n                )\n\n            print(\"\\nResource Usage:\")\n            final_cost = sum(prices[c] * num_spares_chosen[c]\n                             for c in components)\n            final_weight = sum(weights[c] * num_spares_chosen[c]\n                               for c in components)\n            print(\n                f\"  Total Cost: {final_cost:.2f} Yuan (Budget: <= {max_budget})\"\n            )\n            print(\n                f\"  Total Weight: {final_weight:.2f} kg (Limit: <= {max_weight})\"\n            )\n\n        elif model.status == GRB.INFEASIBLE:\n            print(\n                \"Model is infeasible. The requirements cannot be met under the given budget and weight constraints.\"\n            )\n            model.computeIIS()\n            model.write(\"system_reliability_iis.ilp\")\n            print(\"IIS written to system_reliability_iis.ilp for debugging.\")\n        elif model.status == GRB.INF_OR_UNBD:\n            print(\"Model is infeasible or unbounded.\")\n        else:\n            print(f\"Optimization stopped with status: {model.status}\")\n            if model.SolCount == 0:\n                print(\"No feasible solution found.\")\n\n    except gp.GurobiError as e:\n        print(f\"Gurobi error code {e.errno}: {e}\")\n        print(f\"Error message: {e.message}\")\n    except Exception as e:\n        print(f\"An unexpected error occurred: {e}\")\n\n\nif __name__ == '__main__':\n    solve_system_reliability()", "output_status": [], "success_count": 0, "success_confidence": 0, "fail_to_diagnose": 0, "fail_to_verify": 0, "retrieved_insights": [], "tag": [{"problem_domain": "Resource Allocation", "modeling_type": "MILP", "industry_sector": "Manufacturing", "reason": "The problem involves allocating limited resources (budget and weight) to maximize system reliability by selecting the number of spare parts for each component. The solver uses a Mixed-Integer Linear Programming (MILP) approach by transforming the multiplicative objective into a sum of logarithms and using binary variables for selection, which is a common technique in reliability optimization. The application is directly related to the design and maintenance of electronic systems, which falls under manufacturing."}], "cluster": null, "prompt": "Below is an operations research question. First formulate the problem as an optimization problem. Then according to the formulated problem, write python code that uses 'gurobipy' to solve the optimization problem. You should write a complete python code that can be executed to solve the optimization problem.\n\nIMPORTANT: Your code should follow these requirements:\n1. Create a Gurobi model variable named 'model' (not 'm' or other names)\n2. Include all necessary imports and data setup\n3. Write the complete optimization code that can run independently\n4. Do NOT wrap everything in a function - write the code directly\n5. Make sure the model is created and optimized in the main execution flow\n6. The code should print the optimal objective value when solved successfully\n\nExample format:\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Data setup\ndata = {...}\n\n# Create model\nmodel = gp.Model(\"ProblemName\")\n\n# Decision variables\nx = model.addVars(...)\n\n# Objective\nmodel.setObjective(...)\n\n# Constraints\nmodel.addConstr(...)\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\nelse:\n    print(\"No optimal solution found\")\n```\n\n# Question:\nAn electronic system is composed of 3 types of components. The system operates normally if all three components function properly. By installing one or more spare parts for any of the components, the reliability of the components can be improved. The system's operational reliability is the product of the reliabilities of each component, and the reliability of each component is a function of the number of spare parts installed. The first half of the table below shows the function relationship between the number of spare parts and the reliability of a specific component. The prices and weights of the 3 types of components are shown in rows 8 to 9 of the table. Given that the total budget for all spare parts is limited to 150 yuan, and the weight limit is 20 kg, how should spare parts be installed to maximize the system's operational reliability? \n\n\\begin{table}[h]\n\\centering\n\\begin{tabular}{|c|c|c|c|}\n\\hline\n\\textbf{Component Number} & \\textbf{1} & \\textbf{2} & \\textbf{3} \\\\ \\hline\n\\textbf{Number of Spares} &             &             &             \\\\ \\hline\n0                & 0.5         & 0.6         & 0.7         \\\\ \\hline\n1                & 0.6         & 0.75        & 0.9         \\\\ \\hline\n2                & 0.7         & 0.95        & 1.0         \\\\ \\hline\n3                & 0.8         & 1.0         & 1.0         \\\\ \\hline\n4                & 0.9         & 1.0         & 1.0         \\\\ \\hline\n5                & 1.0         & 1.0         & 1.0         \\\\ \\hline\n\\textbf{Unit Price (yuan)}  & 20           & 30           & 40           \\\\ \\hline\n\\textbf{Unit Weight (kg)}  & 2            & 4            & 6            \\\\ \\hline\n\\end{tabular}\n\\caption{Spare Component Data Table}\n\\end{table}\n\n# Response:", "generated_output": "Below is one way to formulate and solve the problem.\n\n---\n\n## 1. Optimization model formulation\n\n**Indices**\n\n- Components: \\( i \\in \\{1,2,3\\} \\)\n- Possible number of spares for each component: \\( k \\in \\{0,1,2,3,4,5\\} \\)\n\n**Parameters**\n\n- \\( r_{i,k} \\): reliability of component \\( i \\) when \\( k \\) spares are installed  \n  (given in the table)\n- \\( c_i \\): unit price of one spare of component \\( i \\)\n- \\( w_i \\): unit weight of one spare of component \\( i \\)\n- Budget limit: \\( B = 150 \\)\n- Weight limit: \\( W = 20 \\)\n\n**Decision variables**\n\n- \\( x_{i,k} \\in \\{0,1\\} \\):  \n  \\( x_{i,k} = 1 \\) if component \\( i \\) is assigned exactly \\( k \\) spares, 0 otherwise.\n- \\( z \\ge 0 \\): system reliability (auxiliary continuous variable)\n\n**Constraints**\n\n1. Exactly one spare-level choice per component:\n\\[\n\\sum_{k=0}^{5} x_{i,k} = 1, \\quad \\forall i = 1,2,3\n\\]\n\n2. Budget constraint (each spare of type \\( i \\) costs \\( c_i \\), and if we choose level \\( k \\), we buy \\( k \\) spares):\n\\[\n\\sum_{i=1}^{3} \\sum_{k=0}^{5} c_i \\cdot k \\cdot x_{i,k} \\le B\n\\]\n\n3. Weight constraint:\n\\[\n\\sum_{i=1}^{3} \\sum_{k=0}^{5} w_i \\cdot k \\cdot x_{i,k} \\le W\n\\]\n\n4. Linearization of the product for system reliability.  \n   Let the system reliability be:\n   \\[\n   R = \\prod_{i=1}^{3} \\left( \\sum_{k=0}^{5} r_{i,k} x_{i,k} \\right)\n   \\]\n   Introduce \\( z \\) and enforce:\n   \\[\n   z \\le \\sum_{k=0}^{5} r_{i,k} x_{i,k}, \\quad \\forall i = 1,2,3\n   \\]\n   Since each term in the product is in \\([0,1]\\), maximizing \\( z \\) subject to\n   \\( z \\le \\) each component reliability will push \\( z \\) up to the minimum of the three component reliabilities.  \n   This gives a conservative approximation:\n   \\[\n   z \\le \\min_i \\left( \\sum_{k} r_{i,k} x_{i,k} \\right) \\le \\prod_i \\left( \\sum_{k} r_{i,k} x_{i,k} \\right)\n   \\]\n   So we maximize a lower bound on the true product. (Gurobi cannot directly maximize a nonconvex product without using nonconvex features; this is a standard linear approximation.)\n\n**Objective**\n\n\\[\n\\max z\n\\]\n\n---\n\n## 2. Python code with Gurobi (`gurobipy`)\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# =========================\n# Data setup\n# =========================\n\ncomponents = [1, 2, 3]\nspares = [0, 1, 2, 3, 4, 5]\n\n# Reliability r[i][k] for component i with k spares\nr = {\n    1: {0: 0.5, 1: 0.6, 2: 0.7, 3: 0.8, 4: 0.9, 5: 1.0},\n    2: {0: 0.6, 1: 0.75, 2: 0.95, 3: 1.0, 4: 1.0, 5: 1.0},\n    3: {0: 0.7, 1: 0.9, 2: 1.0, 3: 1.0, 4: 1.0, 5: 1.0},\n}\n\n# Unit price and weight per spare of each component\nprice = {1: 20, 2: 30, 3: 40}\nweight = {1: 2, 2: 4, 3: 6}\n\n# Limits\nB = 150  # budget\nW = 20   # weight\n\n# =========================\n# Create model\n# =========================\n\nmodel = gp.Model(\"SparePartsReliability\")\n\n# =========================\n# Decision variables\n# =========================\n\n# x[i,k] = 1 if component i uses k spares, 0 otherwise\nx = model.addVars(\n    components,\n    spares,\n    vtype=GRB.BINARY,\n    name=\"x\"\n)\n\n# z = lower bound on system reliability (min of component reliabilities)\nz = model.addVar(vtype=GRB.CONTINUOUS, lb=0.0, ub=1.0, name=\"z\")\n\n# =========================\n# Constraints\n# =========================\n\n# Exactly one spare-level choice per component\nfor i in components:\n    model.addConstr(gp.quicksum(x[i, k] for k in spares) == 1, name=f\"one_level_comp_{i}\")\n\n# Budget constraint\nmodel.addConstr(\n    gp.quicksum(price[i] * k * x[i, k] for i in components for k in spares) <= B,\n    name=\"budget\"\n)\n\n# Weight constraint\nmodel.addConstr(\n    gp.quicksum(weight[i] * k * x[i, k] for i in components for k in spares) <= W,\n    name=\"weight\"\n)\n\n# Reliability lower-bound constraints: z <= reliability of each component\nfor i in components:\n    model.addConstr(\n        z <= gp.quicksum(r[i][k] * x[i, k] for k in spares),\n        name=f\"reliability_lb_comp_{i}\"\n    )\n\n# =========================\n# Objective\n# =========================\n\n# Maximize z (a lower bound on the system reliability)\nmodel.setObjective(z, sense=GRB.MAXIMIZE)\n\n# =========================\n# Optimize\n# =========================\n\nmodel.optimize()\n\n# =========================\n# Results\n# =========================\n\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal objective (lower bound on system reliability): {model.objVal:.6f}\")\n    print(\"Chosen number of spares per component:\")\n    for i in components:\n        for k in spares:\n            if x[i, k].X > 0.5:\n                print(f\"  Component {i}: {k} spares, reliability {r[i][k]}\")\nelse:\n    print(\"No optimal solution found\")\n```", "extracted_code": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# =========================\n# Data setup\n# =========================\n\ncomponents = [1, 2, 3]\nspares = [0, 1, 2, 3, 4, 5]\n\n# Reliability r[i][k] for component i with k spares\nr = {\n    1: {0: 0.5, 1: 0.6, 2: 0.7, 3: 0.8, 4: 0.9, 5: 1.0},\n    2: {0: 0.6, 1: 0.75, 2: 0.95, 3: 1.0, 4: 1.0, 5: 1.0},\n    3: {0: 0.7, 1: 0.9, 2: 1.0, 3: 1.0, 4: 1.0, 5: 1.0},\n}\n\n# Unit price and weight per spare of each component\nprice = {1: 20, 2: 30, 3: 40}\nweight = {1: 2, 2: 4, 3: 6}\n\n# Limits\nB = 150  # budget\nW = 20   # weight\n\n# =========================\n# Create model\n# =========================\n\nmodel = gp.Model(\"SparePartsReliability\")\n\n# =========================\n# Decision variables\n# =========================\n\n# x[i,k] = 1 if component i uses k spares, 0 otherwise\nx = model.addVars(\n    components,\n    spares,\n    vtype=GRB.BINARY,\n    name=\"x\"\n)\n\n# z = lower bound on system reliability (min of component reliabilities)\nz = model.addVar(vtype=GRB.CONTINUOUS, lb=0.0, ub=1.0, name=\"z\")\n\n# =========================\n# Constraints\n# =========================\n\n# Exactly one spare-level choice per component\nfor i in components:\n    model.addConstr(gp.quicksum(x[i, k] for k in spares) == 1, name=f\"one_level_comp_{i}\")\n\n# Budget constraint\nmodel.addConstr(\n    gp.quicksum(price[i] * k * x[i, k] for i in components for k in spares) <= B,\n    name=\"budget\"\n)\n\n# Weight constraint\nmodel.addConstr(\n    gp.quicksum(weight[i] * k * x[i, k] for i in components for k in spares) <= W,\n    name=\"weight\"\n)\n\n# Reliability lower-bound constraints: z <= reliability of each component\nfor i in components:\n    model.addConstr(\n        z <= gp.quicksum(r[i][k] * x[i, k] for k in spares),\n        name=f\"reliability_lb_comp_{i}\"\n    )\n\n# =========================\n# Objective\n# =========================\n\n# Maximize z (a lower bound on the system reliability)\nmodel.setObjective(z, sense=GRB.MAXIMIZE)\n\n# =========================\n# Optimize\n# =========================\n\nmodel.optimize()\n\n# =========================\n# Results\n# =========================\n\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal objective (lower bound on system reliability): {model.objVal:.6f}\")\n    print(\"Chosen number of spares per component:\")\n    for i in components:\n        for k in spares:\n            if x[i, k].X > 0.5:\n                print(f\"  Component {i}: {k} spares, reliability {r[i][k]}\")\nelse:\n    print(\"No optimal solution found\")", "execution_success": true, "mathematical_accuracy": false, "execution_result": "Execution Successful", "execution_best_solution": 0.75, "execution_state": "Execution Successful"}
{"task_id": "B027", "description": "Someone has a fund of 300,000 yuan and has the following investment projects in the next three years:\n(1) Investment can be made at the beginning of each year within three years, with an annual profit of 20% of the investment amount, and the principal and interest can be used for investment in the following year;\n(2) Investment is only allowed at the beginning of the first year, and it can be recovered at the end of the second year, with the total principal and interest amounting to 150% of the investment amount, but the investment limit is no more than 150,000 yuan;\n(3) Investment is allowed at the beginning of the second year within three years, and it can be recovered at the end of the third year, with the total principal and interest amounting to 160% of the investment amount, and the investment limit is 200,000 yuan;\n(4) Investment is allowed at the beginning of the third year within three years, and it can be recovered in one year with a profit of 40%, and the investment limit is 100,000 yuan.\nChapter One: Linear Programming and Simplex Method\nTry to determine an investment plan for this person that maximizes the principal and interest at the end of the third year.", "ground_truth": 580000.0, "formulation": null, "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_investment_problem():\n    \"\"\"\n    Solves the multi-period investment problem using Gurobi to maximize\n    the total principal and interest at the end of the third year.\n    \"\"\"\n    try:\n        # Initial capital\n        K0 = 300000.0\n\n        # Create a new model\n        model = gp.Model(\"MultiPeriodInvestment\")\n\n        # --- Decision Variables ---\n        # x_ij: amount invested in project i at the start of year j\n        # Project 1: Annual, 20% profit (return 1.2)\n        x11 = model.addVar(name=\"x11_P1_Y1\", lb=0.0,\n                           vtype=GRB.CONTINUOUS)  # P1, Start of Year 1\n        x12 = model.addVar(name=\"x12_P1_Y2\", lb=0.0,\n                           vtype=GRB.CONTINUOUS)  # P1, Start of Year 2\n        x13 = model.addVar(name=\"x13_P1_Y3\", lb=0.0,\n                           vtype=GRB.CONTINUOUS)  # P1, Start of Year 3\n\n        # Project 2: Start Y1, 2-year, 150% total return (factor 1.5), limit 150k\n        x21 = model.addVar(name=\"x21_P2_Y1\", lb=0.0, vtype=GRB.CONTINUOUS)\n\n        # Project 3: Start Y2, 2-year, 160% total return (factor 1.6), limit 200k\n        x32 = model.addVar(name=\"x32_P3_Y2\", lb=0.0, vtype=GRB.CONTINUOUS)\n\n        # Project 4: Start Y3, 1-year, 40% profit (return 1.4), limit 100k\n        x43 = model.addVar(name=\"x43_P4_Y3\", lb=0.0, vtype=GRB.CONTINUOUS)\n\n        # --- Objective Function ---\n        # Maximize total principal and interest at the end of Year 3.\n        # Z = K0 + 0.2*x11 + 0.5*x21 + 0.2*x12 + 0.6*x32 + 0.2*x13 + 0.4*x43\n        objective = K0 + 0.2 * x11 + 0.5 * x21 + 0.2 * x12 + 0.6 * x32 + 0.2 * x13 + 0.4 * x43\n        model.setObjective(objective, GRB.MAXIMIZE)\n\n        # --- Constraints ---\n        # 1. Cash Availability at Start of Year 1\n        model.addConstr(x11 + x21 <= K0, \"Cash_SOY1\")\n\n        # 2. Cash Availability at Start of Year 2\n        # Investments_SOY2 <= K0 + 0.2*x11 - x21\n        # x12 + x32 - 0.2*x11 + x21 <= K0\n        model.addConstr(x12 + x32 - 0.2 * x11 + x21 <= K0, \"Cash_SOY2\")\n\n        # 3. Cash Availability at Start of Year 3\n        # Investments_SOY3 <= K0 + 0.2*x11 + 0.5*x21 + 0.2*x12 - x32\n        # x13 + x43 - 0.2*x11 - 0.5*x21 - 0.2*x12 + x32 <= K0\n        model.addConstr(\n            x13 + x43 - 0.2 * x11 - 0.5 * x21 - 0.2 * x12 + x32 <= K0,\n            \"Cash_SOY3\")\n\n        # 4. Investment Limit for Project 2\n        model.addConstr(x21 <= 150000, \"Limit_P2\")\n\n        # 5. Investment Limit for Project 3\n        model.addConstr(x32 <= 200000, \"Limit_P3\")\n\n        # 6. Investment Limit for Project 4\n        model.addConstr(x43 <= 100000, \"Limit_P4\")\n\n        # Suppress Gurobi output to console\n        # model.setParam('OutputFlag', 0)\n\n        # Optimize the model\n        model.optimize()\n\n        # --- Results ---\n        if model.status == GRB.OPTIMAL:\n            print(\"Optimal investment plan found.\")\n            print(\n                f\"Maximum Principal and Interest at End of Year 3: {model.objVal:.2f} yuan\"\n            )\n\n            total_profit = model.objVal - K0\n            print(f\"Total Profit over 3 years: {total_profit:.2f} yuan\")\n\n            print(\"\\nInvestment Plan Details (yuan):\")\n            print(\"  Start of Year 1:\")\n            print(f\"    Project 1 (Annual, 20% profit): {x11.X:.2f}\")\n            print(\n                f\"    Project 2 (2-year, 150% return, limit 150k): {x21.X:.2f}\"\n            )\n            cash_soy1_invested = x11.X + x21.X\n            cash_soy1_uninvested = K0 - cash_soy1_invested\n            print(f\"    Total invested at SOY1: {cash_soy1_invested:.2f}\")\n            print(f\"    Uninvested cash from SOY1: {cash_soy1_uninvested:.2f}\")\n\n            cash_available_soy2 = K0 + 0.2 * x11.X - x21.X\n            print(\n                f\"\\n  Cash available at Start of Year 2: {cash_available_soy2:.2f}\"\n            )\n            print(\"  Start of Year 2:\")\n            print(f\"    Project 1 (Annual, 20% profit): {x12.X:.2f}\")\n            print(\n                f\"    Project 3 (2-year, 160% return, limit 200k): {x32.X:.2f}\"\n            )\n            cash_soy2_invested = x12.X + x32.X\n            cash_soy2_uninvested = cash_available_soy2 - cash_soy2_invested\n            print(f\"    Total invested at SOY2: {cash_soy2_invested:.2f}\")\n            print(f\"    Uninvested cash from SOY2: {cash_soy2_uninvested:.2f}\")\n\n            cash_available_soy3 = K0 + 0.2 * x11.X + 0.5 * x21.X + 0.2 * x12.X - x32.X\n            print(\n                f\"\\n  Cash available at Start of Year 3: {cash_available_soy3:.2f}\"\n            )\n            print(\"  Start of Year 3:\")\n            print(f\"    Project 1 (Annual, 20% profit): {x13.X:.2f}\")\n            print(\n                f\"    Project 4 (1-year, 40% profit, limit 100k): {x43.X:.2f}\")\n            cash_soy3_invested = x13.X + x43.X\n            cash_soy3_uninvested = cash_available_soy3 - cash_soy3_invested\n            print(f\"    Total invested at SOY3: {cash_soy3_invested:.2f}\")\n            print(\n                f\"    Uninvested cash from SOY3 (carried to EOY3): {cash_soy3_uninvested:.2f}\"\n            )\n\n        else:\n            print(\"No optimal solution found. Status code:\", model.status)\n\n    except gp.GurobiError as e:\n        print(f\"Error code {e.errno}: {e}\")\n    except AttributeError:\n        print(\n            \"Encountered an attribute error. Gurobi might not be installed or licensed correctly.\"\n        )\n    except Exception as e:\n        print(f\"An unexpected error occurred: {e}\")\n\n\nif __name__ == '__main__':\n    solve_investment_problem()", "output_status": [], "success_count": 0, "success_confidence": 0, "fail_to_diagnose": 0, "fail_to_verify": 0, "retrieved_insights": [], "tag": [{"problem_domain": "Resource Allocation", "modeling_type": "LP", "industry_sector": "Finance", "reason": "The problem involves allocating a limited fund across various investment projects over multiple time periods to maximize the total return, which is a classic resource allocation problem. The mathematical formulation consists of a linear objective function and linear constraints, with continuous decision variables, making it a Linear Program (LP). The context of managing investment funds and maximizing returns clearly places it within the finance sector."}], "cluster": null, "prompt": "Below is an operations research question. First formulate the problem as an optimization problem. Then according to the formulated problem, write python code that uses 'gurobipy' to solve the optimization problem. You should write a complete python code that can be executed to solve the optimization problem.\n\nIMPORTANT: Your code should follow these requirements:\n1. Create a Gurobi model variable named 'model' (not 'm' or other names)\n2. Include all necessary imports and data setup\n3. Write the complete optimization code that can run independently\n4. Do NOT wrap everything in a function - write the code directly\n5. Make sure the model is created and optimized in the main execution flow\n6. The code should print the optimal objective value when solved successfully\n\nExample format:\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Data setup\ndata = {...}\n\n# Create model\nmodel = gp.Model(\"ProblemName\")\n\n# Decision variables\nx = model.addVars(...)\n\n# Objective\nmodel.setObjective(...)\n\n# Constraints\nmodel.addConstr(...)\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\nelse:\n    print(\"No optimal solution found\")\n```\n\n# Question:\nSomeone has a fund of 300,000 yuan and has the following investment projects in the next three years:\n(1) Investment can be made at the beginning of each year within three years, with an annual profit of 20% of the investment amount, and the principal and interest can be used for investment in the following year;\n(2) Investment is only allowed at the beginning of the first year, and it can be recovered at the end of the second year, with the total principal and interest amounting to 150% of the investment amount, but the investment limit is no more than 150,000 yuan;\n(3) Investment is allowed at the beginning of the second year within three years, and it can be recovered at the end of the third year, with the total principal and interest amounting to 160% of the investment amount, and the investment limit is 200,000 yuan;\n(4) Investment is allowed at the beginning of the third year within three years, and it can be recovered in one year with a profit of 40%, and the investment limit is 100,000 yuan.\nChapter One: Linear Programming and Simplex Method\nTry to determine an investment plan for this person that maximizes the principal and interest at the end of the third year.\n\n# Response:", "generated_output": "Below is a formulation and then a complete Gurobi Python code that can be run directly.\n\n---\n\n## 1. Optimization model formulation\n\nLet:\n\n- \\(x_{1}\\): amount invested in project (1) at the beginning of year 1  \n- \\(x_{2}\\): amount invested in project (1) at the beginning of year 2  \n- \\(x_{3}\\): amount invested in project (1) at the beginning of year 3  \n\n- \\(y\\): amount invested in project (2) at the beginning of year 1  \n- \\(z\\): amount invested in project (3) at the beginning of year 2  \n- \\(w\\): amount invested in project (4) at the beginning of year 3  \n\nAll variables are continuous and nonnegative.\n\nInitial fund at beginning of year 1: 300,000.\n\nReturns:\n- Project (1): invest at beginning of a year, get 1.2 times that amount at the end of that year.\n- Project (2): invest at beginning of year 1, get 1.5 times that amount at end of year 2.\n- Project (3): invest at beginning of year 2, get 1.6 times that amount at end of year 3.\n- Project (4): invest at beginning of year 3, get 1.4 times that amount at end of year 3.\n\n### Cash-flow constraints\n\n**Beginning of year 1:**\nAll investments at the beginning of year 1 cannot exceed the initial fund:\n\\[\nx_1 + y \\le 300000\n\\]\n\n**Beginning of year 2:**\nAvailable money at the beginning of year 2 is the return from project (1) in year 1:\n\\[\n\\text{Available at start of year 2} = 1.2 x_1\n\\]\nThis must cover investments in project (1) and (3) at the beginning of year 2:\n\\[\nx_2 + z \\le 1.2 x_1\n\\]\n\n**Beginning of year 3:**\nAvailable money at the beginning of year 3 is the return from project (1) in year 2 and project (2) (which matures at end of year 2):\n\\[\n\\text{Available at start of year 3} = 1.2 x_2 + 1.5 y\n\\]\nThis must cover investments in project (1) and (4) at the beginning of year 3:\n\\[\nx_3 + w \\le 1.2 x_2 + 1.5 y\n\\]\n\n### Investment limits\n\n\\[\n\\begin{aligned}\ny &\\le 150000 \\quad &\\text{(project 2 limit)}\\\\\nz &\\le 200000 \\quad &\\text{(project 3 limit)}\\\\\nw &\\le 100000 \\quad &\\text{(project 4 limit)}\n\\end{aligned}\n\\]\n\n### Objective\n\nMaximize total principal + interest at the end of year 3.\n\nAt end of year 3, we have:\n- Return from project (1) in year 3: \\(1.2 x_3\\)\n- Return from project (3): \\(1.6 z\\)\n- Return from project (4): \\(1.4 w\\)\n\nSo the objective is:\n\\[\n\\max \\; 1.2 x_3 + 1.6 z + 1.4 w\n\\]\n\nSubject to all constraints above and \\(x_1, x_2, x_3, y, z, w \\ge 0\\).\n\n---\n\n## 2. Complete Gurobi Python code\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# =========================\n# Data setup\n# =========================\ninitial_fund = 300000.0\n\n# Project returns (multipliers)\nr1 = 1.2   # project (1): 20% per year\nr2 = 1.5   # project (2): 50% over 2 years\nr3 = 1.6   # project (3): 60% over 2 years\nr4 = 1.4   # project (4): 40% over 1 year\n\n# Investment limits\nlimit_y = 150000.0  # project (2)\nlimit_z = 200000.0  # project (3)\nlimit_w = 100000.0  # project (4)\n\n# =========================\n# Create model\n# =========================\nmodel = gp.Model(\"InvestmentPlanning\")\n\n# =========================\n# Decision variables\n# =========================\n# x1, x2, x3: amounts invested in project (1) at beginning of years 1, 2, 3\nx1 = model.addVar(name=\"x1\", lb=0.0)\nx2 = model.addVar(name=\"x2\", lb=0.0)\nx3 = model.addVar(name=\"x3\", lb=0.0)\n\n# y: amount invested in project (2) at beginning of year 1\ny = model.addVar(name=\"y\", lb=0.0)\n\n# z: amount invested in project (3) at beginning of year 2\nz = model.addVar(name=\"z\", lb=0.0)\n\n# w: amount invested in project (4) at beginning of year 3\nw = model.addVar(name=\"w\", lb=0.0)\n\n# =========================\n# Constraints\n# =========================\n\n# Beginning of year 1: investments in projects (1) and (2) cannot exceed initial fund\nmodel.addConstr(x1 + y <= initial_fund, name=\"Year1_budget\")\n\n# Beginning of year 2: investments in projects (1) and (3) cannot exceed returns from project (1) in year 1\nmodel.addConstr(x2 + z <= r1 * x1, name=\"Year2_budget\")\n\n# Beginning of year 3: investments in projects (1) and (4) cannot exceed returns from project (1) in year 2 and project (2)\nmodel.addConstr(x3 + w <= r1 * x2 + r2 * y, name=\"Year3_budget\")\n\n# Investment limits\nmodel.addConstr(y <= limit_y, name=\"Limit_project2\")\nmodel.addConstr(z <= limit_z, name=\"Limit_project3\")\nmodel.addConstr(w <= limit_w, name=\"Limit_project4\")\n\n# =========================\n# Objective: maximize total wealth at end of year 3\n# =========================\n# End of year 3 wealth: returns from project (1) in year 3, project (3), and project (4)\nobjective_expr = r1 * x3 + r3 * z + r4 * w\nmodel.setObjective(objective_expr, GRB.MAXIMIZE)\n\n# =========================\n# Optimize\n# =========================\nmodel.optimize()\n\n# =========================\n# Results\n# =========================\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal:.2f}\")\n    print(\"Optimal investment plan:\")\n    print(f\"  x1 (proj 1, year 1): {x1.X:.2f}\")\n    print(f\"  x2 (proj 1, year 2): {x2.X:.2f}\")\n    print(f\"  x3 (proj 1, year 3): {x3.X:.2f}\")\n    print(f\"  y  (proj 2, year 1): {y.X:.2f}\")\n    print(f\"  z  (proj 3, year 2): {z.X:.2f}\")\n    print(f\"  w  (proj 4, year 3): {w.X:.2f}\")\nelse:\n    print(\"No optimal solution found\")\n```", "extracted_code": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# =========================\n# Data setup\n# =========================\ninitial_fund = 300000.0\n\n# Project returns (multipliers)\nr1 = 1.2   # project (1): 20% per year\nr2 = 1.5   # project (2): 50% over 2 years\nr3 = 1.6   # project (3): 60% over 2 years\nr4 = 1.4   # project (4): 40% over 1 year\n\n# Investment limits\nlimit_y = 150000.0  # project (2)\nlimit_z = 200000.0  # project (3)\nlimit_w = 100000.0  # project (4)\n\n# =========================\n# Create model\n# =========================\nmodel = gp.Model(\"InvestmentPlanning\")\n\n# =========================\n# Decision variables\n# =========================\n# x1, x2, x3: amounts invested in project (1) at beginning of years 1, 2, 3\nx1 = model.addVar(name=\"x1\", lb=0.0)\nx2 = model.addVar(name=\"x2\", lb=0.0)\nx3 = model.addVar(name=\"x3\", lb=0.0)\n\n# y: amount invested in project (2) at beginning of year 1\ny = model.addVar(name=\"y\", lb=0.0)\n\n# z: amount invested in project (3) at beginning of year 2\nz = model.addVar(name=\"z\", lb=0.0)\n\n# w: amount invested in project (4) at beginning of year 3\nw = model.addVar(name=\"w\", lb=0.0)\n\n# =========================\n# Constraints\n# =========================\n\n# Beginning of year 1: investments in projects (1) and (2) cannot exceed initial fund\nmodel.addConstr(x1 + y <= initial_fund, name=\"Year1_budget\")\n\n# Beginning of year 2: investments in projects (1) and (3) cannot exceed returns from project (1) in year 1\nmodel.addConstr(x2 + z <= r1 * x1, name=\"Year2_budget\")\n\n# Beginning of year 3: investments in projects (1) and (4) cannot exceed returns from project (1) in year 2 and project (2)\nmodel.addConstr(x3 + w <= r1 * x2 + r2 * y, name=\"Year3_budget\")\n\n# Investment limits\nmodel.addConstr(y <= limit_y, name=\"Limit_project2\")\nmodel.addConstr(z <= limit_z, name=\"Limit_project3\")\nmodel.addConstr(w <= limit_w, name=\"Limit_project4\")\n\n# =========================\n# Objective: maximize total wealth at end of year 3\n# =========================\n# End of year 3 wealth: returns from project (1) in year 3, project (3), and project (4)\nobjective_expr = r1 * x3 + r3 * z + r4 * w\nmodel.setObjective(objective_expr, GRB.MAXIMIZE)\n\n# =========================\n# Optimize\n# =========================\nmodel.optimize()\n\n# =========================\n# Results\n# =========================\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal:.2f}\")\n    print(\"Optimal investment plan:\")\n    print(f\"  x1 (proj 1, year 1): {x1.X:.2f}\")\n    print(f\"  x2 (proj 1, year 2): {x2.X:.2f}\")\n    print(f\"  x3 (proj 1, year 3): {x3.X:.2f}\")\n    print(f\"  y  (proj 2, year 1): {y.X:.2f}\")\n    print(f\"  z  (proj 3, year 2): {z.X:.2f}\")\n    print(f\"  w  (proj 4, year 3): {w.X:.2f}\")\nelse:\n    print(\"No optimal solution found\")", "execution_success": true, "mathematical_accuracy": true, "execution_result": "Execution Successful", "execution_best_solution": 580000.0, "execution_state": "Execution Successful"}
{"task_id": "B024", "description": "An investor plans to invest 100,000 yuan, with two investment options to choose from. The first investment guarantees a return of 0.7 yuan for every 1 yuan invested after one year. The second investment guarantees a return of 2 yuan for every 1 yuan invested after two years, but the investment time must be in multiples of two years. In order to maximize the investor's earnings by the end of the third year, how should the investments be made? Formulate this as a linear programming problem.", "ground_truth": 510000.0, "formulation": null, "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef solve_investment_problem():\n    \"\"\"\n    Solves the multi-period investment problem using Gurobi.\n    \"\"\"\n    try:\n        # Initial capital\n        K = 100000.0\n\n        # Create a new model\n        model = gp.Model(\"InvestmentStrategy\")\n\n        # --- Decision Variables ---\n        # x_ij: amount invested in option i at the start of year j (0-indexed for time)\n        # Option 1: 1-year term, 1 yuan becomes 1.7 yuan (0.7 profit)\n        # Option 2: 2-year term, 1 yuan becomes 3 yuan (2 profit)\n\n        # Investments at Start of Year 1 (Time 0)\n        x10 = model.addVar(name=\"x10\", lb=0.0,\n                           vtype=GRB.CONTINUOUS)  # Opt1, Year 1\n        x20 = model.addVar(name=\"x20\", lb=0.0,\n                           vtype=GRB.CONTINUOUS)  # Opt2, Year 1 (matures EOY2)\n\n        # Investments at Start of Year 2 (Time 1)\n        x11 = model.addVar(name=\"x11\", lb=0.0,\n                           vtype=GRB.CONTINUOUS)  # Opt1, Year 2\n        x21 = model.addVar(name=\"x21\", lb=0.0,\n                           vtype=GRB.CONTINUOUS)  # Opt2, Year 2 (matures EOY3)\n\n        # Investments at Start of Year 3 (Time 2)\n        x12 = model.addVar(name=\"x12\", lb=0.0,\n                           vtype=GRB.CONTINUOUS)  # Opt1, Year 3\n        # No x22 as Opt2 takes 2 years and goal is EOY3\n\n        # --- Objective Function ---\n        # Maximize total earnings by the end of year 3.\n        # Earnings = (Total value at EOY3) - K\n        # Total value = K + 0.7*x10 + 2*x20 + 0.7*x11 + 2*x21 + 0.7*x12\n        # Earnings = 0.7*x10 + 2*x20 + 0.7*x11 + 2*x21 + 0.7*x12\n        objective = 0.7 * x10 + 2.0 * x20 + 0.7 * x11 + 2.0 * x21 + 0.7 * x12\n        model.setObjective(objective, GRB.MAXIMIZE)\n\n        # --- Constraints ---\n        # Constraint 1: Cash availability at Start of Year 1 (Time 0)\n        model.addConstr(x10 + x20 <= K, \"Cash_Year1_Start\")\n\n        # Constraint 2: Cash availability at Start of Year 2 (Time 1)\n        # Money available = (K - x10 - x20) (uninvested T0) + 1.7*x10 (from x10 maturing)\n        # x11 + x21 <= K + 0.7*x10 - x20\n        model.addConstr(x11 + x21 - 0.7 * x10 + x20 <= K, \"Cash_Year2_Start\")\n\n        # Constraint 3: Cash availability at Start of Year 3 (Time 2)\n        # Money available at T2 = (Cash_Available_T1 - x11 - x21) (uninvested T1)\n        #                         + 1.7*x11 (from x11 maturing)\n        #                         + 3.0*x20 (from x20 maturing)\n        # Cash_Available_T1 = K + 0.7*x10 - x20\n        # Money available at T2 = (K + 0.7*x10 - x20 - x11 - x21) + 1.7*x11 + 3.0*x20\n        #                       = K + 0.7*x10 + 2.0*x20 + 0.7*x11 - x21\n        # x12 <= K + 0.7*x10 + 2.0*x20 + 0.7*x11 - x21\n        model.addConstr(x12 - 0.7 * x10 - 2.0 * x20 - 0.7 * x11 + x21 <= K,\n                        \"Cash_Year3_Start\")\n\n        # Suppress Gurobi output to console\n        model.setParam('OutputFlag', 0)\n\n        # Optimize the model\n        model.optimize()\n\n        # --- Results ---\n        if model.status == GRB.OPTIMAL:\n            print(\"Optimal solution found.\")\n            print(f\"Maximum Earnings: {model.objVal:.2f} yuan\")\n            print(\"\\nInvestment Plan:\")\n            print(f\"  Start of Year 1 (Time 0):\")\n            print(f\"    Invest in Option 1 (x10): {x10.X:.2f} yuan\")\n            print(f\"    Invest in Option 2 (x20): {x20.X:.2f} yuan\")\n\n            available_t1 = K - x10.X - x20.X + 1.7 * x10.X\n            print(\n                f\"\\n  Cash available at Start of Year 2 (Time 1): {available_t1:.2f} yuan\"\n            )\n            print(f\"  Start of Year 2 (Time 1):\")\n            print(f\"    Invest in Option 1 (x11): {x11.X:.2f} yuan\")\n            print(f\"    Invest in Option 2 (x21): {x21.X:.2f} yuan\")\n\n            available_t2 = available_t1 - x11.X - x21.X + 1.7 * x11.X + 3.0 * x20.X\n            print(\n                f\"\\n  Cash available at Start of Year 3 (Time 2): {available_t2:.2f} yuan\"\n            )\n            print(f\"  Start of Year 3 (Time 2):\")\n            print(f\"    Invest in Option 1 (x12): {x12.X:.2f} yuan\")\n\n            total_value_eoy3 = K + model.objVal\n            print(\n                f\"\\nTotal value at End of Year 3: {total_value_eoy3:.2f} yuan\")\n\n        else:\n            print(\"No optimal solution found. Status code:\", model.status)\n\n    except gp.GurobiError as e:\n        print(f\"Error code {e.errno}: {e}\")\n    except AttributeError:\n        print(\n            \"Encountered an attribute error, Gurobi might not be installed or licensed correctly.\"\n        )\n\n\nif __name__ == '__main__':\n    solve_investment_problem()", "output_status": [], "success_count": 0, "success_confidence": 0, "fail_to_diagnose": 0, "fail_to_verify": 0, "retrieved_insights": [], "tag": [{"problem_domain": "Portfolio Optimization", "modeling_type": "LP", "industry_sector": "Finance", "reason": "The problem involves allocating an initial capital across different investment options over multiple time periods to maximize total earnings, which is a classic portfolio optimization problem. The formulation uses linear objective and constraints with continuous variables, making it a Linear Program (LP)."}], "cluster": null, "prompt": "Below is an operations research question. First formulate the problem as an optimization problem. Then according to the formulated problem, write python code that uses 'gurobipy' to solve the optimization problem. You should write a complete python code that can be executed to solve the optimization problem.\n\nIMPORTANT: Your code should follow these requirements:\n1. Create a Gurobi model variable named 'model' (not 'm' or other names)\n2. Include all necessary imports and data setup\n3. Write the complete optimization code that can run independently\n4. Do NOT wrap everything in a function - write the code directly\n5. Make sure the model is created and optimized in the main execution flow\n6. The code should print the optimal objective value when solved successfully\n\nExample format:\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Data setup\ndata = {...}\n\n# Create model\nmodel = gp.Model(\"ProblemName\")\n\n# Decision variables\nx = model.addVars(...)\n\n# Objective\nmodel.setObjective(...)\n\n# Constraints\nmodel.addConstr(...)\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\nelse:\n    print(\"No optimal solution found\")\n```\n\n# Question:\nAn investor plans to invest 100,000 yuan, with two investment options to choose from. The first investment guarantees a return of 0.7 yuan for every 1 yuan invested after one year. The second investment guarantees a return of 2 yuan for every 1 yuan invested after two years, but the investment time must be in multiples of two years. In order to maximize the investor's earnings by the end of the third year, how should the investments be made? Formulate this as a linear programming problem.\n\n# Response:", "generated_output": "Below is a clear LP formulation followed by complete Gurobi code.\n\n---\n\n## 1. Linear Programming Formulation\n\nLet:\n\n- \\(x_1\\): amount (yuan) invested in option 1 at the beginning of year 1  \n- \\(x_2\\): amount (yuan) invested in option 1 at the beginning of year 2  \n- \\(x_3\\): amount (yuan) invested in option 1 at the beginning of year 3  \n- \\(y_1\\): amount (yuan) invested in option 2 at the beginning of year 1  \n- \\(y_2\\): amount (yuan) invested in option 2 at the beginning of year 2  \n\nInterpretation:\n\n- Option 1: 1 yuan at the beginning of a year returns 1.7 yuan at the end of that year (principal + 0.7 profit).\n- Option 2: 1 yuan at the beginning of a year returns 3 yuan at the end of the second year after investment (principal + 2 profit).  \n  - So \\(y_1\\) (invested at start of year 1) returns at end of year 2.  \n  - \\(y_2\\) (invested at start of year 2) returns at end of year 3.\n\nInitial capital at start of year 1: 100,000 yuan.\n\n### Cash-flow constraints\n\n1. **Start of year 1**  \n   All initial capital is allocated to investments at the beginning of year 1:\n   \\[\n   x_1 + y_1 = 100000\n   \\]\n\n2. **Start of year 2**  \n   Available capital at the beginning of year 2 is the return from option 1 invested in year 1:\n   \\[\n   x_2 + y_2 \\le 1.7 x_1\n   \\]\n\n3. **Start of year 3**  \n   Available capital at the beginning of year 3 is the return from:\n   - option 1 invested in year 2 (returns at end of year 2), and\n   - option 2 invested in year 1 (returns at end of year 2).\n   So:\n   \\[\n   x_3 \\le 1.7 x_2 + 3 y_1\n   \\]\n\n4. **Nonnegativity**\n   \\[\n   x_1, x_2, x_3, y_1, y_2 \\ge 0\n   \\]\n\n### Objective\n\nMaximize total wealth at the end of year 3:\n\n- \\(1.7 x_3\\): return from option 1 invested at start of year 3  \n- \\(3 y_2\\): return from option 2 invested at start of year 2  \n- \\(3 y_1\\): return from option 2 invested at start of year 1 (already realized at end of year 2, but still part of wealth at end of year 3)\n\nThus:\n\\[\n\\max Z = 1.7 x_3 + 3 y_2 + 3 y_1\n\\]\n\n---\n\n## 2. Complete Gurobi Python Code\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Data setup\ninitial_capital = 100000.0\nr1 = 1.7   # total return factor for option 1 after 1 year\nr2 = 3.0   # total return factor for option 2 after 2 years\n\n# Create model\nmodel = gp.Model(\"InvestmentPlanning3Years\")\n\n# Decision variables\n# x1, x2, x3: amounts invested in option 1 at start of years 1, 2, 3\n# y1, y2: amounts invested in option 2 at start of years 1, 2\nx1 = model.addVar(name=\"x1\", lb=0.0)\nx2 = model.addVar(name=\"x2\", lb=0.0)\nx3 = model.addVar(name=\"x3\", lb=0.0)\ny1 = model.addVar(name=\"y1\", lb=0.0)\ny2 = model.addVar(name=\"y2\", lb=0.0)\n\n# Objective: maximize wealth at end of year 3\n# Z = 1.7*x3 + 3*y2 + 3*y1\nmodel.setObjective(r1 * x3 + r2 * y2 + r2 * y1, GRB.MAXIMIZE)\n\n# Constraints\n\n# 1) Start of year 1: allocate initial capital\nmodel.addConstr(x1 + y1 == initial_capital, name=\"Year1Budget\")\n\n# 2) Start of year 2: capital from option 1 invested in year 1\nmodel.addConstr(x2 + y2 <= r1 * x1, name=\"Year2Budget\")\n\n# 3) Start of year 3: capital from option 1 in year 2 and option 2 in year 1\nmodel.addConstr(x3 <= r1 * x2 + r2 * y1, name=\"Year3Budget\")\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value (total wealth at end of year 3): {model.objVal:.2f}\")\n    print(\"Optimal investment plan:\")\n    print(f\"  x1 (opt1, start year 1): {x1.X:.2f}\")\n    print(f\"  y1 (opt2, start year 1): {y1.X:.2f}\")\n    print(f\"  x2 (opt1, start year 2): {x2.X:.2f}\")\n    print(f\"  y2 (opt2, start year 2): {y2.X:.2f}\")\n    print(f\"  x3 (opt1, start year 3): {x3.X:.2f}\")\nelse:\n    print(\"No optimal solution found\")\n```", "extracted_code": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Data setup\ninitial_capital = 100000.0\nr1 = 1.7   # total return factor for option 1 after 1 year\nr2 = 3.0   # total return factor for option 2 after 2 years\n\n# Create model\nmodel = gp.Model(\"InvestmentPlanning3Years\")\n\n# Decision variables\n# x1, x2, x3: amounts invested in option 1 at start of years 1, 2, 3\n# y1, y2: amounts invested in option 2 at start of years 1, 2\nx1 = model.addVar(name=\"x1\", lb=0.0)\nx2 = model.addVar(name=\"x2\", lb=0.0)\nx3 = model.addVar(name=\"x3\", lb=0.0)\ny1 = model.addVar(name=\"y1\", lb=0.0)\ny2 = model.addVar(name=\"y2\", lb=0.0)\n\n# Objective: maximize wealth at end of year 3\n# Z = 1.7*x3 + 3*y2 + 3*y1\nmodel.setObjective(r1 * x3 + r2 * y2 + r2 * y1, GRB.MAXIMIZE)\n\n# Constraints\n\n# 1) Start of year 1: allocate initial capital\nmodel.addConstr(x1 + y1 == initial_capital, name=\"Year1Budget\")\n\n# 2) Start of year 2: capital from option 1 invested in year 1\nmodel.addConstr(x2 + y2 <= r1 * x1, name=\"Year2Budget\")\n\n# 3) Start of year 3: capital from option 1 in year 2 and option 2 in year 1\nmodel.addConstr(x3 <= r1 * x2 + r2 * y1, name=\"Year3Budget\")\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value (total wealth at end of year 3): {model.objVal:.2f}\")\n    print(\"Optimal investment plan:\")\n    print(f\"  x1 (opt1, start year 1): {x1.X:.2f}\")\n    print(f\"  y1 (opt2, start year 1): {y1.X:.2f}\")\n    print(f\"  x2 (opt1, start year 2): {x2.X:.2f}\")\n    print(f\"  y2 (opt2, start year 2): {y2.X:.2f}\")\n    print(f\"  x3 (opt1, start year 3): {x3.X:.2f}\")\nelse:\n    print(\"No optimal solution found\")", "execution_success": true, "mathematical_accuracy": false, "execution_result": "Execution Successful", "execution_best_solution": 810000.0, "execution_state": "Execution Successful"}
{"task_id": "B067", "description": "There are two coal yards A and B, each receiving no less than 80 tons and 100 tons of coal per month, respectively. They are responsible for supplying coal to three residential areas, which need 55 tons, 75 tons, and 50 tons of coal per month, respectively. Coal yard A is located 10 kilometers, 5 kilometers, and 6 kilometers from these three residential areas. Coal yard B is located 4 kilometers, 8 kilometers, and 15 kilometers from these three residential areas. How should these two coal yards distribute coal to the three residential areas to minimize the ton-kilometers of transportation?", "ground_truth": 1030.0, "formulation": null, "correct_program": "def optimize_coal_distribution(supply_A=80,\n                               supply_B=100,\n                               demand_1=55,\n                               demand_2=75,\n                               demand_3=50):\n    import gurobipy as gp\n    from gurobipy import GRB\n\n    # Create a new model\n    model = gp.Model(\"Coal_Distribution_Minimize_TonKilometers\")\n\n    # Decision variables: amount of coal shipped from each yard to each area\n    x_A1 = model.addVar(lb=0, name=\"x_A1\")\n    x_A2 = model.addVar(lb=0, name=\"x_A2\")\n    x_A3 = model.addVar(lb=0, name=\"x_A3\")\n    x_B1 = model.addVar(lb=0, name=\"x_B1\")\n    x_B2 = model.addVar(lb=0, name=\"x_B2\")\n    x_B3 = model.addVar(lb=0, name=\"x_B3\")\n\n    # Set objective: minimize total ton-kilometers\n    model.setObjective(\n        10 * x_A1 + 5 * x_A2 + 6 * x_A3 + 4 * x_B1 + 8 * x_B2 + 15 * x_B3,\n        GRB.MINIMIZE)\n\n    # Supply constraints\n    model.addConstr(x_A1 + x_A2 + x_A3 >= supply_A, \"Supply_A\")\n    model.addConstr(x_B1 + x_B2 + x_B3 >= supply_B, \"Supply_B\")\n\n    # Demand constraints\n    model.addConstr(x_A1 + x_B1 == demand_1, \"Demand_1\")\n    model.addConstr(x_A2 + x_B2 == demand_2, \"Demand_2\")\n    model.addConstr(x_A3 + x_B3 == demand_3, \"Demand_3\")\n\n    # Optimize the model\n    model.optimize()\n\n    # Check if a feasible solution was found\n    if model.status == GRB.OPTIMAL:\n        return model.objVal\n    else:\n        return None\nif __name__ == \"__main__\":\n    result = optimize_coal_distribution()\n    if result is not None:\n        print(f\"Optimal total ton-kilometers: {result}\")\n    else:\n        print(\"No feasible solution found.\")", "output_status": [], "success_count": 0, "success_confidence": 0, "fail_to_diagnose": 0, "fail_to_verify": 0, "retrieved_insights": [], "tag": [{"problem_domain": "Transportation Problem", "modeling_type": "LP", "industry_sector": "Energy", "reason": "The problem involves minimizing transportation costs (ton-kilometers) for distributing coal from supply points to demand points, which is a classic transportation problem. The model uses linear decision variables and constraints, with a linear objective function, making it a Linear Program (LP). The application is related to coal distribution, which falls under the energy sector."}], "cluster": null, "prompt": "Below is an operations research question. First formulate the problem as an optimization problem. Then according to the formulated problem, write python code that uses 'gurobipy' to solve the optimization problem. You should write a complete python code that can be executed to solve the optimization problem.\n\nIMPORTANT: Your code should follow these requirements:\n1. Create a Gurobi model variable named 'model' (not 'm' or other names)\n2. Include all necessary imports and data setup\n3. Write the complete optimization code that can run independently\n4. Do NOT wrap everything in a function - write the code directly\n5. Make sure the model is created and optimized in the main execution flow\n6. The code should print the optimal objective value when solved successfully\n\nExample format:\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Data setup\ndata = {...}\n\n# Create model\nmodel = gp.Model(\"ProblemName\")\n\n# Decision variables\nx = model.addVars(...)\n\n# Objective\nmodel.setObjective(...)\n\n# Constraints\nmodel.addConstr(...)\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\nelse:\n    print(\"No optimal solution found\")\n```\n\n# Question:\nThere are two coal yards A and B, each receiving no less than 80 tons and 100 tons of coal per month, respectively. They are responsible for supplying coal to three residential areas, which need 55 tons, 75 tons, and 50 tons of coal per month, respectively. Coal yard A is located 10 kilometers, 5 kilometers, and 6 kilometers from these three residential areas. Coal yard B is located 4 kilometers, 8 kilometers, and 15 kilometers from these three residential areas. How should these two coal yards distribute coal to the three residential areas to minimize the ton-kilometers of transportation?\n\n# Response:", "generated_output": "Below is the mathematical formulation followed by a complete Gurobi Python code.\n\n---\n\n## 1. Optimization Model Formulation\n\n**Decision variables**\n\nLet  \n- \\(x_{A1}\\): tons shipped from yard A to residential area 1  \n- \\(x_{A2}\\): tons shipped from yard A to residential area 2  \n- \\(x_{A3}\\): tons shipped from yard A to residential area 3  \n- \\(x_{B1}\\): tons shipped from yard B to residential area 1  \n- \\(x_{B2}\\): tons shipped from yard B to residential area 2  \n- \\(x_{B3}\\): tons shipped from yard B to residential area 3  \n\nAll variables are nonnegative:\n\\[\nx_{ij} \\ge 0\n\\]\n\n**Parameters**\n\nDemands (tons/month):  \n- Area 1: \\(d_1 = 55\\)  \n- Area 2: \\(d_2 = 75\\)  \n- Area 3: \\(d_3 = 50\\)\n\nMinimum supply (tons/month):  \n- Yard A: at least 80 tons  \n- Yard B: at least 100 tons  \n\nDistances (km):  \n- From A: \\(c_{A1} = 10\\), \\(c_{A2} = 5\\), \\(c_{A3} = 6\\)  \n- From B: \\(c_{B1} = 4\\), \\(c_{B2} = 8\\), \\(c_{B3} = 15\\)\n\n**Objective function**\n\nMinimize total ton-kilometers:\n\\[\n\\min Z = 10x_{A1} + 5x_{A2} + 6x_{A3} + 4x_{B1} + 8x_{B2} + 15x_{B3}\n\\]\n\n**Constraints**\n\n1. Demand satisfaction for each residential area:\n\\[\n\\begin{aligned}\nx_{A1} + x_{B1} &= 55 \\\\\nx_{A2} + x_{B2} &= 75 \\\\\nx_{A3} + x_{B3} &= 50\n\\end{aligned}\n\\]\n\n2. Minimum supply from each yard:\n\\[\n\\begin{aligned}\nx_{A1} + x_{A2} + x_{A3} &\\ge 80 \\\\\nx_{B1} + x_{B2} + x_{B3} &\\ge 100\n\\end{aligned}\n\\]\n\n3. Nonnegativity:\n\\[\nx_{ij} \\ge 0 \\quad \\forall i \\in \\{A,B\\}, j \\in \\{1,2,3\\}\n\\]\n\n---\n\n## 2. Complete Gurobi Python Code\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# -----------------------------\n# Data setup\n# -----------------------------\n\nyards = ['A', 'B']\nareas = [1, 2, 3]\n\n# Distances (km) from each yard to each area\ndistance = {\n    ('A', 1): 10,\n    ('A', 2): 5,\n    ('A', 3): 6,\n    ('B', 1): 4,\n    ('B', 2): 8,\n    ('B', 3): 15\n}\n\n# Demands (tons) for each residential area\ndemand = {\n    1: 55,\n    2: 75,\n    3: 50\n}\n\n# Minimum supply (tons) from each yard\nmin_supply = {\n    'A': 80,\n    'B': 100\n}\n\n# -----------------------------\n# Create model\n# -----------------------------\n\nmodel = gp.Model(\"Coal_Distribution\")\n\n# -----------------------------\n# Decision variables\n# x[i,j] = tons shipped from yard i to area j\n# -----------------------------\n\nx = model.addVars(yards, areas, name=\"x\", lb=0.0)\n\n# -----------------------------\n# Objective: minimize total ton-kilometers\n# -----------------------------\n\nmodel.setObjective(\n    gp.quicksum(distance[i, j] * x[i, j] for i in yards for j in areas),\n    GRB.MINIMIZE\n)\n\n# -----------------------------\n# Constraints\n# -----------------------------\n\n# Demand satisfaction for each area\nfor j in areas:\n    model.addConstr(\n        gp.quicksum(x[i, j] for i in yards) == demand[j],\n        name=f\"demand_area_{j}\"\n    )\n\n# Minimum supply from each yard\nfor i in yards:\n    model.addConstr(\n        gp.quicksum(x[i, j] for j in areas) >= min_supply[i],\n        name=f\"min_supply_{i}\"\n    )\n\n# -----------------------------\n# Optimize\n# -----------------------------\n\nmodel.optimize()\n\n# -----------------------------\n# Results\n# -----------------------------\n\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value (total ton-kilometers): {model.objVal}\")\n    print(\"\\nOptimal shipment plan (tons):\")\n    for i in yards:\n        for j in areas:\n            val = x[i, j].X\n            if abs(val) > 1e-6:\n                print(f\"  From yard {i} to area {j}: {val:.2f} tons\")\nelse:\n    print(\"No optimal solution found\")\n```", "extracted_code": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# -----------------------------\n# Data setup\n# -----------------------------\n\nyards = ['A', 'B']\nareas = [1, 2, 3]\n\n# Distances (km) from each yard to each area\ndistance = {\n    ('A', 1): 10,\n    ('A', 2): 5,\n    ('A', 3): 6,\n    ('B', 1): 4,\n    ('B', 2): 8,\n    ('B', 3): 15\n}\n\n# Demands (tons) for each residential area\ndemand = {\n    1: 55,\n    2: 75,\n    3: 50\n}\n\n# Minimum supply (tons) from each yard\nmin_supply = {\n    'A': 80,\n    'B': 100\n}\n\n# -----------------------------\n# Create model\n# -----------------------------\n\nmodel = gp.Model(\"Coal_Distribution\")\n\n# -----------------------------\n# Decision variables\n# x[i,j] = tons shipped from yard i to area j\n# -----------------------------\n\nx = model.addVars(yards, areas, name=\"x\", lb=0.0)\n\n# -----------------------------\n# Objective: minimize total ton-kilometers\n# -----------------------------\n\nmodel.setObjective(\n    gp.quicksum(distance[i, j] * x[i, j] for i in yards for j in areas),\n    GRB.MINIMIZE\n)\n\n# -----------------------------\n# Constraints\n# -----------------------------\n\n# Demand satisfaction for each area\nfor j in areas:\n    model.addConstr(\n        gp.quicksum(x[i, j] for i in yards) == demand[j],\n        name=f\"demand_area_{j}\"\n    )\n\n# Minimum supply from each yard\nfor i in yards:\n    model.addConstr(\n        gp.quicksum(x[i, j] for j in areas) >= min_supply[i],\n        name=f\"min_supply_{i}\"\n    )\n\n# -----------------------------\n# Optimize\n# -----------------------------\n\nmodel.optimize()\n\n# -----------------------------\n# Results\n# -----------------------------\n\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value (total ton-kilometers): {model.objVal}\")\n    print(\"\\nOptimal shipment plan (tons):\")\n    for i in yards:\n        for j in areas:\n            val = x[i, j].X\n            if abs(val) > 1e-6:\n                print(f\"  From yard {i} to area {j}: {val:.2f} tons\")\nelse:\n    print(\"No optimal solution found\")", "execution_success": true, "mathematical_accuracy": true, "execution_result": "Execution Successful", "execution_best_solution": 1030.0, "execution_state": "Execution Successful"}
{"task_id": "B093", "description": "A company blends two types of crude oil (A and B) to produce two types of gasoline (Type I and Type II). The minimum proportion of crude oil A in gasoline Types I and II is 50% and 60%, respectively. The selling prices are 4800 yuan/t and 5600 yuan/t, respectively. The company has current inventories of 500 t of crude oil A and 1000 t of crude oil B, and they can purchase up to 1500 t of crude oil A from the market. The market price for crude oil A is: 10,000 yuan/t for purchases up to 500 t; 8,000 yuan/t for the portion exceeding 500 t but not exceeding 1000 t; 6,000 yuan/t for the portion exceeding 1000 t. How should the company plan its purchasing and processing of crude oil?", "ground_truth": 5000000.0, "formulation": null, "correct_program": "from gurobipy import Model, GRB, quicksum\n\n# 创建模型\nmodel = Model(\"Crude_Oil_Blending_Improved\")\n\n# ----------------------------\n# 参数设置\n# ----------------------------\nprice_I = 4800  # Type I 汽油售价\nprice_II = 5600  # Type II 汽油售价\n\ncost_A_segment1 = 10000  # 第一段成本（前500吨）\ncost_A_segment2 = 8000  # 第二段成本（500~1000吨）\ncost_A_segment3 = 6000  # 第三段成本（超过1000吨）\n\nmax_segment1 = 500  # 第一段最大购买量\nmax_segment2 = 500  # 第二段最大购买量\nmax_segment3 = 500  # 第三段最大购买量（总共最多1500）\n\ninv_A = 500  # 现有原油A库存\ninv_B = 1000  # 现有原油B库存\n\nM = 1e6  # 大M值\n\n# ----------------------------\n# 决策变量\n# ----------------------------\n\n# 汽油产量\nx1 = model.addVar(name=\"Gasoline_TypeI\")\nx2 = model.addVar(name=\"Gasoline_TypeII\")\n\n# 原油使用量\na1 = model.addVar(name=\"CrudeA_TypeI\")\nb1 = model.addVar(name=\"CrudeB_TypeI\")\na2 = model.addVar(name=\"CrudeA_TypeII\")\nb2 = model.addVar(name=\"CrudeB_TypeII\")\n\n# 购买的原油 A 分段数量\npa1 = model.addVar(ub=max_segment1, name=\"PurchaseA_Segment1\")  # ≤500\npa2 = model.addVar(ub=max_segment2, name=\"PurchaseA_Segment2\")  # ≤500\npa3 = model.addVar(ub=max_segment3, name=\"PurchaseA_Segment3\")  # ≤500\n\n# 是否进入某分段的二元变量\ny1 = model.addVar(vtype=GRB.BINARY, name=\"Segment1_Active\")\ny2 = model.addVar(vtype=GRB.BINARY, name=\"Segment2_Active\")\ny3 = model.addVar(vtype=GRB.BINARY, name=\"Segment3_Active\")\n\n# 总共使用的原油A和B\ntotal_a_used = a1 + a2\ntotal_b_used = b1 + b2\n\n# ----------------------------\n# 约束条件\n# ----------------------------\n\n# 1. 汽油生产由对应原油组成\nmodel.addConstr(a1 + b1 == x1, \"TypeI_Production\")\nmodel.addConstr(a2 + b2 == x2, \"TypeII_Production\")\n\n# 2. 原油A占比约束\nmodel.addConstr(a1 >= 0.5 * x1, \"TypeI_Min_A_Content\")\nmodel.addConstr(a2 >= 0.6 * x2, \"TypeII_Min_A_Content\")\n\n# 3. 原油使用总量不能超过库存+购买量\nmodel.addConstr(total_a_used <= inv_A + pa1 + pa2 + pa3, \"CrudeA_Limit\")\nmodel.addConstr(total_b_used <= inv_B, \"CrudeB_Limit\")\n\n# 4. 分段购买逻辑约束（必须买满前面段才允许进入下一段）\n# 第一段：只要 y1=1，就可以买，但不超过 max_segment1\nmodel.addConstr(pa1 <= max_segment1 * y1, \"Segment1_Upper\")\nmodel.addConstr(pa1 >= 0)\n\n# 第二段：只能在 y2=1 且 pa1 已买满时才能购买\nmodel.addConstr(pa2 <= max_segment2 * y2, \"Segment2_Upper\")\nmodel.addConstr(y1 >= y2, \"Must_Fill_Segment1_First\")\nmodel.addConstr(pa1 >= max_segment1 * y2, \"Fill_Segment1_Before_Segment2\")\n\n# 第三段：只能在 y3=1 且 pa1、pa2 都已买满时才能购买\nmodel.addConstr(pa3 <= max_segment3 * y3, \"Segment3_Upper\")\nmodel.addConstr(y2 >= y3, \"Must_Fill_Segment2_Before_Segment3\")\n# model.addConstr(pa1 >= max_segment1 * y3, \"Fill_Segment1_Before_Segment3\")\nmodel.addConstr(pa2 >= max_segment2 * y3, \"Fill_Segment2_Before_Segment3\")\n\n# ----------------------------\n# 目标函数：最大化利润 = 销售收入 - 原油成本\n# ----------------------------\n\nrevenue = price_I * x1 + price_II * x2\npurchase_cost = cost_A_segment1 * pa1 + cost_A_segment2 * pa2 + cost_A_segment3 * pa3\n\nprofit = revenue - purchase_cost\n\nmodel.setObjective(profit, GRB.MAXIMIZE)\n\n# ----------------------------\n# 求解模型\n# ----------------------------\n\nmodel.optimize()\n\n# ----------------------------\n# 输出结果\n# ----------------------------\n\nif model.status == GRB.OPTIMAL:\n    print(\"\\nOptimal Solution Found:\")\n    print(f\"Produce {x1.X:.2f} tons of Gasoline Type I\")\n    print(f\"Produce {x2.X:.2f} tons of Gasoline Type II\")\n    print(f\"Use {a1.X:.2f} tons of Crude A for Type I\")\n    print(f\"Use {b1.X:.2f} tons of Crude B for Type I\")\n    print(f\"Use {a2.X:.2f} tons of Crude A for Type II\")\n    print(f\"Use {b2.X:.2f} tons of Crude B for Type II\")\n    print(f\"Purchase Segment 1: {pa1.X:.2f} tons (<=500)\")\n    print(f\"Purchase Segment 2: {pa2.X:.2f} tons (500~1000)\")\n    print(f\"Purchase Segment 3: {pa3.X:.2f} tons (>1000)\")\n    print(f\"Total Profit: {profit.getValue():.2f} yuan\")\nelse:\n    print(\"No optimal solution found.\")", "output_status": [], "success_count": 0, "success_confidence": 0, "fail_to_diagnose": 0, "fail_to_verify": 0, "retrieved_insights": [], "tag": [{"problem_domain": "Blending", "modeling_type": "MILP", "industry_sector": "Manufacturing", "reason": "The problem involves mixing different crude oils to produce gasoline, which is a classic blending problem. The solver uses continuous variables for quantities and binary variables to model the piecewise linear purchasing cost for crude oil A, making it a Mixed-Integer Linear Program. The application is in the production of gasoline, falling under the manufacturing sector."}], "cluster": null, "prompt": "Below is an operations research question. First formulate the problem as an optimization problem. Then according to the formulated problem, write python code that uses 'gurobipy' to solve the optimization problem. You should write a complete python code that can be executed to solve the optimization problem.\n\nIMPORTANT: Your code should follow these requirements:\n1. Create a Gurobi model variable named 'model' (not 'm' or other names)\n2. Include all necessary imports and data setup\n3. Write the complete optimization code that can run independently\n4. Do NOT wrap everything in a function - write the code directly\n5. Make sure the model is created and optimized in the main execution flow\n6. The code should print the optimal objective value when solved successfully\n\nExample format:\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Data setup\ndata = {...}\n\n# Create model\nmodel = gp.Model(\"ProblemName\")\n\n# Decision variables\nx = model.addVars(...)\n\n# Objective\nmodel.setObjective(...)\n\n# Constraints\nmodel.addConstr(...)\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\nelse:\n    print(\"No optimal solution found\")\n```\n\n# Question:\nA company blends two types of crude oil (A and B) to produce two types of gasoline (Type I and Type II). The minimum proportion of crude oil A in gasoline Types I and II is 50% and 60%, respectively. The selling prices are 4800 yuan/t and 5600 yuan/t, respectively. The company has current inventories of 500 t of crude oil A and 1000 t of crude oil B, and they can purchase up to 1500 t of crude oil A from the market. The market price for crude oil A is: 10,000 yuan/t for purchases up to 500 t; 8,000 yuan/t for the portion exceeding 500 t but not exceeding 1000 t; 6,000 yuan/t for the portion exceeding 1000 t. How should the company plan its purchasing and processing of crude oil?\n\n# Response:", "generated_output": "Below is a clear formulation and then a complete Gurobi Python code.\n\n---\n\n## 1. Optimization model formulation\n\n### Decision variables\nLet:\n\n- \\(x_1\\): tons of gasoline Type I produced  \n- \\(x_2\\): tons of gasoline Type II produced  \n\nCrude A usage:\n- \\(a_1\\): tons of crude A used in Type I  \n- \\(a_2\\): tons of crude A used in Type II  \n\nCrude B usage:\n- \\(b_1\\): tons of crude B used in Type I  \n- \\(b_2\\): tons of crude B used in Type II  \n\nPurchases of crude A in price tiers:\n- \\(y_1\\): tons of crude A purchased in tier 1 (10,000 yuan/t, up to 500 t)  \n- \\(y_2\\): tons of crude A purchased in tier 2 (8,000 yuan/t, next 500 t, i.e., up to 1000 t total)  \n- \\(y_3\\): tons of crude A purchased in tier 3 (6,000 yuan/t, beyond 1000 t, up to total 1500 t purchased)\n\nAll variables are nonnegative.\n\n### Parameters\n\n- Initial inventory of crude A: \\(A_0 = 500\\) t  \n- Initial inventory of crude B: \\(B_0 = 1000\\) t  \n- Max total purchase of A: \\(Y_{\\max} = 1500\\) t  \n- Tier limits for A purchase:\n  - \\(0 \\le y_1 \\le 500\\)\n  - \\(0 \\le y_2 \\le 500\\)\n  - \\(0 \\le y_3 \\le 500\\) (since total purchase ≤ 1500 and tiers are 500 each)\n\nSelling prices:\n- Type I: 4800 yuan/t  \n- Type II: 5600 yuan/t  \n\nPurchase prices for A:\n- Tier 1: 10,000 yuan/t  \n- Tier 2: 8,000 yuan/t  \n- Tier 3: 6,000 yuan/t  \n\n### Constraints\n\n1. Blend composition (minimum proportion of A):\n   - Type I: at least 50% A  \n     \\[\n     a_1 \\ge 0.5 x_1\n     \\]\n   - Type II: at least 60% A  \n     \\[\n     a_2 \\ge 0.6 x_2\n     \\]\n\n2. Material balance for each gasoline type:\n   - Type I:\n     \\[\n     a_1 + b_1 = x_1\n     \\]\n   - Type II:\n     \\[\n     a_2 + b_2 = x_2\n     \\]\n\n3. Availability of crude A:\n   \\[\n   a_1 + a_2 \\le A_0 + y_1 + y_2 + y_3\n   \\]\n\n4. Availability of crude B (no purchase, only inventory):\n   \\[\n   b_1 + b_2 \\le B_0\n   \\]\n\n5. Purchase limits for A:\n   \\[\n   y_1 \\le 500,\\quad y_2 \\le 500,\\quad y_3 \\le 500\n   \\]\n   \\[\n   y_1 + y_2 + y_3 \\le 1500\n   \\]\n\n6. Nonnegativity:\n   \\[\n   x_1, x_2, a_1, a_2, b_1, b_2, y_1, y_2, y_3 \\ge 0\n   \\]\n\n### Objective function\n\nMaximize profit = revenue from gasoline − cost of purchased crude A.\n\nRevenue:\n\\[\nR = 4800 x_1 + 5600 x_2\n\\]\n\nCost of purchased A:\n\\[\nC = 10000 y_1 + 8000 y_2 + 6000 y_3\n\\]\n\nObjective:\n\\[\n\\max \\; Z = 4800 x_1 + 5600 x_2 - (10000 y_1 + 8000 y_2 + 6000 y_3)\n\\]\n\n---\n\n## 2. Complete Gurobi Python code\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# -----------------------------\n# Data setup\n# -----------------------------\nA_initial = 500.0   # tons of crude A in inventory\nB_initial = 1000.0  # tons of crude B in inventory\n\n# Selling prices (yuan per ton)\nprice_I = 4800.0\nprice_II = 5600.0\n\n# Purchase price tiers for crude A (yuan per ton)\nprice_A_tier1 = 10000.0\nprice_A_tier2 = 8000.0\nprice_A_tier3 = 6000.0\n\n# Tier capacities for crude A purchases (tons)\ntier_cap = 500.0  # each tier up to 500 t\nmax_purchase_A = 1500.0  # total purchase limit\n\n# -----------------------------\n# Create model\n# -----------------------------\nmodel = gp.Model(\"CrudeBlending\")\n\n# -----------------------------\n# Decision variables\n# -----------------------------\n# Gasoline production quantities\nx1 = model.addVar(name=\"x1_TypeI\", lb=0.0)   # tons of Type I gasoline\nx2 = model.addVar(name=\"x2_TypeII\", lb=0.0)  # tons of Type II gasoline\n\n# Crude A usage in each gasoline type\na1 = model.addVar(name=\"a1_A_in_TypeI\", lb=0.0)\na2 = model.addVar(name=\"a2_A_in_TypeII\", lb=0.0)\n\n# Crude B usage in each gasoline type\nb1 = model.addVar(name=\"b1_B_in_TypeI\", lb=0.0)\nb2 = model.addVar(name=\"b2_B_in_TypeII\", lb=0.0)\n\n# Purchases of crude A in each price tier\ny1 = model.addVar(name=\"y1_A_tier1\", lb=0.0)  # up to 500 t at 10,000\ny2 = model.addVar(name=\"y2_A_tier2\", lb=0.0)  # next 500 t at 8,000\ny3 = model.addVar(name=\"y3_A_tier3\", lb=0.0)  # next 500 t at 6,000\n\nmodel.update()\n\n# -----------------------------\n# Constraints\n# -----------------------------\n\n# 1. Blend composition constraints (minimum proportion of A)\nmodel.addConstr(a1 >= 0.5 * x1, name=\"min_A_in_TypeI\")\nmodel.addConstr(a2 >= 0.6 * x2, name=\"min_A_in_TypeII\")\n\n# 2. Material balance for each gasoline type\nmodel.addConstr(a1 + b1 == x1, name=\"balance_TypeI\")\nmodel.addConstr(a2 + b2 == x2, name=\"balance_TypeII\")\n\n# 3. Availability of crude A (inventory + purchases)\nmodel.addConstr(a1 + a2 <= A_initial + y1 + y2 + y3, name=\"A_availability\")\n\n# 4. Availability of crude B (only inventory)\nmodel.addConstr(b1 + b2 <= B_initial, name=\"B_availability\")\n\n# 5. Purchase limits for A tiers\nmodel.addConstr(y1 <= tier_cap, name=\"tier1_cap\")\nmodel.addConstr(y2 <= tier_cap, name=\"tier2_cap\")\nmodel.addConstr(y3 <= tier_cap, name=\"tier3_cap\")\nmodel.addConstr(y1 + y2 + y3 <= max_purchase_A, name=\"total_purchase_cap\")\n\n# -----------------------------\n# Objective: maximize profit\n# -----------------------------\nrevenue = price_I * x1 + price_II * x2\ncost_A = price_A_tier1 * y1 + price_A_tier2 * y2 + price_A_tier3 * y3\n\nmodel.setObjective(revenue - cost_A, GRB.MAXIMIZE)\n\n# -----------------------------\n# Optimize\n# -----------------------------\nmodel.optimize()\n\n# -----------------------------\n# Results\n# -----------------------------\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal:.2f}\")\n    print(\"Decision variables:\")\n    for v in model.getVars():\n        print(f\"  {v.VarName} = {v.X:.4f}\")\nelse:\n    print(\"No optimal solution found\")\n```", "extracted_code": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# -----------------------------\n# Data setup\n# -----------------------------\nA_initial = 500.0   # tons of crude A in inventory\nB_initial = 1000.0  # tons of crude B in inventory\n\n# Selling prices (yuan per ton)\nprice_I = 4800.0\nprice_II = 5600.0\n\n# Purchase price tiers for crude A (yuan per ton)\nprice_A_tier1 = 10000.0\nprice_A_tier2 = 8000.0\nprice_A_tier3 = 6000.0\n\n# Tier capacities for crude A purchases (tons)\ntier_cap = 500.0  # each tier up to 500 t\nmax_purchase_A = 1500.0  # total purchase limit\n\n# -----------------------------\n# Create model\n# -----------------------------\nmodel = gp.Model(\"CrudeBlending\")\n\n# -----------------------------\n# Decision variables\n# -----------------------------\n# Gasoline production quantities\nx1 = model.addVar(name=\"x1_TypeI\", lb=0.0)   # tons of Type I gasoline\nx2 = model.addVar(name=\"x2_TypeII\", lb=0.0)  # tons of Type II gasoline\n\n# Crude A usage in each gasoline type\na1 = model.addVar(name=\"a1_A_in_TypeI\", lb=0.0)\na2 = model.addVar(name=\"a2_A_in_TypeII\", lb=0.0)\n\n# Crude B usage in each gasoline type\nb1 = model.addVar(name=\"b1_B_in_TypeI\", lb=0.0)\nb2 = model.addVar(name=\"b2_B_in_TypeII\", lb=0.0)\n\n# Purchases of crude A in each price tier\ny1 = model.addVar(name=\"y1_A_tier1\", lb=0.0)  # up to 500 t at 10,000\ny2 = model.addVar(name=\"y2_A_tier2\", lb=0.0)  # next 500 t at 8,000\ny3 = model.addVar(name=\"y3_A_tier3\", lb=0.0)  # next 500 t at 6,000\n\nmodel.update()\n\n# -----------------------------\n# Constraints\n# -----------------------------\n\n# 1. Blend composition constraints (minimum proportion of A)\nmodel.addConstr(a1 >= 0.5 * x1, name=\"min_A_in_TypeI\")\nmodel.addConstr(a2 >= 0.6 * x2, name=\"min_A_in_TypeII\")\n\n# 2. Material balance for each gasoline type\nmodel.addConstr(a1 + b1 == x1, name=\"balance_TypeI\")\nmodel.addConstr(a2 + b2 == x2, name=\"balance_TypeII\")\n\n# 3. Availability of crude A (inventory + purchases)\nmodel.addConstr(a1 + a2 <= A_initial + y1 + y2 + y3, name=\"A_availability\")\n\n# 4. Availability of crude B (only inventory)\nmodel.addConstr(b1 + b2 <= B_initial, name=\"B_availability\")\n\n# 5. Purchase limits for A tiers\nmodel.addConstr(y1 <= tier_cap, name=\"tier1_cap\")\nmodel.addConstr(y2 <= tier_cap, name=\"tier2_cap\")\nmodel.addConstr(y3 <= tier_cap, name=\"tier3_cap\")\nmodel.addConstr(y1 + y2 + y3 <= max_purchase_A, name=\"total_purchase_cap\")\n\n# -----------------------------\n# Objective: maximize profit\n# -----------------------------\nrevenue = price_I * x1 + price_II * x2\ncost_A = price_A_tier1 * y1 + price_A_tier2 * y2 + price_A_tier3 * y3\n\nmodel.setObjective(revenue - cost_A, GRB.MAXIMIZE)\n\n# -----------------------------\n# Optimize\n# -----------------------------\nmodel.optimize()\n\n# -----------------------------\n# Results\n# -----------------------------\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal:.2f}\")\n    print(\"Decision variables:\")\n    for v in model.getVars():\n        print(f\"  {v.VarName} = {v.X:.4f}\")\nelse:\n    print(\"No optimal solution found\")", "execution_success": true, "mathematical_accuracy": false, "execution_result": "Execution Successful", "execution_best_solution": 7000000.0, "execution_state": "Execution Successful"}
{"task_id": "B007", "description": "Now, we need to determine 4 out of 5 workers to complete one of the four tasks respectively. Due to each worker's different technical specialties, the time required for them to complete each task varies. The hours required by each worker to complete each task are shown in Table 5-2.\n\nTable 5-2\n| Worker | $A$ | $B$ | $C$ | $D$ |\n|--------|-----|-----|-----|-----|\n| I      | 9   | 4   | 3   | 7   |\n| II     | 4   | 6   | 5   | 6   |\n| III    | 5   | 4   | 7   | 5   |\n| IV     | 7   | 5   | 2   | 3   |\n| V      | 10  | 6   | 7   | 4   |\n\nTry to find a job assignment plan that minimizes the total working hours.", "ground_truth": 14.0, "formulation": null, "correct_program": "def optimize_worker_task_assignment():\n    from gurobipy import Model, GRB\n\n    # Data: hours required for each worker-task pair\n    hours = {\n        ('I', 'A'): 9,\n        ('I', 'B'): 4,\n        ('I', 'C'): 3,\n        ('I', 'D'): 7,\n        ('II', 'A'): 4,\n        ('II', 'B'): 6,\n        ('II', 'C'): 5,\n        ('II', 'D'): 6,\n        ('III', 'A'): 5,\n        ('III', 'B'): 4,\n        ('III', 'C'): 7,\n        ('III', 'D'): 5,\n        ('IV', 'A'): 7,\n        ('IV', 'B'): 5,\n        ('IV', 'C'): 2,\n        ('IV', 'D'): 3,\n        ('V', 'A'): 10,\n        ('V', 'B'): 6,\n        ('V', 'C'): 7,\n        ('V', 'D'): 4\n    }\n\n    workers = ['I', 'II', 'III', 'IV', 'V']\n    tasks = ['A', 'B', 'C', 'D']\n\n    # Create model\n    m = Model(\"WorkerTaskAssignment\")\n    m.setParam('OutputFlag', 0)  # Suppress output\n\n    # Decision variables: x_{i,j}\n    x = m.addVars(workers, tasks, vtype=GRB.BINARY, name='x')\n    # Worker selection variables: y_i\n    y = m.addVars(workers, vtype=GRB.BINARY, name='y')\n\n    # Objective: minimize total hours\n    m.setObjective(\n        sum(hours[(i, j)] * x[i, j] for i in workers for j in tasks),\n        GRB.MINIMIZE)\n\n    # Constraints:\n\n    # Each task assigned to exactly one worker\n    for j in tasks:\n        m.addConstr(sum(x[i, j] for i in workers) == 1,\n                    name=f\"Task_{j}_assignment\")\n\n    # Worker assignment constraints\n    for i in workers:\n        m.addConstr(sum(x[i, j] for j in tasks) <= y[i],\n                    name=f\"Worker_{i}_assignment_limit\")\n\n    # Exactly 4 workers are selected\n    m.addConstr(sum(y[i] for i in workers) == 4, name=\"Select_4_workers\")\n\n    # Linking constraints: worker assigned only if selected\n    for i in workers:\n        for j in tasks:\n            m.addConstr(x[i, j] <= y[i], name=f\"Link_{i}_{j}\")\n\n    # Optimize\n    m.optimize()\n\n    # Check feasibility and return optimal value\n    if m.status == GRB.OPTIMAL:\n        return m.objVal\n    else:\n        return None\n\nif __name__ == \"__main__\":\n    result = optimize_worker_task_assignment()\n    if result is not None:\n        print(f\"Optimal total hours: {result}\")\n    else:\n        print(\"No feasible solution found.\")", "output_status": [], "success_count": 0, "success_confidence": 0, "fail_to_diagnose": 0, "fail_to_verify": 0, "retrieved_insights": [], "tag": [{"problem_domain": "Assignment", "modeling_type": "MILP", "industry_sector": "General Business Operations", "reason": "The problem involves assigning workers to tasks to minimize total hours, which is a classic assignment problem. The formulation uses binary variables for assignments and worker selection, and linear constraints and objective, making it a Mixed-Integer Linear Program. This type of problem is common in various business operations where resources (workers) need to be allocated to tasks."}], "cluster": null, "prompt": "Below is an operations research question. First formulate the problem as an optimization problem. Then according to the formulated problem, write python code that uses 'gurobipy' to solve the optimization problem. You should write a complete python code that can be executed to solve the optimization problem.\n\nIMPORTANT: Your code should follow these requirements:\n1. Create a Gurobi model variable named 'model' (not 'm' or other names)\n2. Include all necessary imports and data setup\n3. Write the complete optimization code that can run independently\n4. Do NOT wrap everything in a function - write the code directly\n5. Make sure the model is created and optimized in the main execution flow\n6. The code should print the optimal objective value when solved successfully\n\nExample format:\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Data setup\ndata = {...}\n\n# Create model\nmodel = gp.Model(\"ProblemName\")\n\n# Decision variables\nx = model.addVars(...)\n\n# Objective\nmodel.setObjective(...)\n\n# Constraints\nmodel.addConstr(...)\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\nelse:\n    print(\"No optimal solution found\")\n```\n\n# Question:\nNow, we need to determine 4 out of 5 workers to complete one of the four tasks respectively. Due to each worker's different technical specialties, the time required for them to complete each task varies. The hours required by each worker to complete each task are shown in Table 5-2.\n\nTable 5-2\n| Worker | $A$ | $B$ | $C$ | $D$ |\n|--------|-----|-----|-----|-----|\n| I      | 9   | 4   | 3   | 7   |\n| II     | 4   | 6   | 5   | 6   |\n| III    | 5   | 4   | 7   | 5   |\n| IV     | 7   | 5   | 2   | 3   |\n| V      | 10  | 6   | 7   | 4   |\n\nTry to find a job assignment plan that minimizes the total working hours.\n\n# Response:", "generated_output": "Below is the mathematical formulation and then the complete Python code using `gurobipy`.\n\n---\n\n## Optimization Model Formulation\n\n**Sets:**\n\n- Workers \\( i \\in W = \\{1,2,3,4,5\\} \\) (I, II, III, IV, V)\n- Tasks \\( j \\in T = \\{A,B,C,D\\} \\)\n\n**Parameters:**\n\nLet \\( c_{ij} \\) be the hours required for worker \\( i \\) to complete task \\( j \\). From the table:\n\n\\[\nC = \n\\begin{array}{c|cccc}\n & A & B & C & D \\\\\n\\hline\n1 & 9 & 4 & 3 & 7 \\\\\n2 & 4 & 6 & 5 & 6 \\\\\n3 & 5 & 4 & 7 & 5 \\\\\n4 & 7 & 5 & 2 & 3 \\\\\n5 & 10 & 6 & 7 & 4 \\\\\n\\end{array}\n\\]\n\n**Decision variables:**\n\n\\[\nx_{ij} = \n\\begin{cases}\n1 & \\text{if worker } i \\text{ is assigned to task } j \\\\\n0 & \\text{otherwise}\n\\end{cases}\n\\]\n\n**Objective:**\n\nMinimize total working hours:\n\n\\[\n\\min \\sum_{i \\in W} \\sum_{j \\in T} c_{ij} x_{ij}\n\\]\n\n**Constraints:**\n\n1. Each task is assigned to exactly one worker:\n\\[\n\\sum_{i \\in W} x_{ij} = 1 \\quad \\forall j \\in T\n\\]\n\n2. Each worker can do at most one task (since only 4 of 5 workers are used):\n\\[\n\\sum_{j \\in T} x_{ij} \\le 1 \\quad \\forall i \\in W\n\\]\n\n3. Binary constraints:\n\\[\nx_{ij} \\in \\{0,1\\} \\quad \\forall i \\in W, \\forall j \\in T\n\\]\n\n---\n\n## Complete Python Code (Gurobi)\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Data setup\nworkers = [\"I\", \"II\", \"III\", \"IV\", \"V\"]\ntasks = [\"A\", \"B\", \"C\", \"D\"]\n\n# Hours required: c[worker][task]\nhours = {\n    \"I\":   {\"A\": 9,  \"B\": 4, \"C\": 3, \"D\": 7},\n    \"II\":  {\"A\": 4,  \"B\": 6, \"C\": 5, \"D\": 6},\n    \"III\": {\"A\": 5,  \"B\": 4, \"C\": 7, \"D\": 5},\n    \"IV\":  {\"A\": 7,  \"B\": 5, \"C\": 2, \"D\": 3},\n    \"V\":   {\"A\": 10, \"B\": 6, \"C\": 7, \"D\": 4},\n}\n\n# Create model\nmodel = gp.Model(\"WorkerTaskAssignment\")\n\n# Decision variables: x[w, t] = 1 if worker w is assigned to task t\nx = model.addVars(workers, tasks, vtype=GRB.BINARY, name=\"x\")\n\n# Objective: minimize total working hours\nmodel.setObjective(\n    gp.quicksum(hours[w][t] * x[w, t] for w in workers for t in tasks),\n    GRB.MINIMIZE\n)\n\n# Constraints\n\n# Each task is assigned to exactly one worker\nfor t in tasks:\n    model.addConstr(gp.quicksum(x[w, t] for w in workers) == 1, name=f\"task_{t}_assigned_once\")\n\n# Each worker can do at most one task (only 4 of 5 workers will be used)\nfor w in workers:\n    model.addConstr(gp.quicksum(x[w, t] for t in tasks) <= 1, name=f\"worker_{w}_at_most_one\")\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\n    print(\"Assignments:\")\n    for w in workers:\n        for t in tasks:\n            if x[w, t].X > 0.5:\n                print(f\"  Worker {w} -> Task {t}, hours = {hours[w][t]}\")\nelse:\n    print(\"No optimal solution found\")\n```", "extracted_code": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Data setup\nworkers = [\"I\", \"II\", \"III\", \"IV\", \"V\"]\ntasks = [\"A\", \"B\", \"C\", \"D\"]\n\n# Hours required: c[worker][task]\nhours = {\n    \"I\":   {\"A\": 9,  \"B\": 4, \"C\": 3, \"D\": 7},\n    \"II\":  {\"A\": 4,  \"B\": 6, \"C\": 5, \"D\": 6},\n    \"III\": {\"A\": 5,  \"B\": 4, \"C\": 7, \"D\": 5},\n    \"IV\":  {\"A\": 7,  \"B\": 5, \"C\": 2, \"D\": 3},\n    \"V\":   {\"A\": 10, \"B\": 6, \"C\": 7, \"D\": 4},\n}\n\n# Create model\nmodel = gp.Model(\"WorkerTaskAssignment\")\n\n# Decision variables: x[w, t] = 1 if worker w is assigned to task t\nx = model.addVars(workers, tasks, vtype=GRB.BINARY, name=\"x\")\n\n# Objective: minimize total working hours\nmodel.setObjective(\n    gp.quicksum(hours[w][t] * x[w, t] for w in workers for t in tasks),\n    GRB.MINIMIZE\n)\n\n# Constraints\n\n# Each task is assigned to exactly one worker\nfor t in tasks:\n    model.addConstr(gp.quicksum(x[w, t] for w in workers) == 1, name=f\"task_{t}_assigned_once\")\n\n# Each worker can do at most one task (only 4 of 5 workers will be used)\nfor w in workers:\n    model.addConstr(gp.quicksum(x[w, t] for t in tasks) <= 1, name=f\"worker_{w}_at_most_one\")\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\n    print(\"Assignments:\")\n    for w in workers:\n        for t in tasks:\n            if x[w, t].X > 0.5:\n                print(f\"  Worker {w} -> Task {t}, hours = {hours[w][t]}\")\nelse:\n    print(\"No optimal solution found\")", "execution_success": true, "mathematical_accuracy": true, "execution_result": "Execution Successful", "execution_best_solution": 14.0, "execution_state": "Execution Successful"}
