{"task_id": "A109", "description": "A zookeeper feeds a gorilla with bananas and mangoes. Each banana contains 80 calories, 20 grams of potassium, and 10 grams of sugar. Each mango contains 100 calories, 15 grams of potassium, and 8 grams of sugar.  The gorilla must consume at least 4000 calories and 150 grams of potassium. Since the gorilla prefers bananas, at most 33% of the fruits he eats can be mangoes. If excess sugar makes the gorilla aggressive, how many of each fruit should he consume to minimize his sugar intake?", "ground_truth": 440.0, "formulation": null, "correct_program": "def optimize_gorilla_fruits():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"GorillaFruits\")\n\n    # Decision variables: number of bananas and mangoes\n    x_b = m.addVar(name=\"Bananas\", lb=0, vtype=GRB.INTEGER)\n    x_m = m.addVar(name=\"Mangoes\", lb=0, vtype=GRB.INTEGER)\n\n    # Set the objective: minimize total sugar intake\n    m.setObjective(10 * x_b + 8 * x_m, GRB.MINIMIZE)\n\n    # Add calorie constraint\n    m.addConstr(80 * x_b + 100 * x_m >= 4000, name=\"Calories\")\n    # Add potassium constraint\n    m.addConstr(20 * x_b + 15 * x_m >= 150, name=\"Potassium\")\n    # Add preference constraint (x_b >= 2 * x_m)\n    m.addConstr(x_b >= 2 * x_m, name=\"Preference\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the minimum sugar intake\n        return m.objVal\n    else:\n        # No feasible solution\n        return None\n\n# Example usage\nprint(optimize_gorilla_fruits())", "output_status": [], "success_count": 0, "success_confidence": 0, "fail_to_diagnose": 0, "fail_to_verify": 0, "retrieved_insights": [], "tag": [{"problem_domain": "Resource Allocation", "modeling_type": "MILP", "industry_sector": "Animal Care", "reason": "The problem involves allocating two types of fruits (resources) to meet nutritional requirements while minimizing sugar intake. The decision variables are integers, and the objective function and constraints are linear, classifying it as a Mixed-Integer Linear Program. The application sector is specific to animal feeding in a zoo context."}], "cluster": null, "prompt": "Below is an operations research question. First formulate the problem as an optimization problem. Then according to the formulated problem, write python code that uses 'gurobipy' to solve the optimization problem. You should write a complete python code that can be executed to solve the optimization problem.\n\nIMPORTANT: Your code should follow these requirements:\n1. Create a Gurobi model variable named 'model' (not 'm' or other names)\n2. Include all necessary imports and data setup\n3. Write the complete optimization code that can run independently\n4. Do NOT wrap everything in a function - write the code directly\n5. Make sure the model is created and optimized in the main execution flow\n6. The code should print the optimal objective value when solved successfully\n\nExample format:\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Data setup\ndata = {...}\n\n# Create model\nmodel = gp.Model(\"ProblemName\")\n\n# Decision variables\nx = model.addVars(...)\n\n# Objective\nmodel.setObjective(...)\n\n# Constraints\nmodel.addConstr(...)\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\nelse:\n    print(\"No optimal solution found\")\n```\n\n# Question:\nA zookeeper feeds a gorilla with bananas and mangoes. Each banana contains 80 calories, 20 grams of potassium, and 10 grams of sugar. Each mango contains 100 calories, 15 grams of potassium, and 8 grams of sugar.  The gorilla must consume at least 4000 calories and 150 grams of potassium. Since the gorilla prefers bananas, at most 33% of the fruits he eats can be mangoes. If excess sugar makes the gorilla aggressive, how many of each fruit should he consume to minimize his sugar intake?\n\n# Response:", "generated_output": "Below is the formulation and then the complete Python code using `gurobipy`.\n\n---\n\n## Optimization Model Formulation\n\nDecision variables  \n- \\( x_B \\ge 0 \\): number of bananas  \n- \\( x_M \\ge 0 \\): number of mangoes  \n\nObjective (minimize total sugar):  \n\\[\n\\min \\; Z = 10 x_B + 8 x_M\n\\]\n\nSubject to:\n\n1. Calorie requirement (at least 4000 calories):  \n\\[\n80 x_B + 100 x_M \\ge 4000\n\\]\n\n2. Potassium requirement (at least 150 grams):  \n\\[\n20 x_B + 15 x_M \\ge 150\n\\]\n\n3. Mango proportion constraint (at most 33% of fruits are mangoes):  \n\\[\nx_M \\le 0.33 (x_B + x_M)\n\\]\nThis can be rewritten as:\n\\[\nx_M \\le 0.33 x_B + 0.33 x_M \\\\\nx_M - 0.33 x_M \\le 0.33 x_B \\\\\n0.67 x_M \\le 0.33 x_B \\\\\n67 x_M \\le 33 x_B\n\\]\n\n4. Non-negativity:  \n\\[\nx_B \\ge 0,\\quad x_M \\ge 0\n\\]\n\n---\n\n## Complete Python Code (Gurobi)\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Create model\nmodel = gp.Model(\"GorillaDiet\")\n\n# Decision variables: number of bananas (xB) and mangoes (xM)\nxB = model.addVar(name=\"Bananas\", lb=0)\nxM = model.addVar(name=\"Mangoes\", lb=0)\n\n# Objective: minimize total sugar intake\n# Sugar: 10 g per banana, 8 g per mango\nmodel.setObjective(10 * xB + 8 * xM, GRB.MINIMIZE)\n\n# Constraints\n\n# 1) Calorie requirement: at least 4000 calories\n# 80 cal per banana, 100 cal per mango\nmodel.addConstr(80 * xB + 100 * xM >= 4000, name=\"CalorieRequirement\")\n\n# 2) Potassium requirement: at least 150 grams\n# 20 g per banana, 15 g per mango\nmodel.addConstr(20 * xB + 15 * xM >= 150, name=\"PotassiumRequirement\")\n\n# 3) Mango proportion: at most 33% of fruits can be mangoes\n# xM <= 0.33 * (xB + xM)  ->  67*xM <= 33*xB\nmodel.addConstr(67 * xM <= 33 * xB, name=\"MangoProportion\")\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value (minimum sugar): {model.objVal}\")\n    print(f\"Bananas: {xB.X}\")\n    print(f\"Mangoes: {xM.X}\")\nelse:\n    print(\"No optimal solution found\")\n```", "extracted_code": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create model\nmodel = gp.Model(\"GorillaDiet\")\n\n# Decision variables: number of bananas (xB) and mangoes (xM)\nxB = model.addVar(name=\"Bananas\", lb=0)\nxM = model.addVar(name=\"Mangoes\", lb=0)\n\n# Objective: minimize total sugar intake\n# Sugar: 10 g per banana, 8 g per mango\nmodel.setObjective(10 * xB + 8 * xM, GRB.MINIMIZE)\n\n# Constraints\n\n# 1) Calorie requirement: at least 4000 calories\n# 80 cal per banana, 100 cal per mango\nmodel.addConstr(80 * xB + 100 * xM >= 4000, name=\"CalorieRequirement\")\n\n# 2) Potassium requirement: at least 150 grams\n# 20 g per banana, 15 g per mango\nmodel.addConstr(20 * xB + 15 * xM >= 150, name=\"PotassiumRequirement\")\n\n# 3) Mango proportion: at most 33% of fruits can be mangoes\n# xM <= 0.33 * (xB + xM)  ->  67*xM <= 33*xB\nmodel.addConstr(67 * xM <= 33 * xB, name=\"MangoProportion\")\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value (minimum sugar): {model.objVal}\")\n    print(f\"Bananas: {xB.X}\")\n    print(f\"Mangoes: {xM.X}\")\nelse:\n    print(\"No optimal solution found\")", "execution_success": true, "mathematical_accuracy": true, "execution_result": "Execution Successful", "execution_best_solution": 431.40877598152423, "execution_state": "Execution Successful"}
{"task_id": "A149", "description": "A toy store hires seasonal and full-time volunteers to deliver gifts and gives them points for service. A seasonal volunteer can deliver 5 gifts and gets 2 points. A full-time volunteer can deliver 8 gifts and gets 5 points. The store can only give out 200 points. In addition, a maximum of 30% of the volunteers can be seasonal and at least 10 must be full-time. How many of each volunteer is needed to maximize the total number of gifts that can be delivered?", "ground_truth": 342.0, "formulation": null, "correct_program": "def optimize_volunteers():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"VolunteerOptimization\")\n\n    # Decision variables\n    S = m.addVar(vtype=GRB.INTEGER, name=\"Seasonal\")\n    F = m.addVar(vtype=GRB.INTEGER, name=\"FullTime\")\n\n    # Set objective: maximize total gifts\n    m.setObjective(5 * S + 8 * F, GRB.MAXIMIZE)\n\n    # Add constraints\n    # Points constraint\n    m.addConstr(2 * S + 5 * F <= 200, name=\"PointsLimit\")\n    # Seasonal volunteers limit (7S <= 3F)\n    m.addConstr(7 * S <= 3 * F, name=\"SeasonalLimit\")\n    # Minimum full-time volunteers\n    m.addConstr(F >= 10, name=\"MinFullTime\")\n    # Non-negativity is implicit in variable definitions\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the maximum total gifts delivered\n        return m.objVal\n    else:\n        # No feasible solution\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    max_gifts = optimize_volunteers()\n    if max_gifts is not None:\n        print(f\"Maximum Gifts Delivered: {max_gifts}\")\n    else:\n        print(\"No feasible solution found.\")", "output_status": [], "success_count": 0, "success_confidence": 0, "fail_to_diagnose": 0, "fail_to_verify": 0, "retrieved_insights": [], "tag": [{"problem_domain": "Resource Allocation", "modeling_type": "MILP", "industry_sector": "Retail", "reason": "The problem involves allocating two types of volunteers (resources) to maximize gifts delivered, subject to constraints on points, volunteer mix, and minimum full-time volunteers. Since decision variables (number of volunteers) must be integers and the objective and constraints are linear, it falls under Mixed-Integer Linear Programming. The context of a toy store delivering gifts places it in the retail sector."}], "cluster": null, "prompt": "Below is an operations research question. First formulate the problem as an optimization problem. Then according to the formulated problem, write python code that uses 'gurobipy' to solve the optimization problem. You should write a complete python code that can be executed to solve the optimization problem.\n\nIMPORTANT: Your code should follow these requirements:\n1. Create a Gurobi model variable named 'model' (not 'm' or other names)\n2. Include all necessary imports and data setup\n3. Write the complete optimization code that can run independently\n4. Do NOT wrap everything in a function - write the code directly\n5. Make sure the model is created and optimized in the main execution flow\n6. The code should print the optimal objective value when solved successfully\n\nExample format:\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Data setup\ndata = {...}\n\n# Create model\nmodel = gp.Model(\"ProblemName\")\n\n# Decision variables\nx = model.addVars(...)\n\n# Objective\nmodel.setObjective(...)\n\n# Constraints\nmodel.addConstr(...)\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\nelse:\n    print(\"No optimal solution found\")\n```\n\n# Question:\nA toy store hires seasonal and full-time volunteers to deliver gifts and gives them points for service. A seasonal volunteer can deliver 5 gifts and gets 2 points. A full-time volunteer can deliver 8 gifts and gets 5 points. The store can only give out 200 points. In addition, a maximum of 30% of the volunteers can be seasonal and at least 10 must be full-time. How many of each volunteer is needed to maximize the total number of gifts that can be delivered?\n\n# Response:", "generated_output": "Below is the formulation and then the complete Python code using `gurobipy`.\n\n---\n\n## Optimization Model Formulation\n\n**Decision variables**\n\n- \\( x_s \\): number of seasonal volunteers (integer, \\( x_s \\ge 0 \\))\n- \\( x_f \\): number of full-time volunteers (integer, \\( x_f \\ge 0 \\))\n\n**Objective**\n\nMaximize total number of gifts delivered:\n\\[\n\\max \\; Z = 5x_s + 8x_f\n\\]\n\n**Constraints**\n\n1. Points budget (store can only give out 200 points):\n\\[\n2x_s + 5x_f \\le 200\n\\]\n\n2. Seasonal volunteers are at most 30% of total volunteers:\n\\[\nx_s \\le 0.3(x_s + x_f)\n\\]\nRewriting:\n\\[\nx_s \\le 0.3x_s + 0.3x_f \\\\\n0.7x_s \\le 0.3x_f \\\\\n7x_s \\le 3x_f\n\\]\n\n3. At least 10 full-time volunteers:\n\\[\nx_f \\ge 10\n\\]\n\n4. Non-negativity and integrality:\n\\[\nx_s, x_f \\in \\mathbb{Z}_{\\ge 0}\n\\]\n\n---\n\n## Complete Python Code (Gurobi)\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Create model\nmodel = gp.Model(\"ToyStoreVolunteers\")\n\n# Decision variables\n# x_s: number of seasonal volunteers\n# x_f: number of full-time volunteers\nx_s = model.addVar(vtype=GRB.INTEGER, name=\"seasonal\")\nx_f = model.addVar(vtype=GRB.INTEGER, name=\"fulltime\")\n\n# Objective: maximize total gifts delivered = 5*x_s + 8*x_f\nmodel.setObjective(5 * x_s + 8 * x_f, GRB.MAXIMIZE)\n\n# Constraints\n\n# 1) Points budget: 2*x_s + 5*x_f <= 200\nmodel.addConstr(2 * x_s + 5 * x_f <= 200, name=\"points_budget\")\n\n# 2) Seasonal at most 30% of total: 7*x_s <= 3*x_f (rearranged form)\nmodel.addConstr(7 * x_s <= 3 * x_f, name=\"seasonal_ratio\")\n\n# 3) At least 10 full-time volunteers: x_f >= 10\nmodel.addConstr(x_f >= 10, name=\"min_fulltime\")\n\n# 4) Non-negativity is already enforced by default lower bound 0 for variables\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value (max gifts): {model.objVal}\")\n    print(f\"Seasonal volunteers: {int(x_s.X)}\")\n    print(f\"Full-time volunteers: {int(x_f.X)}\")\nelse:\n    print(\"No optimal solution found\")\n```", "extracted_code": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create model\nmodel = gp.Model(\"ToyStoreVolunteers\")\n\n# Decision variables\n# x_s: number of seasonal volunteers\n# x_f: number of full-time volunteers\nx_s = model.addVar(vtype=GRB.INTEGER, name=\"seasonal\")\nx_f = model.addVar(vtype=GRB.INTEGER, name=\"fulltime\")\n\n# Objective: maximize total gifts delivered = 5*x_s + 8*x_f\nmodel.setObjective(5 * x_s + 8 * x_f, GRB.MAXIMIZE)\n\n# Constraints\n\n# 1) Points budget: 2*x_s + 5*x_f <= 200\nmodel.addConstr(2 * x_s + 5 * x_f <= 200, name=\"points_budget\")\n\n# 2) Seasonal at most 30% of total: 7*x_s <= 3*x_f (rearranged form)\nmodel.addConstr(7 * x_s <= 3 * x_f, name=\"seasonal_ratio\")\n\n# 3) At least 10 full-time volunteers: x_f >= 10\nmodel.addConstr(x_f >= 10, name=\"min_fulltime\")\n\n# 4) Non-negativity is already enforced by default lower bound 0 for variables\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value (max gifts): {model.objVal}\")\n    print(f\"Seasonal volunteers: {int(x_s.X)}\")\n    print(f\"Full-time volunteers: {int(x_f.X)}\")\nelse:\n    print(\"No optimal solution found\")", "execution_success": true, "mathematical_accuracy": true, "execution_result": "Execution Successful", "execution_best_solution": 342.0, "execution_state": "Execution Successful"}
{"task_id": "A213", "description": "A restaurant has two combos available to their customers, an original and an experimental meal. The original meal typically generates 20 units of food waste and 45 units of wrapping waste and takes 10 minutes to cook. In comparison, the experimental meal generates 25 units of food waste and 35 units of wrapping waste and takes 15 minutes to cook. The restaurant can have at most 900 units of wrapping waste and can have at most 800 units of food waste as regulated by the government. How many of each combo should be pushed for by the waiting staff to minimize the cooking time?", "ground_truth": 0.0, "formulation": null, "correct_program": "def optimize_meals(\n    max_food_waste=800,\n    max_wrapping_waste=900,\n    time_original=10,\n    time_experimental=15,\n    food_waste_original=20,\n    food_waste_experimental=25,\n    wrapping_waste_original=45,\n    wrapping_waste_experimental=35\n):\n    import gurobipy as gp\n    from gurobipy import GRB\n\n    # Create a new model\n    model = gp.Model(\"RestaurantMealOptimization\")\n\n    # Decision variables: number of original and experimental meals\n    x = model.addVar(vtype=GRB.INTEGER, name=\"Original\")\n    y = model.addVar(vtype=GRB.INTEGER, name=\"Experimental\")\n\n    # Set objective: minimize total cooking time\n    model.setObjective(\n        time_original * x + time_experimental * y,\n        GRB.MINIMIZE\n    )\n\n    # Add waste constraints\n    model.addConstr(\n        food_waste_original * x + food_waste_experimental * y <= max_food_waste,\n        name=\"FoodWasteLimit\"\n    )\n    model.addConstr(\n        wrapping_waste_original * x + wrapping_waste_experimental * y <= max_wrapping_waste,\n        name=\"WrappingWasteLimit\"\n    )\n\n    # Set non-negativity constraints (implicit in variable definition)\n    # Solve the model\n    model.optimize()\n\n    # Check if a feasible solution was found\n    if model.status == GRB.OPTIMAL:\n        # Return the optimal total cooking time\n        return model.objVal\n    else:\n        # No feasible solution\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    min_time = optimize_meals()\n    if min_time is not None:\n        print(f\"Minimum Total Cooking Time: {min_time}\")\n    else:\n        print(\"No feasible solution found.\")", "output_status": [], "success_count": 0, "success_confidence": 0, "fail_to_diagnose": 0, "fail_to_verify": 0, "retrieved_insights": [], "tag": [{"problem_domain": "Resource Allocation", "modeling_type": "IP", "industry_sector": "Hospitality", "reason": "The problem involves allocating resources (food waste, wrapping waste) to produce different products (meals) to minimize an objective (cooking time). The decision variables (number of meals) must be integers, leading to an Integer Programming (IP) model. The application is clearly within the hospitality sector, specifically a restaurant."}], "cluster": null, "prompt": "Below is an operations research question. First formulate the problem as an optimization problem. Then according to the formulated problem, write python code that uses 'gurobipy' to solve the optimization problem. You should write a complete python code that can be executed to solve the optimization problem.\n\nIMPORTANT: Your code should follow these requirements:\n1. Create a Gurobi model variable named 'model' (not 'm' or other names)\n2. Include all necessary imports and data setup\n3. Write the complete optimization code that can run independently\n4. Do NOT wrap everything in a function - write the code directly\n5. Make sure the model is created and optimized in the main execution flow\n6. The code should print the optimal objective value when solved successfully\n\nExample format:\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Data setup\ndata = {...}\n\n# Create model\nmodel = gp.Model(\"ProblemName\")\n\n# Decision variables\nx = model.addVars(...)\n\n# Objective\nmodel.setObjective(...)\n\n# Constraints\nmodel.addConstr(...)\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\nelse:\n    print(\"No optimal solution found\")\n```\n\n# Question:\nA restaurant has two combos available to their customers, an original and an experimental meal. The original meal typically generates 20 units of food waste and 45 units of wrapping waste and takes 10 minutes to cook. In comparison, the experimental meal generates 25 units of food waste and 35 units of wrapping waste and takes 15 minutes to cook. The restaurant can have at most 900 units of wrapping waste and can have at most 800 units of food waste as regulated by the government. How many of each combo should be pushed for by the waiting staff to minimize the cooking time?\n\n# Response:", "generated_output": "Below is the formulation and then the complete Python code using `gurobipy`.\n\n---\n\n## Optimization Model Formulation\n\nDecision variables  \n- Let \\( x \\) = number of original meals to push  \n- Let \\( y \\) = number of experimental meals to push  \n\nObjective (minimize total cooking time)  \n\\[\n\\min \\; 10x + 15y\n\\]\n\nSubject to waste constraints:\n\nFood waste constraint (max 800 units):  \n\\[\n20x + 25y \\le 800\n\\]\n\nWrapping waste constraint (max 900 units):  \n\\[\n45x + 35y \\le 900\n\\]\n\nNon-negativity (and integrality if we assume whole meals):  \n\\[\nx \\ge 0,\\; y \\ge 0,\\; x, y \\in \\mathbb{Z}\n\\]\n\n---\n\n## Complete Python Code (Gurobi)\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Create model\nmodel = gp.Model(\"RestaurantMealPlanning\")\n\n# Decision variables: number of original (x) and experimental (y) meals\n# Assuming integer numbers of meals\nx = model.addVar(vtype=GRB.INTEGER, name=\"original_meals\")\ny = model.addVar(vtype=GRB.INTEGER, name=\"experimental_meals\")\n\n# Update model to integrate new variables\nmodel.update()\n\n# Objective: minimize total cooking time = 10x + 15y\nmodel.setObjective(10 * x + 15 * y, GRB.MINIMIZE)\n\n# Constraints\n\n# Food waste: 20x + 25y <= 800\nmodel.addConstr(20 * x + 25 * y <= 800, name=\"food_waste_limit\")\n\n# Wrapping waste: 45x + 35y <= 900\nmodel.addConstr(45 * x + 35 * y <= 900, name=\"wrapping_waste_limit\")\n\n# Non-negativity is already enforced by default lower bound 0 on variables\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value (minimum total cooking time): {model.objVal}\")\n    print(f\"Optimal number of original meals (x): {x.X}\")\n    print(f\"Optimal number of experimental meals (y): {y.X}\")\nelse:\n    print(\"No optimal solution found\")\n```", "extracted_code": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create model\nmodel = gp.Model(\"RestaurantMealPlanning\")\n\n# Decision variables: number of original (x) and experimental (y) meals\n# Assuming integer numbers of meals\nx = model.addVar(vtype=GRB.INTEGER, name=\"original_meals\")\ny = model.addVar(vtype=GRB.INTEGER, name=\"experimental_meals\")\n\n# Update model to integrate new variables\nmodel.update()\n\n# Objective: minimize total cooking time = 10x + 15y\nmodel.setObjective(10 * x + 15 * y, GRB.MINIMIZE)\n\n# Constraints\n\n# Food waste: 20x + 25y <= 800\nmodel.addConstr(20 * x + 25 * y <= 800, name=\"food_waste_limit\")\n\n# Wrapping waste: 45x + 35y <= 900\nmodel.addConstr(45 * x + 35 * y <= 900, name=\"wrapping_waste_limit\")\n\n# Non-negativity is already enforced by default lower bound 0 on variables\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value (minimum total cooking time): {model.objVal}\")\n    print(f\"Optimal number of original meals (x): {x.X}\")\n    print(f\"Optimal number of experimental meals (y): {y.X}\")\nelse:\n    print(\"No optimal solution found\")", "execution_success": true, "mathematical_accuracy": true, "execution_result": "Execution Successful", "execution_best_solution": 0.0, "execution_state": "Execution Successful"}
{"task_id": "A218", "description": "A candle-making company can move their inventory of candles using freight and air. Freight can transport 5 tons per trip while using air can transport 3 tons per trip. Since freight take longer, the cost for each freight trip is $300 while the cost over air for each trip is $550. The company needs to transport at least 200 tons of candles and they have a budget of $20000. Additionally, due to some urgent orders, at least 30% of tons of candles must be transported through air. There must also be at least 5 trips through freight. How many of trip by each should be scheduled to minimize the total number of trips?", "ground_truth": 48.0, "formulation": null, "correct_program": "def optimize_candle_transport():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"Candle_Transport\")\n\n    # Decision variables\n    # Number of freight trips (F), at least 5\n    F = m.addVar(vtype=GRB.INTEGER, name=\"F\", lb=5)\n    # Number of air trips (A), at least 0\n    A = m.addVar(vtype=GRB.INTEGER, name=\"A\", lb=0)\n\n    # Set objective: minimize total trips\n    m.setObjective(F + A, GRB.MINIMIZE)\n\n    # Add constraints\n    # Total tons transported\n    m.addConstr(5 * F + 3 * A >= 200, name=\"TotalTons\")\n    # Budget constraint\n    m.addConstr(300 * F + 550 * A <= 20000, name=\"Budget\")\n    # Air transportation proportion constraint\n    # A >= (1.5/2.1)*F\n    m.addConstr(A >= (1.5 / 2.1) * F, name=\"AirProportion\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        total_trips = m.objVal\n        return total_trips\n    else:\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    min_trips = optimize_candle_transport()\n    if min_trips is not None:\n        print(f\"Minimum Total Trips (Freight + Air): {min_trips}\")\n    else:\n        print(\"No feasible solution found.\")", "output_status": [], "success_count": 0, "success_confidence": 0, "fail_to_diagnose": 0, "fail_to_verify": 0, "retrieved_insights": [], "tag": [{"problem_domain": "Resource Allocation", "modeling_type": "MILP", "industry_sector": "Logistics", "reason": "The problem involves allocating resources (freight and air trips) to transport candles while satisfying various constraints (total tons, budget, air proportion, minimum freight trips) and minimizing the total number of trips. The solver uses integer variables and linear constraints, making it a Mixed-Integer Linear Program."}], "cluster": null, "prompt": "Below is an operations research question. First formulate the problem as an optimization problem. Then according to the formulated problem, write python code that uses 'gurobipy' to solve the optimization problem. You should write a complete python code that can be executed to solve the optimization problem.\n\nIMPORTANT: Your code should follow these requirements:\n1. Create a Gurobi model variable named 'model' (not 'm' or other names)\n2. Include all necessary imports and data setup\n3. Write the complete optimization code that can run independently\n4. Do NOT wrap everything in a function - write the code directly\n5. Make sure the model is created and optimized in the main execution flow\n6. The code should print the optimal objective value when solved successfully\n\nExample format:\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Data setup\ndata = {...}\n\n# Create model\nmodel = gp.Model(\"ProblemName\")\n\n# Decision variables\nx = model.addVars(...)\n\n# Objective\nmodel.setObjective(...)\n\n# Constraints\nmodel.addConstr(...)\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\nelse:\n    print(\"No optimal solution found\")\n```\n\n# Question:\nA candle-making company can move their inventory of candles using freight and air. Freight can transport 5 tons per trip while using air can transport 3 tons per trip. Since freight take longer, the cost for each freight trip is $300 while the cost over air for each trip is $550. The company needs to transport at least 200 tons of candles and they have a budget of $20000. Additionally, due to some urgent orders, at least 30% of tons of candles must be transported through air. There must also be at least 5 trips through freight. How many of trip by each should be scheduled to minimize the total number of trips?\n\n# Response:", "generated_output": "Below is the formulation and then the complete Python code using `gurobipy`.\n\n---\n\n## Optimization Model Formulation\n\n**Decision variables**\n\n- \\( x \\): number of freight trips (integer, \\( x \\ge 0 \\))\n- \\( y \\): number of air trips (integer, \\( y \\ge 0 \\))\n\n**Parameters**\n\n- Freight capacity per trip: 5 tons\n- Air capacity per trip: 3 tons\n- Freight cost per trip: 300\n- Air cost per trip: 550\n- Required tons: at least 200\n- Budget: at most 20000\n- At least 30% of tons via air\n- At least 5 freight trips\n\n**Objective**\n\nMinimize total number of trips:\n\\[\n\\min \\; x + y\n\\]\n\n**Constraints**\n\n1. Capacity (tons transported):\n\\[\n5x + 3y \\ge 200\n\\]\n\n2. Budget:\n\\[\n300x + 550y \\le 20000\n\\]\n\n3. At least 30% of tons via air:\n\nTons via air = \\(3y\\), total tons = \\(5x + 3y\\)\n\n\\[\n\\frac{3y}{5x + 3y} \\ge 0.3\n\\]\n\nMultiply both sides by \\(5x + 3y\\) (positive since we must meet 200 tons):\n\n\\[\n3y \\ge 0.3(5x + 3y)\n\\]\n\\[\n3y \\ge 1.5x + 0.9y\n\\]\n\\[\n3y - 0.9y \\ge 1.5x\n\\]\n\\[\n2.1y \\ge 1.5x\n\\]\n\\[\n21y \\ge 15x\n\\]\n\nWe can keep it as:\n\\[\n21y - 15x \\ge 0\n\\]\n\n4. Minimum freight trips:\n\\[\nx \\ge 5\n\\]\n\n5. Integrality:\n\\[\nx, y \\in \\mathbb{Z}_{\\ge 0}\n\\]\n\n---\n\n## Complete Python Code (Gurobi)\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Create model\nmodel = gp.Model(\"CandleTransport\")\n\n# Decision variables\n# x: number of freight trips\n# y: number of air trips\nx = model.addVar(vtype=GRB.INTEGER, name=\"freight_trips\")\ny = model.addVar(vtype=GRB.INTEGER, name=\"air_trips\")\n\n# Objective: minimize total number of trips\nmodel.setObjective(x + y, GRB.MINIMIZE)\n\n# Constraints\n\n# 1) Capacity: 5x + 3y >= 200\nmodel.addConstr(5 * x + 3 * y >= 200, name=\"capacity\")\n\n# 2) Budget: 300x + 550y <= 20000\nmodel.addConstr(300 * x + 550 * y <= 20000, name=\"budget\")\n\n# 3) At least 30% of tons via air:\n#    3y / (5x + 3y) >= 0.3  ->  21y - 15x >= 0\nmodel.addConstr(21 * y - 15 * x >= 0, name=\"air_share\")\n\n# 4) At least 5 freight trips: x >= 5\nmodel.addConstr(x >= 5, name=\"min_freight_trips\")\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value (minimum total trips): {model.objVal}\")\n    print(f\"Freight trips (x): {x.X}\")\n    print(f\"Air trips (y): {y.X}\")\nelse:\n    print(\"No optimal solution found\")\n```", "extracted_code": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create model\nmodel = gp.Model(\"CandleTransport\")\n\n# Decision variables\n# x: number of freight trips\n# y: number of air trips\nx = model.addVar(vtype=GRB.INTEGER, name=\"freight_trips\")\ny = model.addVar(vtype=GRB.INTEGER, name=\"air_trips\")\n\n# Objective: minimize total number of trips\nmodel.setObjective(x + y, GRB.MINIMIZE)\n\n# Constraints\n\n# 1) Capacity: 5x + 3y >= 200\nmodel.addConstr(5 * x + 3 * y >= 200, name=\"capacity\")\n\n# 2) Budget: 300x + 550y <= 20000\nmodel.addConstr(300 * x + 550 * y <= 20000, name=\"budget\")\n\n# 3) At least 30% of tons via air:\n#    3y / (5x + 3y) >= 0.3  ->  21y - 15x >= 0\nmodel.addConstr(21 * y - 15 * x >= 0, name=\"air_share\")\n\n# 4) At least 5 freight trips: x >= 5\nmodel.addConstr(x >= 5, name=\"min_freight_trips\")\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value (minimum total trips): {model.objVal}\")\n    print(f\"Freight trips (x): {x.X}\")\n    print(f\"Air trips (y): {y.X}\")\nelse:\n    print(\"No optimal solution found\")", "execution_success": true, "mathematical_accuracy": true, "execution_result": "Execution Successful", "execution_best_solution": 48.0, "execution_state": "Execution Successful"}
{"task_id": "A185", "description": "A fashion company sells regular handbags and premium handbags made of higher quality material. They can sell regular handbags at a profit of $30 each and premium handbags at a profit of $180 each. The total monthly cost of manufacturing is $200 per regular handbag and $447 per premium handbag. The company has a total budget of $250000 and can sell at most 475 handbags of either type per month. How many of each handbag should they sell to maximize its monthly profit?", "ground_truth": 85500.0, "formulation": null, "correct_program": "def optimize_handbags(\n    profit_regular=30,\n    profit_premium=180,\n    cost_regular=200,\n    cost_premium=447,\n    total_budget=250000,\n    max_total_handbags=475\n):\n    import gurobipy as gp\n    from gurobipy import GRB\n\n    # Create a new model\n    model = gp.Model(\"Handbag_Production_Optimization\")\n\n    # Decision variables: number of regular and premium handbags\n    x = model.addVar(vtype=GRB.INTEGER, name=\"Regular_Handbags\", lb=0)\n    y = model.addVar(vtype=GRB.INTEGER, name=\"Premium_Handbags\", lb=0)\n\n    # Set objective: maximize profit\n    model.setObjective(profit_regular * x + profit_premium * y, GRB.MAXIMIZE)\n\n    # Add budget constraint\n    model.addConstr(cost_regular * x + cost_premium * y <= total_budget, \"BudgetConstraint\")\n\n    # Add total handbags constraint\n    model.addConstr(x + y <= max_total_handbags, \"TotalHandbagsConstraint\")\n\n    # Optimize the model\n    model.optimize()\n\n    # Check if a feasible solution was found\n    if model.status == GRB.OPTIMAL:\n        # Return the maximum profit\n        return model.objVal\n    else:\n        # No feasible solution found\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    max_profit = optimize_handbags()\n    if max_profit is not None:\n        print(f\"Maximum Profit: ${max_profit}\")\n    else:\n        print(\"No feasible solution found.\")", "output_status": [], "success_count": 0, "success_confidence": 0, "fail_to_diagnose": 0, "fail_to_verify": 0, "retrieved_insights": [], "tag": [{"problem_domain": "Resource Allocation", "modeling_type": "IP", "industry_sector": "Manufacturing", "reason": "The problem involves allocating limited resources (budget, total production capacity) to maximize profit from producing two types of handbags. The decision variables (number of handbags) must be integers, leading to an Integer Programming (IP) model. The application is clearly within the manufacturing sector, specifically fashion manufacturing."}], "cluster": null, "prompt": "Below is an operations research question. First formulate the problem as an optimization problem. Then according to the formulated problem, write python code that uses 'gurobipy' to solve the optimization problem. You should write a complete python code that can be executed to solve the optimization problem.\n\nIMPORTANT: Your code should follow these requirements:\n1. Create a Gurobi model variable named 'model' (not 'm' or other names)\n2. Include all necessary imports and data setup\n3. Write the complete optimization code that can run independently\n4. Do NOT wrap everything in a function - write the code directly\n5. Make sure the model is created and optimized in the main execution flow\n6. The code should print the optimal objective value when solved successfully\n\nExample format:\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Data setup\ndata = {...}\n\n# Create model\nmodel = gp.Model(\"ProblemName\")\n\n# Decision variables\nx = model.addVars(...)\n\n# Objective\nmodel.setObjective(...)\n\n# Constraints\nmodel.addConstr(...)\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\nelse:\n    print(\"No optimal solution found\")\n```\n\n# Question:\nA fashion company sells regular handbags and premium handbags made of higher quality material. They can sell regular handbags at a profit of $30 each and premium handbags at a profit of $180 each. The total monthly cost of manufacturing is $200 per regular handbag and $447 per premium handbag. The company has a total budget of $250000 and can sell at most 475 handbags of either type per month. How many of each handbag should they sell to maximize its monthly profit?\n\n# Response:", "generated_output": "Below is the formulation and then the complete Python code using `gurobipy`.\n\n---\n\n## Optimization Model Formulation\n\n**Decision variables**\n\n- \\( x \\): number of regular handbags to sell (integer, \\( x \\ge 0 \\))\n- \\( y \\): number of premium handbags to sell (integer, \\( y \\ge 0 \\))\n\n**Objective**\n\nMaximize total monthly profit:\n\\[\n\\max \\; 30x + 180y\n\\]\n\n**Constraints**\n\n1. **Budget constraint (manufacturing cost):**\n   \\[\n   200x + 447y \\le 250000\n   \\]\n\n2. **Sales capacity constraint:**\n   \\[\n   x + y \\le 475\n   \\]\n\n3. **Non-negativity and integrality:**\n   \\[\n   x, y \\in \\mathbb{Z}_{\\ge 0}\n   \\]\n\n---\n\n## Complete Python Code (Gurobi)\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Data setup\nprofit_regular = 30\nprofit_premium = 180\n\ncost_regular = 200\ncost_premium = 447\n\nbudget = 250000\nmax_total_handbags = 475\n\n# Create model\nmodel = gp.Model(\"Handbag_Production\")\n\n# Decision variables: number of regular (x) and premium (y) handbags\n# Assuming they must be integer quantities\nx = model.addVar(vtype=GRB.INTEGER, name=\"regular\")\ny = model.addVar(vtype=GRB.INTEGER, name=\"premium\")\n\n# Set objective: maximize profit = 30x + 180y\nmodel.setObjective(profit_regular * x + profit_premium * y, GRB.MAXIMIZE)\n\n# Constraints\n\n# 1) Budget constraint: 200x + 447y <= 250000\nmodel.addConstr(cost_regular * x + cost_premium * y <= budget, name=\"Budget\")\n\n# 2) Sales capacity: x + y <= 475\nmodel.addConstr(x + y <= max_total_handbags, name=\"Capacity\")\n\n# 3) Non-negativity is already enforced by default lower bound 0\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\n    print(f\"Regular handbags (x): {int(x.X)}\")\n    print(f\"Premium handbags (y): {int(y.X)}\")\nelse:\n    print(\"No optimal solution found\")\n```", "extracted_code": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Data setup\nprofit_regular = 30\nprofit_premium = 180\n\ncost_regular = 200\ncost_premium = 447\n\nbudget = 250000\nmax_total_handbags = 475\n\n# Create model\nmodel = gp.Model(\"Handbag_Production\")\n\n# Decision variables: number of regular (x) and premium (y) handbags\n# Assuming they must be integer quantities\nx = model.addVar(vtype=GRB.INTEGER, name=\"regular\")\ny = model.addVar(vtype=GRB.INTEGER, name=\"premium\")\n\n# Set objective: maximize profit = 30x + 180y\nmodel.setObjective(profit_regular * x + profit_premium * y, GRB.MAXIMIZE)\n\n# Constraints\n\n# 1) Budget constraint: 200x + 447y <= 250000\nmodel.addConstr(cost_regular * x + cost_premium * y <= budget, name=\"Budget\")\n\n# 2) Sales capacity: x + y <= 475\nmodel.addConstr(x + y <= max_total_handbags, name=\"Capacity\")\n\n# 3) Non-negativity is already enforced by default lower bound 0\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\n    print(f\"Regular handbags (x): {int(x.X)}\")\n    print(f\"Premium handbags (y): {int(y.X)}\")\nelse:\n    print(\"No optimal solution found\")", "execution_success": true, "mathematical_accuracy": true, "execution_result": "Execution Successful", "execution_best_solution": 85500.0, "execution_state": "Execution Successful"}
{"task_id": "A041", "description": "A new fast food place makes wraps and platters. Each wrap requires 5 units of meat and 3 units of rice. Each platter requires 7 units of meant and 5 units of rice. While each wrap takes 10 minutes to make, each platter takes 8 minutes to make. The fast food place must use at least 3000 units of meat and 2500 units of rice. Since wraps are easier to eat on the go, at least 3 times as many wraps need to be made as platter. How many of each should the fast food place make to minimize the total production time?", "ground_truth": 6794.0, "formulation": null, "correct_program": "def optimize_wraps_and_platters():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"FastFoodProduction\")\n\n    # Decision variables: number of wraps (x) and platters (y)\n    x = m.addVar(vtype=GRB.INTEGER, name=\"wraps\", lb=0)\n    y = m.addVar(vtype=GRB.INTEGER, name=\"platters\", lb=0)\n\n    # Set objective: minimize total production time\n    m.setObjective(10 * x + 8 * y, GRB.MINIMIZE)\n\n    # Add resource constraints\n    m.addConstr(5 * x + 7 * y >= 3000, name=\"meat_constraint\")\n    m.addConstr(3 * x + 5 * y >= 2500, name=\"rice_constraint\")\n\n    # Add production ratio constraint\n    m.addConstr(x - 3 * y >= 0, name=\"wraps_vs_platters\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the optimal total production time\n        return m.objVal\n    else:\n        # No feasible solution found\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    min_time = optimize_wraps_and_platters()\n    if min_time is not None:\n        print(f\"Minimum Total Production Time: {min_time}\")\n    else:\n        print(\"No feasible solution found.\")", "output_status": [], "success_count": 0, "success_confidence": 0, "fail_to_diagnose": 0, "fail_to_verify": 0, "retrieved_insights": [], "tag": [{"problem_domain": "Production Planning", "modeling_type": "IP", "industry_sector": "Food Service", "reason": "The problem involves determining the optimal quantities of two products (wraps and platters) to produce given resource constraints (meat, rice, and production time) and a production ratio, which is characteristic of Production Planning. The decision variables (number of wraps and platters) must be integers, and the objective function and constraints are linear, making it an Integer Program (IP). The application is clearly within the Food Service industry, specifically a fast food establishment."}], "cluster": null, "prompt": "Below is an operations research question. First formulate the problem as an optimization problem. Then according to the formulated problem, write python code that uses 'gurobipy' to solve the optimization problem. You should write a complete python code that can be executed to solve the optimization problem.\n\nIMPORTANT: Your code should follow these requirements:\n1. Create a Gurobi model variable named 'model' (not 'm' or other names)\n2. Include all necessary imports and data setup\n3. Write the complete optimization code that can run independently\n4. Do NOT wrap everything in a function - write the code directly\n5. Make sure the model is created and optimized in the main execution flow\n6. The code should print the optimal objective value when solved successfully\n\nExample format:\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Data setup\ndata = {...}\n\n# Create model\nmodel = gp.Model(\"ProblemName\")\n\n# Decision variables\nx = model.addVars(...)\n\n# Objective\nmodel.setObjective(...)\n\n# Constraints\nmodel.addConstr(...)\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\nelse:\n    print(\"No optimal solution found\")\n```\n\n# Question:\nA new fast food place makes wraps and platters. Each wrap requires 5 units of meat and 3 units of rice. Each platter requires 7 units of meant and 5 units of rice. While each wrap takes 10 minutes to make, each platter takes 8 minutes to make. The fast food place must use at least 3000 units of meat and 2500 units of rice. Since wraps are easier to eat on the go, at least 3 times as many wraps need to be made as platter. How many of each should the fast food place make to minimize the total production time?\n\n# Response:", "generated_output": "Below is the formulation and then the complete Python code using `gurobipy`.\n\n---\n\n## Optimization Model Formulation\n\n**Decision variables**\n\n- \\( x \\): number of wraps to make (continuous, \\( x \\ge 0 \\))\n- \\( y \\): number of platters to make (continuous, \\( y \\ge 0 \\))\n\n**Objective**\n\nMinimize total production time (in minutes):\n\n\\[\n\\min \\; Z = 10x + 8y\n\\]\n\n**Constraints**\n\n1. Meat usage (at least 3000 units):\n\\[\n5x + 7y \\ge 3000\n\\]\n\n2. Rice usage (at least 2500 units):\n\\[\n3x + 5y \\ge 2500\n\\]\n\n3. Wraps at least 3 times platters:\n\\[\nx \\ge 3y\n\\]\n\n4. Non-negativity:\n\\[\nx \\ge 0,\\quad y \\ge 0\n\\]\n\n---\n\n## Python Code with Gurobi\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Create model\nmodel = gp.Model(\"FastFoodWrapsPlatters\")\n\n# Decision variables: number of wraps (x) and platters (y)\n# Assuming they can be fractional; use vtype=GRB.INTEGER if they must be integers\nx = model.addVar(name=\"wraps\", lb=0.0)\ny = model.addVar(name=\"platters\", lb=0.0)\n\n# Update model to integrate new variables\nmodel.update()\n\n# Objective: minimize total production time\n# 10 minutes per wrap, 8 minutes per platter\nmodel.setObjective(10 * x + 8 * y, GRB.MINIMIZE)\n\n# Constraints\n\n# Meat constraint: 5x + 7y >= 3000\nmodel.addConstr(5 * x + 7 * y >= 3000, name=\"meat_requirement\")\n\n# Rice constraint: 3x + 5y >= 2500\nmodel.addConstr(3 * x + 5 * y >= 2500, name=\"rice_requirement\")\n\n# Wraps at least 3 times platters: x >= 3y\nmodel.addConstr(x >= 3 * y, name=\"wraps_vs_platters\")\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value (minimum total time): {model.objVal}\")\n    print(f\"Optimal number of wraps (x): {x.X}\")\n    print(f\"Optimal number of platters (y): {y.X}\")\nelse:\n    print(\"No optimal solution found\")\n```", "extracted_code": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create model\nmodel = gp.Model(\"FastFoodWrapsPlatters\")\n\n# Decision variables: number of wraps (x) and platters (y)\n# Assuming they can be fractional; use vtype=GRB.INTEGER if they must be integers\nx = model.addVar(name=\"wraps\", lb=0.0)\ny = model.addVar(name=\"platters\", lb=0.0)\n\n# Update model to integrate new variables\nmodel.update()\n\n# Objective: minimize total production time\n# 10 minutes per wrap, 8 minutes per platter\nmodel.setObjective(10 * x + 8 * y, GRB.MINIMIZE)\n\n# Constraints\n\n# Meat constraint: 5x + 7y >= 3000\nmodel.addConstr(5 * x + 7 * y >= 3000, name=\"meat_requirement\")\n\n# Rice constraint: 3x + 5y >= 2500\nmodel.addConstr(3 * x + 5 * y >= 2500, name=\"rice_requirement\")\n\n# Wraps at least 3 times platters: x >= 3y\nmodel.addConstr(x >= 3 * y, name=\"wraps_vs_platters\")\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value (minimum total time): {model.objVal}\")\n    print(f\"Optimal number of wraps (x): {x.X}\")\n    print(f\"Optimal number of platters (y): {y.X}\")\nelse:\n    print(\"No optimal solution found\")", "execution_success": true, "mathematical_accuracy": true, "execution_result": "Execution Successful", "execution_best_solution": 6785.714285714285, "execution_state": "Execution Successful"}
{"task_id": "A052", "description": "A laundromat can buy two types of washing machines, a top-loading model and a front-loading model. The top-loading model can wash 50 items per day while the front-loading model can wash 75 items per day. The top-loading model consumes 85 kWh per day while the front-loading model consumes 100 kWh per day. The laundromat must be able to wash at least 5000 items per day and has available 7000 kWh per day. Since the top-loading machine are harder to use, at most 40% of the machines can be top-loading. Further, at least 10 machines should be front-loading. How many of each machine should the laundromat buy to minimize the total number of washing machines?", "ground_truth": 67.0, "formulation": null, "correct_program": "def optimize_washing_machines():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"Laundromat Machine Optimization\")\n    \n    # Decision variables: number of machines\n    x = m.addVar(vtype=GRB.INTEGER, name=\"TopLoading\")\n    y = m.addVar(vtype=GRB.INTEGER, name=\"FrontLoading\")\n    \n    # Set the objective: minimize total number of machines\n    m.setObjective(x + y, GRB.MINIMIZE)\n    \n    # Add constraints\n    # Washing capacity constraint\n    m.addConstr(50 * x + 75 * y >= 5000, \"WashingCapacity\")\n    # Energy consumption constraint\n    m.addConstr(85 * x + 100 * y <= 7000, \"EnergyLimit\")\n    # Top-loading proportion constraint (transformed to linear form)\n    m.addConstr(3 * x <= 2 * y, \"TopLoadingProportion\")\n    # Minimum front-loading machines\n    m.addConstr(y >= 10, \"MinFrontLoading\")\n    # Non-negativity is implicit in variable definition\n    \n    # Optimize the model\n    m.optimize()\n    \n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the optimal total number of machines\n        return m.objVal\n    else:\n        # No feasible solution\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    min_machines = optimize_washing_machines()\n    if min_machines is not None:\n        print(f\"Minimum Total Number of Machines: {min_machines}\")\n    else:\n        print(\"No feasible solution found.\")", "output_status": [], "success_count": 0, "success_confidence": 0, "fail_to_diagnose": 0, "fail_to_verify": 0, "retrieved_insights": [], "tag": [{"problem_domain": "Resource Allocation", "modeling_type": "MILP", "industry_sector": "Service", "reason": "The problem involves allocating a limited budget of resources (washing capacity, energy, and machine types) to minimize the total number of machines. The solver uses integer variables and linear constraints, making it a Mixed-Integer Linear Program."}], "cluster": null, "prompt": "Below is an operations research question. First formulate the problem as an optimization problem. Then according to the formulated problem, write python code that uses 'gurobipy' to solve the optimization problem. You should write a complete python code that can be executed to solve the optimization problem.\n\nIMPORTANT: Your code should follow these requirements:\n1. Create a Gurobi model variable named 'model' (not 'm' or other names)\n2. Include all necessary imports and data setup\n3. Write the complete optimization code that can run independently\n4. Do NOT wrap everything in a function - write the code directly\n5. Make sure the model is created and optimized in the main execution flow\n6. The code should print the optimal objective value when solved successfully\n\nExample format:\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Data setup\ndata = {...}\n\n# Create model\nmodel = gp.Model(\"ProblemName\")\n\n# Decision variables\nx = model.addVars(...)\n\n# Objective\nmodel.setObjective(...)\n\n# Constraints\nmodel.addConstr(...)\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\nelse:\n    print(\"No optimal solution found\")\n```\n\n# Question:\nA laundromat can buy two types of washing machines, a top-loading model and a front-loading model. The top-loading model can wash 50 items per day while the front-loading model can wash 75 items per day. The top-loading model consumes 85 kWh per day while the front-loading model consumes 100 kWh per day. The laundromat must be able to wash at least 5000 items per day and has available 7000 kWh per day. Since the top-loading machine are harder to use, at most 40% of the machines can be top-loading. Further, at least 10 machines should be front-loading. How many of each machine should the laundromat buy to minimize the total number of washing machines?\n\n# Response:", "generated_output": "Below is the mathematical formulation followed by complete Python code using `gurobipy`.\n\n---\n\n## Optimization Model\n\n**Decision variables**\n\n- \\( x_T \\ge 0 \\): number of top-loading machines (integer)\n- \\( x_F \\ge 0 \\): number of front-loading machines (integer)\n\n**Objective**\n\nMinimize total number of machines:\n\\[\n\\min \\; x_T + x_F\n\\]\n\n**Constraints**\n\n1. Washing capacity (items per day):\n\\[\n50 x_T + 75 x_F \\ge 5000\n\\]\n\n2. Energy consumption (kWh per day):\n\\[\n85 x_T + 100 x_F \\le 7000\n\\]\n\n3. At most 40% of machines are top-loading:\n\\[\nx_T \\le 0.4(x_T + x_F)\n\\]\nThis can be rewritten as:\n\\[\n0.6 x_T \\le 0.4 x_F \\quad \\Rightarrow \\quad 3 x_T \\le 2 x_F\n\\]\n\n4. At least 10 front-loading machines:\n\\[\nx_F \\ge 10\n\\]\n\n5. Integrality:\n\\[\nx_T, x_F \\in \\mathbb{Z}_{\\ge 0}\n\\]\n\n---\n\n## Gurobi Python Code\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Create model\nmodel = gp.Model(\"Laundromat_Machine_Selection\")\n\n# Decision variables: number of top-loading (xT) and front-loading (xF) machines\nxT = model.addVar(vtype=GRB.INTEGER, name=\"TopLoading\")\nxF = model.addVar(vtype=GRB.INTEGER, name=\"FrontLoading\")\n\n# Set objective: minimize total number of machines\nmodel.setObjective(xT + xF, GRB.MINIMIZE)\n\n# Constraints\n\n# 1. Washing capacity: 50 xT + 75 xF >= 5000\nmodel.addConstr(50 * xT + 75 * xF >= 5000, name=\"Capacity\")\n\n# 2. Energy consumption: 85 xT + 100 xF <= 7000\nmodel.addConstr(85 * xT + 100 * xF <= 7000, name=\"Energy\")\n\n# 3. At most 40% of machines are top-loading: 3 xT <= 2 xF\nmodel.addConstr(3 * xT <= 2 * xF, name=\"TopLoadingShare\")\n\n# 4. At least 10 front-loading machines: xF >= 10\nmodel.addConstr(xF >= 10, name=\"MinFrontLoading\")\n\n# 5. Non-negativity (implicitly enforced by lower bound 0)\nxT.lb = 0\nxF.lb = 0\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value (minimum number of machines): {model.objVal}\")\n    print(f\"Top-loading machines (xT): {xT.X}\")\n    print(f\"Front-loading machines (xF): {xF.X}\")\nelse:\n    print(\"No optimal solution found\")\n```", "extracted_code": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create model\nmodel = gp.Model(\"Laundromat_Machine_Selection\")\n\n# Decision variables: number of top-loading (xT) and front-loading (xF) machines\nxT = model.addVar(vtype=GRB.INTEGER, name=\"TopLoading\")\nxF = model.addVar(vtype=GRB.INTEGER, name=\"FrontLoading\")\n\n# Set objective: minimize total number of machines\nmodel.setObjective(xT + xF, GRB.MINIMIZE)\n\n# Constraints\n\n# 1. Washing capacity: 50 xT + 75 xF >= 5000\nmodel.addConstr(50 * xT + 75 * xF >= 5000, name=\"Capacity\")\n\n# 2. Energy consumption: 85 xT + 100 xF <= 7000\nmodel.addConstr(85 * xT + 100 * xF <= 7000, name=\"Energy\")\n\n# 3. At most 40% of machines are top-loading: 3 xT <= 2 xF\nmodel.addConstr(3 * xT <= 2 * xF, name=\"TopLoadingShare\")\n\n# 4. At least 10 front-loading machines: xF >= 10\nmodel.addConstr(xF >= 10, name=\"MinFrontLoading\")\n\n# 5. Non-negativity (implicitly enforced by lower bound 0)\nxT.lb = 0\nxF.lb = 0\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value (minimum number of machines): {model.objVal}\")\n    print(f\"Top-loading machines (xT): {xT.X}\")\n    print(f\"Front-loading machines (xF): {xF.X}\")\nelse:\n    print(\"No optimal solution found\")", "execution_success": true, "mathematical_accuracy": true, "execution_result": "Execution Successful", "execution_best_solution": 67.0, "execution_state": "Execution Successful"}
{"task_id": "A105", "description": "A woman eats cashews and almonds to get her calorie and protein intake. A serving of almonds contains 200 calories and 20 grams of protein. A serving of cashews contains 300 calories and 25 grams of protein. The woman decides to eat at least twice as many servings of almonds as cashews. Furthermore, a serving of almonds contains 15 grams of fat while a serving of cashews contains 12 grams of fat. If the woman needs to consume at least 10000 calories and 800 grams of protein this week, how many servings of each should she eat to minimize her fat intake?", "ground_truth": 600.0, "formulation": null, "correct_program": "def optimize_nut_intake():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"nut_intake_min_fat\")\n\n    # Decision variables: servings of almonds and cashews\n    x_A = m.addVar(name=\"almond_servings\", lb=0)\n    x_C = m.addVar(name=\"cashew_servings\", lb=0)\n\n    # Set the objective: minimize total fat intake\n    m.setObjective(15 * x_A + 12 * x_C, GRB.MINIMIZE)\n\n    # Add constraints\n    # Calorie constraint\n    m.addConstr(200 * x_A + 300 * x_C >= 10000, name=\"calories\")\n    # Protein constraint\n    m.addConstr(20 * x_A + 25 * x_C >= 800, name=\"protein\")\n    # Servings ratio constraint\n    m.addConstr(x_A >= 2 * x_C, name=\"ratio\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the optimal value of the objective function\n        return m.objVal\n    else:\n        # No feasible solution found\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    min_fat = optimize_nut_intake()\n    if min_fat is not None:\n        print(f\"Minimum Total Fat Intake: {min_fat}\")\n    else:\n        print(\"No feasible solution found.\")", "output_status": [], "success_count": 0, "success_confidence": 0, "fail_to_diagnose": 0, "fail_to_verify": 0, "retrieved_insights": [], "tag": [{"problem_domain": "Resource Allocation", "modeling_type": "LP", "industry_sector": "Health", "reason": "The problem involves allocating servings of different nuts (resources) to meet nutritional requirements while minimizing fat intake. The objective function and all constraints are linear, and decision variables are continuous, making it a Linear Program. The application directly relates to dietary planning and nutritional goals, fitting within the health sector."}], "cluster": null, "prompt": "Below is an operations research question. First formulate the problem as an optimization problem. Then according to the formulated problem, write python code that uses 'gurobipy' to solve the optimization problem. You should write a complete python code that can be executed to solve the optimization problem.\n\nIMPORTANT: Your code should follow these requirements:\n1. Create a Gurobi model variable named 'model' (not 'm' or other names)\n2. Include all necessary imports and data setup\n3. Write the complete optimization code that can run independently\n4. Do NOT wrap everything in a function - write the code directly\n5. Make sure the model is created and optimized in the main execution flow\n6. The code should print the optimal objective value when solved successfully\n\nExample format:\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Data setup\ndata = {...}\n\n# Create model\nmodel = gp.Model(\"ProblemName\")\n\n# Decision variables\nx = model.addVars(...)\n\n# Objective\nmodel.setObjective(...)\n\n# Constraints\nmodel.addConstr(...)\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\nelse:\n    print(\"No optimal solution found\")\n```\n\n# Question:\nA woman eats cashews and almonds to get her calorie and protein intake. A serving of almonds contains 200 calories and 20 grams of protein. A serving of cashews contains 300 calories and 25 grams of protein. The woman decides to eat at least twice as many servings of almonds as cashews. Furthermore, a serving of almonds contains 15 grams of fat while a serving of cashews contains 12 grams of fat. If the woman needs to consume at least 10000 calories and 800 grams of protein this week, how many servings of each should she eat to minimize her fat intake?\n\n# Response:", "generated_output": "```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# =========================\n# Data setup\n# =========================\ncal_almond = 200   # calories per serving of almonds\nprot_almond = 20   # protein (g) per serving of almonds\nfat_almond = 15    # fat (g) per serving of almonds\n\ncal_cashew = 300   # calories per serving of cashews\nprot_cashew = 25   # protein (g) per serving of cashews\nfat_cashew = 12    # fat (g) per serving of cashews\n\nmin_calories = 10000\nmin_protein = 800\n\n# =========================\n# Create model\n# =========================\nmodel = gp.Model(\"NutIntakeMinFat\")\n\n# Decision variables:\n# x_A = servings of almonds\n# x_C = servings of cashews\nx_A = model.addVar(name=\"Almonds\", lb=0, vtype=GRB.CONTINUOUS)\nx_C = model.addVar(name=\"Cashews\", lb=0, vtype=GRB.CONTINUOUS)\n\n# =========================\n# Objective: minimize total fat\n# =========================\nmodel.setObjective(fat_almond * x_A + fat_cashew * x_C, GRB.MINIMIZE)\n\n# =========================\n# Constraints\n# =========================\n\n# Calorie requirement\nmodel.addConstr(cal_almond * x_A + cal_cashew * x_C >= min_calories,\n               name=\"CalorieRequirement\")\n\n# Protein requirement\nmodel.addConstr(prot_almond * x_A + prot_cashew * x_C >= min_protein,\n               name=\"ProteinRequirement\")\n\n# At least twice as many servings of almonds as cashews: x_A >= 2 * x_C\nmodel.addConstr(x_A >= 2 * x_C, name=\"AlmondsAtLeastTwiceCashews\")\n\n# =========================\n# Optimize\n# =========================\nmodel.optimize()\n\n# =========================\n# Results\n# =========================\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value (minimum total fat): {model.objVal}\")\n    print(f\"Servings of almonds: {x_A.X}\")\n    print(f\"Servings of cashews: {x_C.X}\")\nelse:\n    print(\"No optimal solution found\")\n```", "extracted_code": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# =========================\n# Data setup\n# =========================\ncal_almond = 200   # calories per serving of almonds\nprot_almond = 20   # protein (g) per serving of almonds\nfat_almond = 15    # fat (g) per serving of almonds\n\ncal_cashew = 300   # calories per serving of cashews\nprot_cashew = 25   # protein (g) per serving of cashews\nfat_cashew = 12    # fat (g) per serving of cashews\n\nmin_calories = 10000\nmin_protein = 800\n\n# =========================\n# Create model\n# =========================\nmodel = gp.Model(\"NutIntakeMinFat\")\n\n# Decision variables:\n# x_A = servings of almonds\n# x_C = servings of cashews\nx_A = model.addVar(name=\"Almonds\", lb=0, vtype=GRB.CONTINUOUS)\nx_C = model.addVar(name=\"Cashews\", lb=0, vtype=GRB.CONTINUOUS)\n\n# =========================\n# Objective: minimize total fat\n# =========================\nmodel.setObjective(fat_almond * x_A + fat_cashew * x_C, GRB.MINIMIZE)\n\n# =========================\n# Constraints\n# =========================\n\n# Calorie requirement\nmodel.addConstr(cal_almond * x_A + cal_cashew * x_C >= min_calories,\n               name=\"CalorieRequirement\")\n\n# Protein requirement\nmodel.addConstr(prot_almond * x_A + prot_cashew * x_C >= min_protein,\n               name=\"ProteinRequirement\")\n\n# At least twice as many servings of almonds as cashews: x_A >= 2 * x_C\nmodel.addConstr(x_A >= 2 * x_C, name=\"AlmondsAtLeastTwiceCashews\")\n\n# =========================\n# Optimize\n# =========================\nmodel.optimize()\n\n# =========================\n# Results\n# =========================\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value (minimum total fat): {model.objVal}\")\n    print(f\"Servings of almonds: {x_A.X}\")\n    print(f\"Servings of cashews: {x_C.X}\")\nelse:\n    print(\"No optimal solution found\")", "execution_success": true, "mathematical_accuracy": true, "execution_result": "Execution Successful", "execution_best_solution": 600.0, "execution_state": "Execution Successful"}
{"task_id": "A216", "description": "A lighting company has access to two types of lights to provide their customers, an LED fixture, and a fluorescence lamp. The LED light uses 5 units of electricity per hour and needs to be changed 3 times a decade. Conversely, the fluorescence lamp uses 8 units of electricity per hour and needs to be changed 4 times a decade. Due to previous installations, at least 30% implemented lights must be fluorescence lamps. If the customer requires at least 300 light fixtures and can use at most 2000 units of electricity, how many of each light should be installed to reduce the total number of light changes?", "ground_truth": 990.0, "formulation": null, "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\n\ndef optimize_lighting(min_total_fixtures=300,\n                      max_electricity=2000,\n                      led_electricity=5,\n                      fluorescence_electricity=8,\n                      led_changes=3,\n                      fluorescence_changes=4,\n                      fluorescence_ratio=0.3):\n    # Create a new model\n    m = gp.Model(\"LightingOptimization\")\n\n    # Decision variables: number of fixtures\n    x_LED = m.addVar(vtype=GRB.INTEGER, lb=0, name=\"x_LED\")\n    x_F = m.addVar(vtype=GRB.INTEGER, lb=0, name=\"x_F\")\n\n    # Set objective: minimize total changes\n    total_changes = led_changes * x_LED + fluorescence_changes * x_F\n    m.setObjective(total_changes, GRB.MINIMIZE)\n\n    # Add constraints\n    # 1. Minimum total fixtures\n    m.addConstr(x_LED + x_F >= min_total_fixtures, \"MinFixtures\")\n\n    # 2. Electricity consumption limit\n    m.addConstr(\n        led_electricity * x_LED + fluorescence_electricity * x_F\n        <= max_electricity, \"ElectricityLimit\")\n\n    # 3. Fluorescence proportion constraint\n    # x_F >= 0.3 * (x_LED + x_F)\n    # Rearranged: 0.7 * x_F >= 0.3 * x_LED\n    m.addConstr(0.7 * x_F >= 0.3 * x_LED, \"FluorescenceRatio\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        return m.objVal\n    else:\n        return None\n\n# Example usage\nif __name__ == \"__main__\":\n    result = optimize_lighting()\n    print(f\"Optimal total changes: {result}\")", "output_status": [], "success_count": 0, "success_confidence": 0, "fail_to_diagnose": 0, "fail_to_verify": 0, "retrieved_insights": [], "tag": [{"problem_domain": "Resource Allocation", "modeling_type": "MILP", "industry_sector": "Manufacturing", "reason": "The problem involves allocating a limited budget of electricity and minimum total fixtures to two types of lights (LED and fluorescence) to minimize the total number of light changes. The decision variables are integers, and the objective function and constraints are linear, making it a Mixed-Integer Linear Program. The context of a lighting company providing products to customers falls under manufacturing."}], "cluster": null, "prompt": "Below is an operations research question. First formulate the problem as an optimization problem. Then according to the formulated problem, write python code that uses 'gurobipy' to solve the optimization problem. You should write a complete python code that can be executed to solve the optimization problem.\n\nIMPORTANT: Your code should follow these requirements:\n1. Create a Gurobi model variable named 'model' (not 'm' or other names)\n2. Include all necessary imports and data setup\n3. Write the complete optimization code that can run independently\n4. Do NOT wrap everything in a function - write the code directly\n5. Make sure the model is created and optimized in the main execution flow\n6. The code should print the optimal objective value when solved successfully\n\nExample format:\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Data setup\ndata = {...}\n\n# Create model\nmodel = gp.Model(\"ProblemName\")\n\n# Decision variables\nx = model.addVars(...)\n\n# Objective\nmodel.setObjective(...)\n\n# Constraints\nmodel.addConstr(...)\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\nelse:\n    print(\"No optimal solution found\")\n```\n\n# Question:\nA lighting company has access to two types of lights to provide their customers, an LED fixture, and a fluorescence lamp. The LED light uses 5 units of electricity per hour and needs to be changed 3 times a decade. Conversely, the fluorescence lamp uses 8 units of electricity per hour and needs to be changed 4 times a decade. Due to previous installations, at least 30% implemented lights must be fluorescence lamps. If the customer requires at least 300 light fixtures and can use at most 2000 units of electricity, how many of each light should be installed to reduce the total number of light changes?\n\n# Response:", "generated_output": "Below is the formulation and then the complete Python code using `gurobipy`.\n\n---\n\n## Optimization Model Formulation\n\n**Decision variables**\n\n- \\( x \\): number of LED fixtures to install (integer, \\( x \\ge 0 \\))\n- \\( y \\): number of fluorescence lamps to install (integer, \\( y \\ge 0 \\))\n\n**Objective**\n\nMinimize the total number of light changes over a decade:\n\n\\[\n\\min \\; 3x + 4y\n\\]\n\n**Constraints**\n\n1. Minimum total number of fixtures:\n\n\\[\nx + y \\ge 300\n\\]\n\n2. Electricity usage limit (units per hour):\n\n\\[\n5x + 8y \\le 2000\n\\]\n\n3. At least 30% of installed lights must be fluorescence lamps:\n\n\\[\ny \\ge 0.3(x + y)\n\\]\n\nThis can be rewritten as:\n\n\\[\ny \\ge 0.3x + 0.3y \\Rightarrow 0.7y \\ge 0.3x \\Rightarrow 7y \\ge 3x\n\\]\n\n4. Non-negativity and integrality:\n\n\\[\nx, y \\in \\mathbb{Z}_{\\ge 0}\n\\]\n\n---\n\n## Complete Python Code (Gurobi)\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Create model\nmodel = gp.Model(\"LightingInstallation\")\n\n# Decision variables\n# x: number of LED fixtures\n# y: number of fluorescence lamps\nx = model.addVar(vtype=GRB.INTEGER, name=\"LED\")\ny = model.addVar(vtype=GRB.INTEGER, name=\"Fluorescent\")\n\n# Update model to integrate new variables\nmodel.update()\n\n# Objective: minimize total number of light changes over a decade\n# LED: 3 changes per decade, Fluorescent: 4 changes per decade\nmodel.setObjective(3 * x + 4 * y, GRB.MINIMIZE)\n\n# Constraints\n\n# 1. At least 300 total fixtures\nmodel.addConstr(x + y >= 300, name=\"MinFixtures\")\n\n# 2. Electricity usage limit: 5x + 8y <= 2000\nmodel.addConstr(5 * x + 8 * y <= 2000, name=\"ElectricityLimit\")\n\n# 3. At least 30% of installed lights must be fluorescence lamps\n# y >= 0.3(x + y)  ->  7y >= 3x\nmodel.addConstr(7 * y >= 3 * x, name=\"FluorescentShare\")\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value (minimum total changes): {model.objVal}\")\n    print(f\"Number of LED fixtures (x): {int(x.X)}\")\n    print(f\"Number of fluorescent lamps (y): {int(y.X)}\")\nelse:\n    print(\"No optimal solution found\")\n```", "extracted_code": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create model\nmodel = gp.Model(\"LightingInstallation\")\n\n# Decision variables\n# x: number of LED fixtures\n# y: number of fluorescence lamps\nx = model.addVar(vtype=GRB.INTEGER, name=\"LED\")\ny = model.addVar(vtype=GRB.INTEGER, name=\"Fluorescent\")\n\n# Update model to integrate new variables\nmodel.update()\n\n# Objective: minimize total number of light changes over a decade\n# LED: 3 changes per decade, Fluorescent: 4 changes per decade\nmodel.setObjective(3 * x + 4 * y, GRB.MINIMIZE)\n\n# Constraints\n\n# 1. At least 300 total fixtures\nmodel.addConstr(x + y >= 300, name=\"MinFixtures\")\n\n# 2. Electricity usage limit: 5x + 8y <= 2000\nmodel.addConstr(5 * x + 8 * y <= 2000, name=\"ElectricityLimit\")\n\n# 3. At least 30% of installed lights must be fluorescence lamps\n# y >= 0.3(x + y)  ->  7y >= 3x\nmodel.addConstr(7 * y >= 3 * x, name=\"FluorescentShare\")\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value (minimum total changes): {model.objVal}\")\n    print(f\"Number of LED fixtures (x): {int(x.X)}\")\n    print(f\"Number of fluorescent lamps (y): {int(y.X)}\")\nelse:\n    print(\"No optimal solution found\")", "execution_success": true, "mathematical_accuracy": true, "execution_result": "Execution Successful", "execution_best_solution": 990.0, "execution_state": "Execution Successful"}
{"task_id": "A099", "description": "A travelling salesman only eats ramen and fries. Each pack of ramen contains 400 calories, 20 grams of protein, and 100 mg of sodium. Each pack of fries contains 300 calories, 10 grams of protein, and 75 mg of sodium. Since fries are easier to eat while driving, at most 30% of his meals can be ramen. The salesman wants to ensure he eats at least 3000 calories and 80 grams of protein. How many of each should he eat to minimize his sodium intake?", "ground_truth": 750.0, "formulation": null, "correct_program": "def optimize_meal(min_calories=3000, min_protein=80):\n    import gurobipy as gp\n    from gurobipy import GRB\n\n    # Create a new model\n    model = gp.Model(\"MealOptimization\")\n\n    # Decision variables: number of ramen and fries packs\n    R = model.addVar(name=\"R\", lb=0)\n    F = model.addVar(name=\"F\", lb=0)\n\n    # Objective: minimize total sodium intake\n    sodium = 100 * R + 75 * F\n    model.setObjective(sodium, GRB.MINIMIZE)\n\n    # Nutritional constraints\n    model.addConstr(400 * R + 300 * F >= min_calories, name=\"Calories\")\n    model.addConstr(20 * R + 10 * F >= min_protein, name=\"Protein\")\n\n    # Proportion constraint: R <= 0.3*(R+F)\n    # Simplified to 7 R <= 3 F\n    model.addConstr(7 * R <= 3 * F, name=\"RamenProportion\")\n\n    # Optimize the model\n    model.optimize()\n\n    # Check if a feasible solution was found\n    if model.status == GRB.OPTIMAL:\n        # Return the minimal sodium intake\n        return model.objVal\n    else:\n        # No feasible solution found\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    min_sodium = optimize_meal()\n    if min_sodium is not None:\n        print(f\"Minimum Sodium Intake: {min_sodium}\")\n    else:\n        print(\"No feasible solution found.\")", "output_status": [], "success_count": 0, "success_confidence": 0, "fail_to_diagnose": 0, "fail_to_verify": 0, "retrieved_insights": [], "tag": [{"problem_domain": "Blending", "modeling_type": "LP", "industry_sector": "Food & Beverage", "reason": "The problem involves combining different food items (ramen and fries) to meet nutritional requirements while minimizing a cost (sodium intake), which is characteristic of a blending problem. The model uses continuous variables and linear constraints and objective, making it a Linear Program. The application is directly related to food consumption and nutrition, fitting the Food & Beverage sector."}], "cluster": null, "prompt": "Below is an operations research question. First formulate the problem as an optimization problem. Then according to the formulated problem, write python code that uses 'gurobipy' to solve the optimization problem. You should write a complete python code that can be executed to solve the optimization problem.\n\nIMPORTANT: Your code should follow these requirements:\n1. Create a Gurobi model variable named 'model' (not 'm' or other names)\n2. Include all necessary imports and data setup\n3. Write the complete optimization code that can run independently\n4. Do NOT wrap everything in a function - write the code directly\n5. Make sure the model is created and optimized in the main execution flow\n6. The code should print the optimal objective value when solved successfully\n\nExample format:\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Data setup\ndata = {...}\n\n# Create model\nmodel = gp.Model(\"ProblemName\")\n\n# Decision variables\nx = model.addVars(...)\n\n# Objective\nmodel.setObjective(...)\n\n# Constraints\nmodel.addConstr(...)\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\nelse:\n    print(\"No optimal solution found\")\n```\n\n# Question:\nA travelling salesman only eats ramen and fries. Each pack of ramen contains 400 calories, 20 grams of protein, and 100 mg of sodium. Each pack of fries contains 300 calories, 10 grams of protein, and 75 mg of sodium. Since fries are easier to eat while driving, at most 30% of his meals can be ramen. The salesman wants to ensure he eats at least 3000 calories and 80 grams of protein. How many of each should he eat to minimize his sodium intake?\n\n# Response:", "generated_output": "Below is the formulation and then the complete Python code using `gurobipy`.\n\n---\n\n## Optimization Formulation\n\nDecision variables  \n- \\( x \\): number of packs of ramen  \n- \\( y \\): number of packs of fries  \n\nObjective (minimize total sodium):  \n\\[\n\\min \\; 100x + 75y\n\\]\n\nSubject to:\n\n1. Calorie requirement (at least 3000 calories):  \n\\[\n400x + 300y \\ge 3000\n\\]\n\n2. Protein requirement (at least 80 grams):  \n\\[\n20x + 10y \\ge 80\n\\]\n\n3. At most 30% of meals can be ramen:  \n\\[\nx \\le 0.3(x + y)\n\\]\nThis can be rewritten as:\n\\[\nx \\le 0.3x + 0.3y \\Rightarrow 0.7x \\le 0.3y \\Rightarrow 7x \\le 3y\n\\]\n\n4. Non-negativity:  \n\\[\nx \\ge 0,\\quad y \\ge 0\n\\]\n\nWe will treat \\(x\\) and \\(y\\) as continuous (real-valued) variables.\n\n---\n\n## Gurobi Python Code\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Create model\nmodel = gp.Model(\"RamenFriesDiet\")\n\n# Decision variables: number of ramen packs (x) and fries packs (y)\n# Non-negative continuous variables\nx = model.addVar(name=\"ramen\", lb=0.0)\ny = model.addVar(name=\"fries\", lb=0.0)\n\n# Objective: minimize total sodium intake\n# Ramen: 100 mg sodium per pack, Fries: 75 mg sodium per pack\nmodel.setObjective(100 * x + 75 * y, GRB.MINIMIZE)\n\n# Constraints\n\n# 1) Calorie requirement: 400x + 300y >= 3000\nmodel.addConstr(400 * x + 300 * y >= 3000, name=\"calories\")\n\n# 2) Protein requirement: 20x + 10y >= 80\nmodel.addConstr(20 * x + 10 * y >= 80, name=\"protein\")\n\n# 3) At most 30% of meals can be ramen:\n#    x <= 0.3 * (x + y)  ->  7x <= 3y\nmodel.addConstr(7 * x <= 3 * y, name=\"ramen_fraction\")\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value (minimum sodium): {model.objVal}\")\n    print(f\"Optimal number of ramen packs (x): {x.X}\")\n    print(f\"Optimal number of fries packs (y): {y.X}\")\nelse:\n    print(\"No optimal solution found\")\n```", "extracted_code": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create model\nmodel = gp.Model(\"RamenFriesDiet\")\n\n# Decision variables: number of ramen packs (x) and fries packs (y)\n# Non-negative continuous variables\nx = model.addVar(name=\"ramen\", lb=0.0)\ny = model.addVar(name=\"fries\", lb=0.0)\n\n# Objective: minimize total sodium intake\n# Ramen: 100 mg sodium per pack, Fries: 75 mg sodium per pack\nmodel.setObjective(100 * x + 75 * y, GRB.MINIMIZE)\n\n# Constraints\n\n# 1) Calorie requirement: 400x + 300y >= 3000\nmodel.addConstr(400 * x + 300 * y >= 3000, name=\"calories\")\n\n# 2) Protein requirement: 20x + 10y >= 80\nmodel.addConstr(20 * x + 10 * y >= 80, name=\"protein\")\n\n# 3) At most 30% of meals can be ramen:\n#    x <= 0.3 * (x + y)  ->  7x <= 3y\nmodel.addConstr(7 * x <= 3 * y, name=\"ramen_fraction\")\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value (minimum sodium): {model.objVal}\")\n    print(f\"Optimal number of ramen packs (x): {x.X}\")\n    print(f\"Optimal number of fries packs (y): {y.X}\")\nelse:\n    print(\"No optimal solution found\")", "execution_success": true, "mathematical_accuracy": true, "execution_result": "Execution Successful", "execution_best_solution": 750.0, "execution_state": "Execution Successful"}
{"task_id": "A126", "description": "There has been an oil spill in the ocean and ducks need to be taken to shore to be cleaned either by boat or by canoe. A boat can take 10 ducks per trip while a canoe can take 8 ducks per trip. Since the boats are motor powered, they take 20 minutes per trip while the canoes take 40 minutes per trip. In order to avoid further environmental damage, there can be at most 12 boat trips and at least 60% of the trips should be by canoe. If at least 300 ducks need to be taken to shore, how many of each transportation method should be used to minimize the total amount of time needed to transport the ducks?", "ground_truth": 1160.0, "formulation": null, "correct_program": "def optimize_duck_transport():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"DuckTransport\")\n\n    # Decision variables: number of trips\n    x_b = m.addVar(vtype=GRB.INTEGER, name=\"boat_trips\")\n    x_c = m.addVar(vtype=GRB.INTEGER, name=\"canoe_trips\")\n\n    # Set objective: minimize total time\n    m.setObjective(20 * x_b + 40 * x_c, GRB.MINIMIZE)\n\n    # Add constraints\n    # Ducks transported at least 300\n    m.addConstr(10 * x_b + 8 * x_c >= 300, name=\"duck_transport\")\n    # Maximum 12 boat trips\n    m.addConstr(x_b <= 12, name=\"max_boat_trips\")\n    # At least 60% trips are by canoe\n    m.addConstr(2 * x_c >= 3 * x_b, name=\"canoe_ratio\")\n    # Non-negativity (implicitly enforced by variable type)\n    # (Gurobi variables are non-negative by default unless specified otherwise)\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the minimal total time\n        return m.objVal\n    else:\n        # No feasible solution\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    min_time = optimize_duck_transport()\n    if min_time is not None:\n        print(f\"Minimum Total Time: {min_time}\")\n    else:\n        print(\"No feasible solution found.\")", "output_status": [], "success_count": 0, "success_confidence": 0, "fail_to_diagnose": 0, "fail_to_verify": 0, "retrieved_insights": [], "tag": [{"problem_domain": "Resource Allocation", "modeling_type": "IP", "industry_sector": "Environment", "reason": "The problem involves allocating transportation resources (boats and canoes) to minimize time while meeting constraints on duck capacity, boat usage, and canoe trip ratios. The decision variables are integers, and the objective and constraints are linear, making it an Integer Program. The context of an oil spill and duck rescue clearly places it in the environmental sector."}], "cluster": null, "prompt": "Below is an operations research question. First formulate the problem as an optimization problem. Then according to the formulated problem, write python code that uses 'gurobipy' to solve the optimization problem. You should write a complete python code that can be executed to solve the optimization problem.\n\nIMPORTANT: Your code should follow these requirements:\n1. Create a Gurobi model variable named 'model' (not 'm' or other names)\n2. Include all necessary imports and data setup\n3. Write the complete optimization code that can run independently\n4. Do NOT wrap everything in a function - write the code directly\n5. Make sure the model is created and optimized in the main execution flow\n6. The code should print the optimal objective value when solved successfully\n\nExample format:\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Data setup\ndata = {...}\n\n# Create model\nmodel = gp.Model(\"ProblemName\")\n\n# Decision variables\nx = model.addVars(...)\n\n# Objective\nmodel.setObjective(...)\n\n# Constraints\nmodel.addConstr(...)\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\nelse:\n    print(\"No optimal solution found\")\n```\n\n# Question:\nThere has been an oil spill in the ocean and ducks need to be taken to shore to be cleaned either by boat or by canoe. A boat can take 10 ducks per trip while a canoe can take 8 ducks per trip. Since the boats are motor powered, they take 20 minutes per trip while the canoes take 40 minutes per trip. In order to avoid further environmental damage, there can be at most 12 boat trips and at least 60% of the trips should be by canoe. If at least 300 ducks need to be taken to shore, how many of each transportation method should be used to minimize the total amount of time needed to transport the ducks?\n\n# Response:", "generated_output": "Below is the formulation and then the complete Python code using `gurobipy`.\n\n---\n\n## Optimization Model Formulation\n\n**Decision variables**\n\n- \\( x \\): number of boat trips (integer, \\( x \\ge 0 \\))\n- \\( y \\): number of canoe trips (integer, \\( y \\ge 0 \\))\n\n**Objective**\n\nMinimize total transportation time (in minutes):\n\n\\[\n\\min Z = 20x + 40y\n\\]\n\n**Constraints**\n\n1. Duck capacity (at least 300 ducks transported):\n\\[\n10x + 8y \\ge 300\n\\]\n\n2. At most 12 boat trips:\n\\[\nx \\le 12\n\\]\n\n3. At least 60% of trips by canoe:\n\nTotal trips = \\( x + y \\). Canoe trips must be at least 60% of total:\n\\[\ny \\ge 0.6(x + y)\n\\]\n\nRewriting:\n\\[\ny \\ge 0.6x + 0.6y \\Rightarrow 0.4y \\ge 0.6x \\Rightarrow 2y \\ge 3x\n\\]\n\nSo:\n\\[\n2y - 3x \\ge 0\n\\]\n\n4. Non-negativity and integrality:\n\\[\nx, y \\in \\mathbb{Z}_{\\ge 0}\n\\]\n\n---\n\n## Complete Python Code (Gurobi)\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Create model\nmodel = gp.Model(\"DuckTransport\")\n\n# Decision variables\n# x: number of boat trips\n# y: number of canoe trips\nx = model.addVar(vtype=GRB.INTEGER, name=\"boat_trips\")\ny = model.addVar(vtype=GRB.INTEGER, name=\"canoe_trips\")\n\n# Objective: minimize total time (minutes)\n# Boat: 20 minutes per trip, Canoe: 40 minutes per trip\nmodel.setObjective(20 * x + 40 * y, GRB.MINIMIZE)\n\n# Constraints\n\n# 1) Duck capacity: 10x + 8y >= 300\nmodel.addConstr(10 * x + 8 * y >= 300, name=\"duck_capacity\")\n\n# 2) At most 12 boat trips: x <= 12\nmodel.addConstr(x <= 12, name=\"boat_limit\")\n\n# 3) At least 60% of trips by canoe: 2y - 3x >= 0\nmodel.addConstr(2 * y - 3 * x >= 0, name=\"canoe_ratio\")\n\n# 4) Non-negativity is already enforced by default lower bound 0 on variables\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value (minimum total time): {model.objVal}\")\n    print(f\"Boat trips (x): {int(x.X)}\")\n    print(f\"Canoe trips (y): {int(y.X)}\")\nelse:\n    print(\"No optimal solution found\")\n```", "extracted_code": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create model\nmodel = gp.Model(\"DuckTransport\")\n\n# Decision variables\n# x: number of boat trips\n# y: number of canoe trips\nx = model.addVar(vtype=GRB.INTEGER, name=\"boat_trips\")\ny = model.addVar(vtype=GRB.INTEGER, name=\"canoe_trips\")\n\n# Objective: minimize total time (minutes)\n# Boat: 20 minutes per trip, Canoe: 40 minutes per trip\nmodel.setObjective(20 * x + 40 * y, GRB.MINIMIZE)\n\n# Constraints\n\n# 1) Duck capacity: 10x + 8y >= 300\nmodel.addConstr(10 * x + 8 * y >= 300, name=\"duck_capacity\")\n\n# 2) At most 12 boat trips: x <= 12\nmodel.addConstr(x <= 12, name=\"boat_limit\")\n\n# 3) At least 60% of trips by canoe: 2y - 3x >= 0\nmodel.addConstr(2 * y - 3 * x >= 0, name=\"canoe_ratio\")\n\n# 4) Non-negativity is already enforced by default lower bound 0 on variables\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value (minimum total time): {model.objVal}\")\n    print(f\"Boat trips (x): {int(x.X)}\")\n    print(f\"Canoe trips (y): {int(y.X)}\")\nelse:\n    print(\"No optimal solution found\")", "execution_success": true, "mathematical_accuracy": true, "execution_result": "Execution Successful", "execution_best_solution": 1160.0, "execution_state": "Execution Successful"}
{"task_id": "A124", "description": "A bee farmer transports his honey in small and large bottles. A small bottle can take 5 units of honey while a large bottle can take 20 units of honey. The farmer has available at most 300 small bottles and at most 100 large bottles. In addition, since small bottles are easier to sell, at least twice as many small bottles must be used than large bottles. Finally, he can transport at most 200 bottles total and at least 50 must be large bottles. How many of each bottle should be use to maximize the total amount of honey he can transport?", "ground_truth": 1990.0, "formulation": null, "correct_program": "def optimize_honey_transport():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"HoneyTransport\")\n\n    # Decision variables\n    # x: number of small bottles\n    # y: number of large bottles\n    x = m.addVar(vtype=GRB.INTEGER, name=\"small_bottles\")\n    y = m.addVar(vtype=GRB.INTEGER, name=\"large_bottles\")\n\n    # Set objective: maximize total honey\n    m.setObjective(5 * x + 20 * y, GRB.MAXIMIZE)\n\n    # Add constraints\n    m.addConstr(x <= 300, \"max_small_bottles\")\n    m.addConstr(y <= 100, \"max_large_bottles\")\n    m.addConstr(x >= 2 * y, \"small_at_least_twice_large\")\n    m.addConstr(x + y <= 200, \"total_bottles_limit\")\n    m.addConstr(y >= 50, \"min_large_bottles\")\n    m.addConstr(x >= 0, \"non_negative_small\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the maximum total honey transported\n        return m.objVal\n    else:\n        # No feasible solution\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    max_honey = optimize_honey_transport()\n    if max_honey is not None:\n        print(f\"Maximum Honey Transported: {max_honey}\")\n    else:\n        print(\"No feasible solution found.\")", "output_status": [], "success_count": 0, "success_confidence": 0, "fail_to_diagnose": 0, "fail_to_verify": 0, "retrieved_insights": [], "tag": [{"problem_domain": "Resource Allocation", "modeling_type": "IP", "industry_sector": "Agriculture", "reason": "The problem involves allocating available bottles (resources) to maximize the amount of honey transported, which is a classic resource allocation problem. The solver uses integer variables and linear constraints to define the problem, which is characteristic of an Integer Program. The context of a bee farmer and honey transportation clearly places it within the agriculture sector."}], "cluster": null, "prompt": "Below is an operations research question. First formulate the problem as an optimization problem. Then according to the formulated problem, write python code that uses 'gurobipy' to solve the optimization problem. You should write a complete python code that can be executed to solve the optimization problem.\n\nIMPORTANT: Your code should follow these requirements:\n1. Create a Gurobi model variable named 'model' (not 'm' or other names)\n2. Include all necessary imports and data setup\n3. Write the complete optimization code that can run independently\n4. Do NOT wrap everything in a function - write the code directly\n5. Make sure the model is created and optimized in the main execution flow\n6. The code should print the optimal objective value when solved successfully\n\nExample format:\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Data setup\ndata = {...}\n\n# Create model\nmodel = gp.Model(\"ProblemName\")\n\n# Decision variables\nx = model.addVars(...)\n\n# Objective\nmodel.setObjective(...)\n\n# Constraints\nmodel.addConstr(...)\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\nelse:\n    print(\"No optimal solution found\")\n```\n\n# Question:\nA bee farmer transports his honey in small and large bottles. A small bottle can take 5 units of honey while a large bottle can take 20 units of honey. The farmer has available at most 300 small bottles and at most 100 large bottles. In addition, since small bottles are easier to sell, at least twice as many small bottles must be used than large bottles. Finally, he can transport at most 200 bottles total and at least 50 must be large bottles. How many of each bottle should be use to maximize the total amount of honey he can transport?\n\n# Response:", "generated_output": "Below is the formulation and then the complete Python code using `gurobipy`.\n\n---\n\n## Optimization Model Formulation\n\n**Decision variables**\n\n- \\( x_s \\): number of small bottles used (integer, \\( x_s \\ge 0 \\))\n- \\( x_l \\): number of large bottles used (integer, \\( x_l \\ge 0 \\))\n\n**Objective**\n\nMaximize total honey transported:\n\n\\[\n\\max \\; Z = 5x_s + 20x_l\n\\]\n\n**Constraints**\n\n1. Small bottle availability:\n\\[\nx_s \\le 300\n\\]\n\n2. Large bottle availability:\n\\[\nx_l \\le 100\n\\]\n\n3. Small bottles at least twice as many as large:\n\\[\nx_s \\ge 2x_l\n\\]\n\n4. Total bottles at most 200:\n\\[\nx_s + x_l \\le 200\n\\]\n\n5. At least 50 large bottles:\n\\[\nx_l \\ge 50\n\\]\n\n6. Non-negativity and integrality:\n\\[\nx_s, x_l \\in \\mathbb{Z}_{\\ge 0}\n\\]\n\n---\n\n## Python Code with Gurobi\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Create model\nmodel = gp.Model(\"BeeFarmerHoneyTransport\")\n\n# Decision variables\n# x_s: number of small bottles\n# x_l: number of large bottles\nx_s = model.addVar(vtype=GRB.INTEGER, name=\"x_s\")\nx_l = model.addVar(vtype=GRB.INTEGER, name=\"x_l\")\n\n# Objective: maximize total honey transported\n# Small bottle: 5 units, Large bottle: 20 units\nmodel.setObjective(5 * x_s + 20 * x_l, GRB.MAXIMIZE)\n\n# Constraints\n\n# 1. Small bottle availability: at most 300\nmodel.addConstr(x_s <= 300, name=\"SmallBottleLimit\")\n\n# 2. Large bottle availability: at most 100\nmodel.addConstr(x_l <= 100, name=\"LargeBottleLimit\")\n\n# 3. At least twice as many small bottles as large bottles: x_s >= 2 * x_l\nmodel.addConstr(x_s >= 2 * x_l, name=\"TwiceAsManySmall\")\n\n# 4. Total bottles at most 200: x_s + x_l <= 200\nmodel.addConstr(x_s + x_l <= 200, name=\"TotalBottleLimit\")\n\n# 5. At least 50 large bottles: x_l >= 50\nmodel.addConstr(x_l >= 50, name=\"MinLargeBottles\")\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value (max honey units): {model.objVal}\")\n    print(f\"Small bottles used (x_s): {x_s.X}\")\n    print(f\"Large bottles used (x_l): {x_l.X}\")\nelse:\n    print(\"No optimal solution found\")\n```", "extracted_code": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create model\nmodel = gp.Model(\"BeeFarmerHoneyTransport\")\n\n# Decision variables\n# x_s: number of small bottles\n# x_l: number of large bottles\nx_s = model.addVar(vtype=GRB.INTEGER, name=\"x_s\")\nx_l = model.addVar(vtype=GRB.INTEGER, name=\"x_l\")\n\n# Objective: maximize total honey transported\n# Small bottle: 5 units, Large bottle: 20 units\nmodel.setObjective(5 * x_s + 20 * x_l, GRB.MAXIMIZE)\n\n# Constraints\n\n# 1. Small bottle availability: at most 300\nmodel.addConstr(x_s <= 300, name=\"SmallBottleLimit\")\n\n# 2. Large bottle availability: at most 100\nmodel.addConstr(x_l <= 100, name=\"LargeBottleLimit\")\n\n# 3. At least twice as many small bottles as large bottles: x_s >= 2 * x_l\nmodel.addConstr(x_s >= 2 * x_l, name=\"TwiceAsManySmall\")\n\n# 4. Total bottles at most 200: x_s + x_l <= 200\nmodel.addConstr(x_s + x_l <= 200, name=\"TotalBottleLimit\")\n\n# 5. At least 50 large bottles: x_l >= 50\nmodel.addConstr(x_l >= 50, name=\"MinLargeBottles\")\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value (max honey units): {model.objVal}\")\n    print(f\"Small bottles used (x_s): {x_s.X}\")\n    print(f\"Large bottles used (x_l): {x_l.X}\")\nelse:\n    print(\"No optimal solution found\")", "execution_success": true, "mathematical_accuracy": true, "execution_result": "Execution Successful", "execution_best_solution": 1990.0, "execution_state": "Execution Successful"}
{"task_id": "A034", "description": "A teddy bear company produces three different colored bears: black, white, and brown. These bears are made in two different factories. Running factory 1 for 1 hour costs $300 and produces 5 black teddy bears, 6 white teddy bears, and 3 brown ones. Running factory 2 for 1 hour costs $600 and produces 10 black teddy bears and 10 white teddy bears. (but no brown ones). To meet children's demand, at least 20 black teddy bears, 5 white teddy bears, and 15 brown teddy bears must be made daily. Given this information, develop a linear programming problem assuming the teddy bear company wants to minimize the cost of production.", "ground_truth": 1500.0, "formulation": null, "correct_program": "def optimize_teddy_bears():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"TeddyBearProduction\")\n\n    # Decision variables: hours factory 1 and factory 2\n    x1 = m.addVar(name=\"Factory1_hours\", lb=0)\n    x2 = m.addVar(name=\"Factory2_hours\", lb=0)\n\n    # Set the objective: minimize total cost\n    m.setObjective(300 * x1 + 600 * x2, GRB.MINIMIZE)\n\n    # Add constraints based on demand\n    m.addConstr(5 * x1 + 10 * x2 >= 20, name=\"BlackDemand\")\n    m.addConstr(6 * x1 + 10 * x2 >= 5, name=\"WhiteDemand\")\n    m.addConstr(3 * x1 >= 15, name=\"BrownDemand\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        return m.objVal\n    else:\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    min_cost = optimize_teddy_bears()\n    if min_cost is not None:\n        print(f\"Minimum Cost of Teddy Bear Production: {min_cost}\")\n    else:\n        print(\"No feasible solution found.\")", "output_status": [], "success_count": 0, "success_confidence": 0, "fail_to_diagnose": 0, "fail_to_verify": 0, "retrieved_insights": [], "tag": [{"problem_domain": "Production Planning", "modeling_type": "LP", "industry_sector": "Manufacturing", "reason": "The problem involves determining the optimal production levels (hours for each factory) to meet demand while minimizing cost, which is a classic production planning scenario. The model uses continuous variables and linear objective/constraints, making it a Linear Program."}], "cluster": null, "prompt": "Below is an operations research question. First formulate the problem as an optimization problem. Then according to the formulated problem, write python code that uses 'gurobipy' to solve the optimization problem. You should write a complete python code that can be executed to solve the optimization problem.\n\nIMPORTANT: Your code should follow these requirements:\n1. Create a Gurobi model variable named 'model' (not 'm' or other names)\n2. Include all necessary imports and data setup\n3. Write the complete optimization code that can run independently\n4. Do NOT wrap everything in a function - write the code directly\n5. Make sure the model is created and optimized in the main execution flow\n6. The code should print the optimal objective value when solved successfully\n\nExample format:\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Data setup\ndata = {...}\n\n# Create model\nmodel = gp.Model(\"ProblemName\")\n\n# Decision variables\nx = model.addVars(...)\n\n# Objective\nmodel.setObjective(...)\n\n# Constraints\nmodel.addConstr(...)\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\nelse:\n    print(\"No optimal solution found\")\n```\n\n# Question:\nA teddy bear company produces three different colored bears: black, white, and brown. These bears are made in two different factories. Running factory 1 for 1 hour costs $300 and produces 5 black teddy bears, 6 white teddy bears, and 3 brown ones. Running factory 2 for 1 hour costs $600 and produces 10 black teddy bears and 10 white teddy bears. (but no brown ones). To meet children's demand, at least 20 black teddy bears, 5 white teddy bears, and 15 brown teddy bears must be made daily. Given this information, develop a linear programming problem assuming the teddy bear company wants to minimize the cost of production.\n\n# Response:", "generated_output": "**Formulation**\n\nDecision variables  \n- Let \\(x_1\\) = hours to run factory 1 per day  \n- Let \\(x_2\\) = hours to run factory 2 per day  \n\nObjective (minimize total daily cost)  \n\\[\n\\min \\; Z = 300x_1 + 600x_2\n\\]\n\nConstraints (demand requirements):\n\nBlack bears (at least 20):  \n\\[\n5x_1 + 10x_2 \\ge 20\n\\]\n\nWhite bears (at least 5):  \n\\[\n6x_1 + 10x_2 \\ge 5\n\\]\n\nBrown bears (at least 15, only from factory 1):  \n\\[\n3x_1 \\ge 15\n\\]\n\nNon-negativity:  \n\\[\nx_1 \\ge 0,\\quad x_2 \\ge 0\n\\]\n\n---\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Create model\nmodel = gp.Model(\"TeddyBearProduction\")\n\n# Decision variables: hours to run each factory (continuous, non-negative)\nx1 = model.addVar(name=\"x1\", lb=0.0)  # hours for factory 1\nx2 = model.addVar(name=\"x2\", lb=0.0)  # hours for factory 2\n\n# Objective: minimize total cost\n# Cost: 300 per hour for factory 1, 600 per hour for factory 2\nmodel.setObjective(300 * x1 + 600 * x2, GRB.MINIMIZE)\n\n# Constraints\n\n# Black bears: 5 from factory 1, 10 from factory 2; need at least 20\nmodel.addConstr(5 * x1 + 10 * x2 >= 20, name=\"BlackDemand\")\n\n# White bears: 6 from factory 1, 10 from factory 2; need at least 5\nmodel.addConstr(6 * x1 + 10 * x2 >= 5, name=\"WhiteDemand\")\n\n# Brown bears: 3 from factory 1 only; need at least 15\nmodel.addConstr(3 * x1 >= 15, name=\"BrownDemand\")\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\n    print(f\"Optimal hours for factory 1 (x1): {x1.X}\")\n    print(f\"Optimal hours for factory 2 (x2): {x2.X}\")\nelse:\n    print(\"No optimal solution found\")\n```", "extracted_code": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create model\nmodel = gp.Model(\"TeddyBearProduction\")\n\n# Decision variables: hours to run each factory (continuous, non-negative)\nx1 = model.addVar(name=\"x1\", lb=0.0)  # hours for factory 1\nx2 = model.addVar(name=\"x2\", lb=0.0)  # hours for factory 2\n\n# Objective: minimize total cost\n# Cost: 300 per hour for factory 1, 600 per hour for factory 2\nmodel.setObjective(300 * x1 + 600 * x2, GRB.MINIMIZE)\n\n# Constraints\n\n# Black bears: 5 from factory 1, 10 from factory 2; need at least 20\nmodel.addConstr(5 * x1 + 10 * x2 >= 20, name=\"BlackDemand\")\n\n# White bears: 6 from factory 1, 10 from factory 2; need at least 5\nmodel.addConstr(6 * x1 + 10 * x2 >= 5, name=\"WhiteDemand\")\n\n# Brown bears: 3 from factory 1 only; need at least 15\nmodel.addConstr(3 * x1 >= 15, name=\"BrownDemand\")\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\n    print(f\"Optimal hours for factory 1 (x1): {x1.X}\")\n    print(f\"Optimal hours for factory 2 (x2): {x2.X}\")\nelse:\n    print(\"No optimal solution found\")", "execution_success": true, "mathematical_accuracy": true, "execution_result": "Execution Successful", "execution_best_solution": 1500.0, "execution_state": "Execution Successful"}
{"task_id": "A150", "description": "A jam company sends its product out in small and large jars. A small jar can hold 50 ml of jam while a large jar can hold 200 ml of jam. Most store prefer the smaller size and so the number of large jars cannot exceed the number of small jars. If the company wants to ship at least 100000 ml of jam, find the minimum number of jars that can be used.", "ground_truth": 800.0, "formulation": null, "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\ndef minimize_jars(volume_threshold=100000, small_jar_ml=50, large_jar_ml=200):\n    \"\"\"\n    Finds the minimum total number of jars (small + large) needed to ship at least\n    'volume_threshold' ml of jam, with the constraint that the number of large jars\n    cannot exceed the number of small jars.\n    \n    Args:\n        volume_threshold (int): Minimum total volume of jam to ship (default: 100000 ml).\n        small_jar_ml (int): Volume of jam in a small jar (default: 50 ml).\n        large_jar_ml (int): Volume of jam in a large jar (default: 200 ml).\n        \n    Returns:\n        int or None: The minimum total number of jars if feasible, else None.\n    \"\"\"\n    # Create a new model\n    model = gp.Model(\"Minimize_Jars\")\n    \n    # Decision variables: number of small and large jars\n    x = model.addVar(name=\"small_jars\", vtype=GRB.INTEGER, lb=0)\n    y = model.addVar(name=\"large_jars\", vtype=GRB.INTEGER, lb=0)\n    \n    # Set objective: minimize total jars\n    model.setObjective(x + y, GRB.MINIMIZE)\n    \n    # Add constraints\n    # Volume constraint\n    model.addConstr(small_jar_ml * x + large_jar_ml * y >= volume_threshold, \"volume_constraint\")\n    # Preference constraint\n    model.addConstr(y <= x, \"preference_constraint\")\n    \n    # Optimize the model\n    model.optimize()\n    \n    # Check if a feasible solution was found\n    if model.status == GRB.OPTIMAL:\n        total_jars = int(x.X + y.X)\n        return total_jars\n    else:\n        return None\n# Example usage \nif __name__ == \"__main__\":\n    min_jars = minimize_jars()\n    if min_jars is not None:\n        print(f\"Minimum Total Jars: {min_jars}\")\n    else:\n        print(\"No feasible solution found.\")", "output_status": [], "success_count": 0, "success_confidence": 0, "fail_to_diagnose": 0, "fail_to_verify": 0, "retrieved_insights": [], "tag": [{"problem_domain": "Resource Allocation", "modeling_type": "IP", "industry_sector": "Manufacturing", "reason": "The problem involves allocating production capacity (jars) to meet a minimum volume requirement while minimizing the total number of jars, which is a classic resource allocation problem. The decision variables (number of small and large jars) must be integers, leading to an Integer Programming (IP) model. The context of a 'jam company' producing and shipping its product clearly falls under the manufacturing sector."}], "cluster": null, "prompt": "Below is an operations research question. First formulate the problem as an optimization problem. Then according to the formulated problem, write python code that uses 'gurobipy' to solve the optimization problem. You should write a complete python code that can be executed to solve the optimization problem.\n\nIMPORTANT: Your code should follow these requirements:\n1. Create a Gurobi model variable named 'model' (not 'm' or other names)\n2. Include all necessary imports and data setup\n3. Write the complete optimization code that can run independently\n4. Do NOT wrap everything in a function - write the code directly\n5. Make sure the model is created and optimized in the main execution flow\n6. The code should print the optimal objective value when solved successfully\n\nExample format:\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Data setup\ndata = {...}\n\n# Create model\nmodel = gp.Model(\"ProblemName\")\n\n# Decision variables\nx = model.addVars(...)\n\n# Objective\nmodel.setObjective(...)\n\n# Constraints\nmodel.addConstr(...)\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\nelse:\n    print(\"No optimal solution found\")\n```\n\n# Question:\nA jam company sends its product out in small and large jars. A small jar can hold 50 ml of jam while a large jar can hold 200 ml of jam. Most store prefer the smaller size and so the number of large jars cannot exceed the number of small jars. If the company wants to ship at least 100000 ml of jam, find the minimum number of jars that can be used.\n\n# Response:", "generated_output": "```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# -----------------------------\n# Data setup\n# -----------------------------\nvolume_small = 50    # ml per small jar\nvolume_large = 200   # ml per large jar\nmin_total_volume = 100000  # ml\n\n# -----------------------------\n# Create model\n# -----------------------------\nmodel = gp.Model(\"JamJars\")\n\n# -----------------------------\n# Decision variables\n# -----------------------------\n# x_s: number of small jars\n# x_l: number of large jars\nx_s = model.addVar(vtype=GRB.INTEGER, name=\"x_small\", lb=0)\nx_l = model.addVar(vtype=GRB.INTEGER, name=\"x_large\", lb=0)\n\n# -----------------------------\n# Objective: minimize total number of jars\n# -----------------------------\nmodel.setObjective(x_s + x_l, GRB.MINIMIZE)\n\n# -----------------------------\n# Constraints\n# -----------------------------\n# Volume requirement: total jam shipped at least 100000 ml\nmodel.addConstr(volume_small * x_s + volume_large * x_l >= min_total_volume,\n                name=\"VolumeRequirement\")\n\n# Preference constraint: number of large jars cannot exceed number of small jars\nmodel.addConstr(x_l <= x_s, name=\"LargeNotExceedSmall\")\n\n# -----------------------------\n# Optimize\n# -----------------------------\nmodel.optimize()\n\n# -----------------------------\n# Results\n# -----------------------------\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value (minimum number of jars): {model.objVal}\")\n    print(f\"Small jars used: {x_s.X}\")\n    print(f\"Large jars used: {x_l.X}\")\nelse:\n    print(\"No optimal solution found\")\n```", "extracted_code": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# -----------------------------\n# Data setup\n# -----------------------------\nvolume_small = 50    # ml per small jar\nvolume_large = 200   # ml per large jar\nmin_total_volume = 100000  # ml\n\n# -----------------------------\n# Create model\n# -----------------------------\nmodel = gp.Model(\"JamJars\")\n\n# -----------------------------\n# Decision variables\n# -----------------------------\n# x_s: number of small jars\n# x_l: number of large jars\nx_s = model.addVar(vtype=GRB.INTEGER, name=\"x_small\", lb=0)\nx_l = model.addVar(vtype=GRB.INTEGER, name=\"x_large\", lb=0)\n\n# -----------------------------\n# Objective: minimize total number of jars\n# -----------------------------\nmodel.setObjective(x_s + x_l, GRB.MINIMIZE)\n\n# -----------------------------\n# Constraints\n# -----------------------------\n# Volume requirement: total jam shipped at least 100000 ml\nmodel.addConstr(volume_small * x_s + volume_large * x_l >= min_total_volume,\n                name=\"VolumeRequirement\")\n\n# Preference constraint: number of large jars cannot exceed number of small jars\nmodel.addConstr(x_l <= x_s, name=\"LargeNotExceedSmall\")\n\n# -----------------------------\n# Optimize\n# -----------------------------\nmodel.optimize()\n\n# -----------------------------\n# Results\n# -----------------------------\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value (minimum number of jars): {model.objVal}\")\n    print(f\"Small jars used: {x_s.X}\")\n    print(f\"Large jars used: {x_l.X}\")\nelse:\n    print(\"No optimal solution found\")", "execution_success": true, "mathematical_accuracy": true, "execution_result": "Execution Successful", "execution_best_solution": 800.0, "execution_state": "Execution Successful"}
{"task_id": "A094", "description": "A pharmacy has two factories, factory 1 and factory 2, where they make acne cream and anti-bacterial cream. Factory 1 produces 12 units of acne cream and 15 units of anti-bacterial cream per hour. Factory 2 produces 20 units of acne cream and 10 units of anti-bacterial cream per hour. Factory 1 requires 30 units of base gel per hour while factory 2 requires 45 units of base gel per hour. The pharmacy has available 5000 units of base gel. Further, they must make at least 800 units of acne cream and 1000 units of anti-bacterial cream. How many hours should each factory be run to minimize the total time needed?", "ground_truth": 40.0, "formulation": null, "correct_program": "def optimize_factory_hours():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"FactoryOptimization\")\n\n    # Decision variables: hours each factory runs\n    t1 = m.addVar(name=\"t1\", lb=0)\n    t2 = m.addVar(name=\"t2\", lb=0)\n    max_hour = m.addVar(name=\"max_hour\", lb=0)\n\n    # Set the objective: minimize total hours\n    m.setObjective(max_hour, GRB.MINIMIZE)\n\n    # Add constraints\n    # Acne cream production constraint\n    m.addConstr(12 * t1 + 20 * t2 >= 800, name=\"AcneProduction\")\n    # Anti-bacterial cream production constraint\n    m.addConstr(15 * t1 + 10 * t2 >= 1000, name=\"AntiBacterialProduction\")\n    # Base gel resource constraint\n    m.addConstr(30 * t1 + 45 * t2 <= 5000, name=\"BaseGelLimit\")\n    # Maximum hours constraint\n    m.addConstr(t1 <= max_hour, name=\"MaxHoursT1\")\n    m.addConstr(t2 <= max_hour, name=\"MaxHoursT2\")\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the optimal total hours\n        return m.objVal\n    else:\n        # No feasible solution\n        return None\n\n# Example usage\nprint(optimize_factory_hours())", "output_status": [], "success_count": 0, "success_confidence": 0, "fail_to_diagnose": 0, "fail_to_verify": 0, "retrieved_insights": [], "tag": [{"problem_domain": "Production Planning", "modeling_type": "LP", "industry_sector": "Manufacturing", "reason": "The problem involves determining optimal production levels (factory operating hours) to meet demand and resource constraints, which is a classic Production Planning problem. The model uses linear objective and constraints with continuous variables, classifying it as a Linear Program. The context of factories producing creams falls under the Manufacturing sector."}], "cluster": null, "prompt": "Below is an operations research question. First formulate the problem as an optimization problem. Then according to the formulated problem, write python code that uses 'gurobipy' to solve the optimization problem. You should write a complete python code that can be executed to solve the optimization problem.\n\nIMPORTANT: Your code should follow these requirements:\n1. Create a Gurobi model variable named 'model' (not 'm' or other names)\n2. Include all necessary imports and data setup\n3. Write the complete optimization code that can run independently\n4. Do NOT wrap everything in a function - write the code directly\n5. Make sure the model is created and optimized in the main execution flow\n6. The code should print the optimal objective value when solved successfully\n\nExample format:\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Data setup\ndata = {...}\n\n# Create model\nmodel = gp.Model(\"ProblemName\")\n\n# Decision variables\nx = model.addVars(...)\n\n# Objective\nmodel.setObjective(...)\n\n# Constraints\nmodel.addConstr(...)\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\nelse:\n    print(\"No optimal solution found\")\n```\n\n# Question:\nA pharmacy has two factories, factory 1 and factory 2, where they make acne cream and anti-bacterial cream. Factory 1 produces 12 units of acne cream and 15 units of anti-bacterial cream per hour. Factory 2 produces 20 units of acne cream and 10 units of anti-bacterial cream per hour. Factory 1 requires 30 units of base gel per hour while factory 2 requires 45 units of base gel per hour. The pharmacy has available 5000 units of base gel. Further, they must make at least 800 units of acne cream and 1000 units of anti-bacterial cream. How many hours should each factory be run to minimize the total time needed?\n\n# Response:", "generated_output": "```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# -----------------------------\n# Data setup\n# -----------------------------\n# Production rates (units per hour)\nacne_prod = {1: 12, 2: 20}          # acne cream\nanti_prod = {1: 15, 2: 10}          # anti-bacterial cream\n\n# Base gel usage (units per hour)\ngel_use = {1: 30, 2: 45}\n\n# Requirements\nmin_acne = 800\nmin_anti = 1000\nmax_gel = 5000\n\n# -----------------------------\n# Create model\n# -----------------------------\nmodel = gp.Model(\"PharmacyProduction\")\n\n# Decision variables:\n# x1 = hours to run factory 1\n# x2 = hours to run factory 2\nx = model.addVars([1, 2], name=\"hours\", lb=0)\n\n# -----------------------------\n# Objective: minimize total time\n# -----------------------------\nmodel.setObjective(x[1] + x[2], GRB.MINIMIZE)\n\n# -----------------------------\n# Constraints\n# -----------------------------\n# Acne cream production requirement\nmodel.addConstr(acne_prod[1] * x[1] + acne_prod[2] * x[2] >= min_acne,\n                name=\"AcneRequirement\")\n\n# Anti-bacterial cream production requirement\nmodel.addConstr(anti_prod[1] * x[1] + anti_prod[2] * x[2] >= min_anti,\n                name=\"AntiRequirement\")\n\n# Base gel availability\nmodel.addConstr(gel_use[1] * x[1] + gel_use[2] * x[2] <= max_gel,\n                name=\"GelLimit\")\n\n# -----------------------------\n# Optimize\n# -----------------------------\nmodel.optimize()\n\n# -----------------------------\n# Results\n# -----------------------------\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value (minimum total hours): {model.objVal}\")\n    print(f\"Hours for factory 1: {x[1].X}\")\n    print(f\"Hours for factory 2: {x[2].X}\")\nelse:\n    print(\"No optimal solution found\")\n```", "extracted_code": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# -----------------------------\n# Data setup\n# -----------------------------\n# Production rates (units per hour)\nacne_prod = {1: 12, 2: 20}          # acne cream\nanti_prod = {1: 15, 2: 10}          # anti-bacterial cream\n\n# Base gel usage (units per hour)\ngel_use = {1: 30, 2: 45}\n\n# Requirements\nmin_acne = 800\nmin_anti = 1000\nmax_gel = 5000\n\n# -----------------------------\n# Create model\n# -----------------------------\nmodel = gp.Model(\"PharmacyProduction\")\n\n# Decision variables:\n# x1 = hours to run factory 1\n# x2 = hours to run factory 2\nx = model.addVars([1, 2], name=\"hours\", lb=0)\n\n# -----------------------------\n# Objective: minimize total time\n# -----------------------------\nmodel.setObjective(x[1] + x[2], GRB.MINIMIZE)\n\n# -----------------------------\n# Constraints\n# -----------------------------\n# Acne cream production requirement\nmodel.addConstr(acne_prod[1] * x[1] + acne_prod[2] * x[2] >= min_acne,\n                name=\"AcneRequirement\")\n\n# Anti-bacterial cream production requirement\nmodel.addConstr(anti_prod[1] * x[1] + anti_prod[2] * x[2] >= min_anti,\n                name=\"AntiRequirement\")\n\n# Base gel availability\nmodel.addConstr(gel_use[1] * x[1] + gel_use[2] * x[2] <= max_gel,\n                name=\"GelLimit\")\n\n# -----------------------------\n# Optimize\n# -----------------------------\nmodel.optimize()\n\n# -----------------------------\n# Results\n# -----------------------------\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value (minimum total hours): {model.objVal}\")\n    print(f\"Hours for factory 1: {x[1].X}\")\n    print(f\"Hours for factory 2: {x[2].X}\")\nelse:\n    print(\"No optimal solution found\")", "execution_success": true, "mathematical_accuracy": false, "execution_result": "Execution Successful", "execution_best_solution": 66.66666666666667, "execution_state": "Execution Successful"}
{"task_id": "A123", "description": "A chocolate company can transport their boxes of chocolate either using their own vans or by renting trucks. Their vans can transport 50 boxes per trip while a truck can transport 80 boxes per trip. Since they own their vans, the cost per van trip is $30 while the cost per truck trip is $50. The company needs to transport at least 1500 boxes of chocolate and they have a budget of $1000. Since the vans also provide advertising, the number of trips by van must be larger than the number of trips by trucks. How many of trip by each should be done to minimize the total number of trips?", "ground_truth": 24.0, "formulation": null, "correct_program": "def optimize_trips():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"Chocolate_Transport\")\n\n    # Decision variables: number of van trips (x) and truck trips (y)\n    # Both are integers and >= 0\n    x = m.addVar(vtype=GRB.INTEGER, name=\"van_trips\")\n    y = m.addVar(vtype=GRB.INTEGER, name=\"truck_trips\")\n\n    # Set the objective: minimize total number of trips\n    m.setObjective(x + y, GRB.MINIMIZE)\n\n    # Add capacity constraint: at least 1500 boxes transported\n    m.addConstr(50 * x + 80 * y >= 1500, name=\"capacity_constraint\")\n\n    # Add budget constraint: total cost <= 1000\n    m.addConstr(30 * x + 50 * y <= 1000, name=\"budget_constraint\")\n\n    # Add trip comparison constraint: van trips > truck trips\n    # Since Gurobi does not support strict inequalities directly,\n    # we model x > y as x >= y + 1\n    m.addConstr(x >= y + 1, name=\"trip_comparison\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the minimal total number of trips\n        return m.objVal\n    else:\n        # No feasible solution found\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    min_trips = optimize_trips()\n    if min_trips is not None:\n        print(f\"Minimum Total Trips: {min_trips}\")\n    else:\n        print(\"No feasible solution found.\")", "output_status": [], "success_count": 0, "success_confidence": 0, "fail_to_diagnose": 0, "fail_to_verify": 0, "retrieved_insights": [], "tag": [{"problem_domain": "Resource Allocation", "modeling_type": "IP", "industry_sector": "Logistics", "reason": "The problem involves allocating resources (van and truck trips) to satisfy demand and budget constraints while minimizing total trips. The decision variables are integers, making it an Integer Programming problem. The application is focused on the movement of goods, which falls under logistics."}], "cluster": null, "prompt": "Below is an operations research question. First formulate the problem as an optimization problem. Then according to the formulated problem, write python code that uses 'gurobipy' to solve the optimization problem. You should write a complete python code that can be executed to solve the optimization problem.\n\nIMPORTANT: Your code should follow these requirements:\n1. Create a Gurobi model variable named 'model' (not 'm' or other names)\n2. Include all necessary imports and data setup\n3. Write the complete optimization code that can run independently\n4. Do NOT wrap everything in a function - write the code directly\n5. Make sure the model is created and optimized in the main execution flow\n6. The code should print the optimal objective value when solved successfully\n\nExample format:\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Data setup\ndata = {...}\n\n# Create model\nmodel = gp.Model(\"ProblemName\")\n\n# Decision variables\nx = model.addVars(...)\n\n# Objective\nmodel.setObjective(...)\n\n# Constraints\nmodel.addConstr(...)\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\nelse:\n    print(\"No optimal solution found\")\n```\n\n# Question:\nA chocolate company can transport their boxes of chocolate either using their own vans or by renting trucks. Their vans can transport 50 boxes per trip while a truck can transport 80 boxes per trip. Since they own their vans, the cost per van trip is $30 while the cost per truck trip is $50. The company needs to transport at least 1500 boxes of chocolate and they have a budget of $1000. Since the vans also provide advertising, the number of trips by van must be larger than the number of trips by trucks. How many of trip by each should be done to minimize the total number of trips?\n\n# Response:", "generated_output": "Below is the formulation and then the complete Python code using `gurobipy`.\n\n---\n\n## Optimization Model Formulation\n\n**Decision variables**\n\n- \\( v \\): number of van trips (integer, \\( v \\ge 0 \\))\n- \\( t \\): number of truck trips (integer, \\( t \\ge 0 \\))\n\n**Objective**\n\nMinimize total number of trips:\n\\[\n\\min \\; v + t\n\\]\n\n**Constraints**\n\n1. **Capacity (boxes transported)**  \n   Each van trip carries 50 boxes, each truck trip carries 80 boxes. Need at least 1500 boxes:\n   \\[\n   50v + 80t \\ge 1500\n   \\]\n\n2. **Budget constraint**  \n   Van trip costs \\$30, truck trip costs \\$50, total budget \\$1000:\n   \\[\n   30v + 50t \\le 1000\n   \\]\n\n3. **Advertising requirement**  \n   Number of van trips must be larger than number of truck trips:\n   \\[\n   v \\ge t + 1\n   \\]\n\n4. **Integrality and non-negativity**\n   \\[\n   v, t \\in \\mathbb{Z}_{\\ge 0}\n   \\]\n\n---\n\n## Complete Python Code (Gurobi)\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Create model\nmodel = gp.Model(\"ChocolateTransport\")\n\n# Decision variables\n# v: number of van trips\n# t: number of truck trips\nv = model.addVar(vtype=GRB.INTEGER, name=\"van_trips\", lb=0)\nt = model.addVar(vtype=GRB.INTEGER, name=\"truck_trips\", lb=0)\n\nmodel.update()\n\n# Objective: minimize total number of trips\nmodel.setObjective(v + t, GRB.MINIMIZE)\n\n# Constraints\n\n# 1) Capacity: 50v + 80t >= 1500\nmodel.addConstr(50 * v + 80 * t >= 1500, name=\"capacity\")\n\n# 2) Budget: 30v + 50t <= 1000\nmodel.addConstr(30 * v + 50 * t <= 1000, name=\"budget\")\n\n# 3) Advertising: v >= t + 1\nmodel.addConstr(v >= t + 1, name=\"advertising\")\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value (minimum total trips): {model.objVal}\")\n    print(f\"Number of van trips (v): {v.X}\")\n    print(f\"Number of truck trips (t): {t.X}\")\nelse:\n    print(\"No optimal solution found\")\n```", "extracted_code": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create model\nmodel = gp.Model(\"ChocolateTransport\")\n\n# Decision variables\n# v: number of van trips\n# t: number of truck trips\nv = model.addVar(vtype=GRB.INTEGER, name=\"van_trips\", lb=0)\nt = model.addVar(vtype=GRB.INTEGER, name=\"truck_trips\", lb=0)\n\nmodel.update()\n\n# Objective: minimize total number of trips\nmodel.setObjective(v + t, GRB.MINIMIZE)\n\n# Constraints\n\n# 1) Capacity: 50v + 80t >= 1500\nmodel.addConstr(50 * v + 80 * t >= 1500, name=\"capacity\")\n\n# 2) Budget: 30v + 50t <= 1000\nmodel.addConstr(30 * v + 50 * t <= 1000, name=\"budget\")\n\n# 3) Advertising: v >= t + 1\nmodel.addConstr(v >= t + 1, name=\"advertising\")\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value (minimum total trips): {model.objVal}\")\n    print(f\"Number of van trips (v): {v.X}\")\n    print(f\"Number of truck trips (t): {t.X}\")\nelse:\n    print(\"No optimal solution found\")", "execution_success": true, "mathematical_accuracy": true, "execution_result": "Execution Successful", "execution_best_solution": 24.0, "execution_state": "Execution Successful"}
{"task_id": "A012", "description": "An art store makes large and small art pieces. The store has available 100 units of paint, 50 units of glitter, and 70 units of glue. To make a large art piece requires 4 units of paint, 3 units of glitter, and 5 units of glue. To make a small art piece requires 2 units of paint, 1 unit of glitter, and 2 units of glue. The store must make at least 5 units of each large and small art pieces. If the profit per large art piece is $30 and the profit per small art piece is $15, how many of each should be made to maximize profit?", "ground_truth": 480.0, "formulation": null, "correct_program": "def optimize_art_production(\n    paint_available=100,\n    glitter_available=50,\n    glue_available=70,\n    min_large=5,\n    min_small=5,\n    profit_large=30,\n    profit_small=15\n):\n    import gurobipy as gp\n    from gurobipy import GRB\n\n    # Create a new model\n    model = gp.Model(\"Art_Production_Maximize_Profit\")\n\n    # Decision variables: number of large and small art pieces\n    x = model.addVar(vtype=GRB.INTEGER, name=\"Large_Art\", lb=min_large)\n    y = model.addVar(vtype=GRB.INTEGER, name=\"Small_Art\", lb=min_small)\n\n    # Set the objective: maximize profit\n    model.setObjective(profit_large * x + profit_small * y, GRB.MAXIMIZE)\n\n    # Add material constraints\n    model.addConstr(4 * x + 2 * y <= paint_available, \"Paint_Constraint\")\n    model.addConstr(3 * x + y <= glitter_available, \"Glitter_Constraint\")\n    model.addConstr(5 * x + 2 * y <= glue_available, \"Glue_Constraint\")\n\n    # Optimize the model\n    model.optimize()\n\n    # Check if a feasible solution was found\n    if model.status == GRB.OPTIMAL:\n        # Return the maximum profit\n        return model.objVal\n    else:\n        # No feasible solution found\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    max_profit = optimize_art_production()\n    if max_profit is not None:\n        print(f\"Maximum Profit: {max_profit}\")\n    else:\n        print(\"No feasible solution found.\")", "output_status": [], "success_count": 0, "success_confidence": 0, "fail_to_diagnose": 0, "fail_to_verify": 0, "retrieved_insights": [], "tag": [{"problem_domain": "Resource Allocation", "modeling_type": "MILP", "industry_sector": "Manufacturing", "reason": "The problem involves allocating limited resources (paint, glitter, glue) to produce different products (large and small art pieces) to maximize profit. The decision variables are integers (number of art pieces), and the objective and constraints are linear, classifying it as a Mixed-Integer Linear Program. The context of making art pieces from raw materials fits within the manufacturing sector."}], "cluster": null, "prompt": "Below is an operations research question. First formulate the problem as an optimization problem. Then according to the formulated problem, write python code that uses 'gurobipy' to solve the optimization problem. You should write a complete python code that can be executed to solve the optimization problem.\n\nIMPORTANT: Your code should follow these requirements:\n1. Create a Gurobi model variable named 'model' (not 'm' or other names)\n2. Include all necessary imports and data setup\n3. Write the complete optimization code that can run independently\n4. Do NOT wrap everything in a function - write the code directly\n5. Make sure the model is created and optimized in the main execution flow\n6. The code should print the optimal objective value when solved successfully\n\nExample format:\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Data setup\ndata = {...}\n\n# Create model\nmodel = gp.Model(\"ProblemName\")\n\n# Decision variables\nx = model.addVars(...)\n\n# Objective\nmodel.setObjective(...)\n\n# Constraints\nmodel.addConstr(...)\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\nelse:\n    print(\"No optimal solution found\")\n```\n\n# Question:\nAn art store makes large and small art pieces. The store has available 100 units of paint, 50 units of glitter, and 70 units of glue. To make a large art piece requires 4 units of paint, 3 units of glitter, and 5 units of glue. To make a small art piece requires 2 units of paint, 1 unit of glitter, and 2 units of glue. The store must make at least 5 units of each large and small art pieces. If the profit per large art piece is $30 and the profit per small art piece is $15, how many of each should be made to maximize profit?\n\n# Response:", "generated_output": "Below is the formulation and then the complete Python code using `gurobipy`.\n\n---\n\n## Optimization Model Formulation\n\n**Decision variables**\n\n- \\( x_L \\ge 0 \\): number of large art pieces to make  \n- \\( x_S \\ge 0 \\): number of small art pieces to make  \n\n**Objective**\n\nMaximize total profit:\n\\[\n\\max \\; Z = 30 x_L + 15 x_S\n\\]\n\n**Constraints**\n\nResource constraints:\n\n- Paint:  \n  \\[\n  4 x_L + 2 x_S \\le 100\n  \\]\n- Glitter:  \n  \\[\n  3 x_L + 1 x_S \\le 50\n  \\]\n- Glue:  \n  \\[\n  5 x_L + 2 x_S \\le 70\n  \\]\n\nMinimum production requirements:\n\n\\[\nx_L \\ge 5\n\\]\n\\[\nx_S \\ge 5\n\\]\n\nNon-negativity:\n\n\\[\nx_L \\ge 0,\\quad x_S \\ge 0\n\\]\n\n---\n\n## Python Code with Gurobi\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Create model\nmodel = gp.Model(\"ArtStoreProduction\")\n\n# Decision variables: number of large and small art pieces\n# They can be continuous (LP) since the problem doesn't explicitly require integers\nx_L = model.addVar(name=\"Large\", lb=0.0)\nx_S = model.addVar(name=\"Small\", lb=0.0)\n\n# Update model to integrate new variables\nmodel.update()\n\n# Objective: maximize profit = 30 * x_L + 15 * x_S\nmodel.setObjective(30 * x_L + 15 * x_S, GRB.MAXIMIZE)\n\n# Constraints\n\n# Paint: 4 * x_L + 2 * x_S <= 100\nmodel.addConstr(4 * x_L + 2 * x_S <= 100, name=\"Paint\")\n\n# Glitter: 3 * x_L + 1 * x_S <= 50\nmodel.addConstr(3 * x_L + 1 * x_S <= 50, name=\"Glitter\")\n\n# Glue: 5 * x_L + 2 * x_S <= 70\nmodel.addConstr(5 * x_L + 2 * x_S <= 70, name=\"Glue\")\n\n# Minimum production requirements\nmodel.addConstr(x_L >= 5, name=\"MinLarge\")\nmodel.addConstr(x_S >= 5, name=\"MinSmall\")\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\n    print(f\"Large pieces (x_L): {x_L.X}\")\n    print(f\"Small pieces (x_S): {x_S.X}\")\nelse:\n    print(\"No optimal solution found\")\n```", "extracted_code": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create model\nmodel = gp.Model(\"ArtStoreProduction\")\n\n# Decision variables: number of large and small art pieces\n# They can be continuous (LP) since the problem doesn't explicitly require integers\nx_L = model.addVar(name=\"Large\", lb=0.0)\nx_S = model.addVar(name=\"Small\", lb=0.0)\n\n# Update model to integrate new variables\nmodel.update()\n\n# Objective: maximize profit = 30 * x_L + 15 * x_S\nmodel.setObjective(30 * x_L + 15 * x_S, GRB.MAXIMIZE)\n\n# Constraints\n\n# Paint: 4 * x_L + 2 * x_S <= 100\nmodel.addConstr(4 * x_L + 2 * x_S <= 100, name=\"Paint\")\n\n# Glitter: 3 * x_L + 1 * x_S <= 50\nmodel.addConstr(3 * x_L + 1 * x_S <= 50, name=\"Glitter\")\n\n# Glue: 5 * x_L + 2 * x_S <= 70\nmodel.addConstr(5 * x_L + 2 * x_S <= 70, name=\"Glue\")\n\n# Minimum production requirements\nmodel.addConstr(x_L >= 5, name=\"MinLarge\")\nmodel.addConstr(x_S >= 5, name=\"MinSmall\")\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\n    print(f\"Large pieces (x_L): {x_L.X}\")\n    print(f\"Small pieces (x_S): {x_S.X}\")\nelse:\n    print(\"No optimal solution found\")", "execution_success": true, "mathematical_accuracy": true, "execution_result": "Execution Successful", "execution_best_solution": 487.5, "execution_state": "Execution Successful"}
{"task_id": "A127", "description": "A soda company sends bottles of their soda to stores around the city in old and new vans. An old van can take 100 soda bottles while a new van can take 80 soda bottles. An old van produces 50 units of pollution while a new van only produces 30 units of pollution. The company needs to send at least 5000 bottles. In addition, at most 30 new vans can be used. How many of each van should be used to minimize the total amount of pollution produced?", "ground_truth": 2200.0, "formulation": null, "correct_program": "def optimize_vans():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"Vans Pollution Minimization\")\n\n    # Decision variables\n    # x: number of old vans\n    # y: number of new vans\n    x = m.addVar(vtype=GRB.INTEGER, name=\"OldVans\", lb=0)\n    y = m.addVar(vtype=GRB.INTEGER, name=\"NewVans\", lb=0)\n\n    # Set objective: minimize total pollution\n    m.setObjective(50 * x + 30 * y, GRB.MINIMIZE)\n\n    # Add constraints\n    # Capacity constraint\n    m.addConstr(100 * x + 80 * y >= 5000, \"Capacity\")\n    # Max number of new vans\n    m.addConstr(y <= 30, \"MaxNewVans\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the optimal total pollution\n        return m.objVal\n    else:\n        # No feasible solution found\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    min_pollution = optimize_vans()\n    if min_pollution is not None:\n        print(f\"Minimum Total Pollution: {min_pollution}\")\n    else:\n        print(\"No feasible solution found.\")", "output_status": [], "success_count": 0, "success_confidence": 0, "fail_to_diagnose": 0, "fail_to_verify": 0, "retrieved_insights": [], "tag": [{"problem_domain": "Resource Allocation", "modeling_type": "IP", "industry_sector": "Logistics", "reason": "The problem involves allocating a limited number of old and new vans (resources) to meet a demand for soda bottles while minimizing pollution. The decision variables are integers, and the objective function and constraints are linear, classifying it as an Integer Program. The application is focused on the transportation and delivery of goods, which falls under logistics."}], "cluster": null, "prompt": "Below is an operations research question. First formulate the problem as an optimization problem. Then according to the formulated problem, write python code that uses 'gurobipy' to solve the optimization problem. You should write a complete python code that can be executed to solve the optimization problem.\n\nIMPORTANT: Your code should follow these requirements:\n1. Create a Gurobi model variable named 'model' (not 'm' or other names)\n2. Include all necessary imports and data setup\n3. Write the complete optimization code that can run independently\n4. Do NOT wrap everything in a function - write the code directly\n5. Make sure the model is created and optimized in the main execution flow\n6. The code should print the optimal objective value when solved successfully\n\nExample format:\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Data setup\ndata = {...}\n\n# Create model\nmodel = gp.Model(\"ProblemName\")\n\n# Decision variables\nx = model.addVars(...)\n\n# Objective\nmodel.setObjective(...)\n\n# Constraints\nmodel.addConstr(...)\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\nelse:\n    print(\"No optimal solution found\")\n```\n\n# Question:\nA soda company sends bottles of their soda to stores around the city in old and new vans. An old van can take 100 soda bottles while a new van can take 80 soda bottles. An old van produces 50 units of pollution while a new van only produces 30 units of pollution. The company needs to send at least 5000 bottles. In addition, at most 30 new vans can be used. How many of each van should be used to minimize the total amount of pollution produced?\n\n# Response:", "generated_output": "Below is the formulation and then the complete Python code using `gurobipy`.\n\n---\n\n## Optimization Model Formulation\n\n**Decision variables**\n\n- \\( x \\): number of old vans used (integer, \\( x \\ge 0 \\))\n- \\( y \\): number of new vans used (integer, \\( y \\ge 0 \\))\n\n**Objective**\n\nMinimize total pollution:\n\\[\n\\min \\; 50x + 30y\n\\]\n\n**Constraints**\n\n1. Bottle requirement (at least 5000 bottles):\n\\[\n100x + 80y \\ge 5000\n\\]\n\n2. New van limit:\n\\[\ny \\le 30\n\\]\n\n3. Non-negativity and integrality:\n\\[\nx, y \\in \\mathbb{Z}_{\\ge 0}\n\\]\n\n---\n\n## Python Code (Gurobi)\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Create model\nmodel = gp.Model(\"SodaVanPollutionMinimization\")\n\n# Decision variables\n# x: number of old vans\n# y: number of new vans\nx = model.addVar(vtype=GRB.INTEGER, name=\"old_vans\", lb=0)\ny = model.addVar(vtype=GRB.INTEGER, name=\"new_vans\", lb=0)\n\nmodel.update()\n\n# Objective: minimize total pollution\n# 50 units per old van, 30 units per new van\nmodel.setObjective(50 * x + 30 * y, GRB.MINIMIZE)\n\n# Constraints\n\n# 1. Bottle requirement: 100x + 80y >= 5000\nmodel.addConstr(100 * x + 80 * y >= 5000, name=\"bottle_requirement\")\n\n# 2. At most 30 new vans: y <= 30\nmodel.addConstr(y <= 30, name=\"new_van_limit\")\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\n    print(f\"Old vans used (x): {x.X}\")\n    print(f\"New vans used (y): {y.X}\")\nelse:\n    print(\"No optimal solution found\")\n```", "extracted_code": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create model\nmodel = gp.Model(\"SodaVanPollutionMinimization\")\n\n# Decision variables\n# x: number of old vans\n# y: number of new vans\nx = model.addVar(vtype=GRB.INTEGER, name=\"old_vans\", lb=0)\ny = model.addVar(vtype=GRB.INTEGER, name=\"new_vans\", lb=0)\n\nmodel.update()\n\n# Objective: minimize total pollution\n# 50 units per old van, 30 units per new van\nmodel.setObjective(50 * x + 30 * y, GRB.MINIMIZE)\n\n# Constraints\n\n# 1. Bottle requirement: 100x + 80y >= 5000\nmodel.addConstr(100 * x + 80 * y >= 5000, name=\"bottle_requirement\")\n\n# 2. At most 30 new vans: y <= 30\nmodel.addConstr(y <= 30, name=\"new_van_limit\")\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\n    print(f\"Old vans used (x): {x.X}\")\n    print(f\"New vans used (y): {y.X}\")\nelse:\n    print(\"No optimal solution found\")", "execution_success": true, "mathematical_accuracy": true, "execution_result": "Execution Successful", "execution_best_solution": 2200.0, "execution_state": "Execution Successful"}
{"task_id": "A089", "description": "A sailor can eat either a crab cakes or a lobster roll for his meals. He needs to ensure he gets at least 80 units of vitamin A and 100 units of vitamin C. Each crab cake contains 5 units of vitamin A and 7 units of vitamin C. Each lobster roll contains 8 units of vitamin A and 4 units of vitamin C. In addition, since lobster is more expensive, at most 40% of his meals should be lobster rolls. If each crab cake contains 4 units of unsaturated fat and each lobster roll contains 6 units of unsaturated fat, how many of each should he eat to minimize his unsaturated fat intake?", "ground_truth": 64.0, "formulation": null, "correct_program": "def optimize_meal_plan():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"MealOptimization\")\n\n    # Decision variables: number of crab cakes and lobster rolls\n    x = m.addVar(name=\"crab_cakes\", lb=0, vtype=GRB.INTEGER)\n    y = m.addVar(name=\"lobster_rolls\", lb=0, vtype=GRB.INTEGER)\n\n    # Set the objective: minimize total unsaturated fat\n    m.setObjective(4 * x + 6 * y, GRB.MINIMIZE)\n\n    # Add vitamin A constraint\n    m.addConstr(5 * x + 8 * y >= 80, name=\"VitaminA\")\n    # Add vitamin C constraint\n    m.addConstr(7 * x + 4 * y >= 100, name=\"VitaminC\")\n    # Add meal composition constraint (lobster at most 40%)\n    m.addConstr(y <= (2/3) * x, name=\"LobsterRatio\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the optimal objective value\n        return m.objVal\n    else:\n        # No feasible solution\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    min_fat = optimize_meal_plan()\n    if min_fat is not None:\n        print(f\"Minimum Total Unsaturated Fat: {min_fat}\")\n    else:\n        print(\"No feasible solution found.\")", "output_status": [], "success_count": 0, "success_confidence": 0, "fail_to_diagnose": 0, "fail_to_verify": 0, "retrieved_insights": [], "tag": [{"problem_domain": "Diet Problem", "modeling_type": "MILP", "industry_sector": "Health", "reason": "The problem involves selecting food items (crab cakes, lobster rolls) to meet nutritional requirements (vitamins A and C) while minimizing a cost (unsaturated fat), which is a classic Diet Problem. The solver uses integer variables and linear constraints, making it a Mixed-Integer Linear Program (MILP). The application directly relates to nutrition and well-being, hence 'Health'."}], "cluster": null, "prompt": "Below is an operations research question. First formulate the problem as an optimization problem. Then according to the formulated problem, write python code that uses 'gurobipy' to solve the optimization problem. You should write a complete python code that can be executed to solve the optimization problem.\n\nIMPORTANT: Your code should follow these requirements:\n1. Create a Gurobi model variable named 'model' (not 'm' or other names)\n2. Include all necessary imports and data setup\n3. Write the complete optimization code that can run independently\n4. Do NOT wrap everything in a function - write the code directly\n5. Make sure the model is created and optimized in the main execution flow\n6. The code should print the optimal objective value when solved successfully\n\nExample format:\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Data setup\ndata = {...}\n\n# Create model\nmodel = gp.Model(\"ProblemName\")\n\n# Decision variables\nx = model.addVars(...)\n\n# Objective\nmodel.setObjective(...)\n\n# Constraints\nmodel.addConstr(...)\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\nelse:\n    print(\"No optimal solution found\")\n```\n\n# Question:\nA sailor can eat either a crab cakes or a lobster roll for his meals. He needs to ensure he gets at least 80 units of vitamin A and 100 units of vitamin C. Each crab cake contains 5 units of vitamin A and 7 units of vitamin C. Each lobster roll contains 8 units of vitamin A and 4 units of vitamin C. In addition, since lobster is more expensive, at most 40% of his meals should be lobster rolls. If each crab cake contains 4 units of unsaturated fat and each lobster roll contains 6 units of unsaturated fat, how many of each should he eat to minimize his unsaturated fat intake?\n\n# Response:", "generated_output": "```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Create model\nmodel = gp.Model(\"SailorDiet\")\n\n# Decision variables\n# x: number of crab cakes\n# y: number of lobster rolls\nx = model.addVar(name=\"crab_cakes\", lb=0)\ny = model.addVar(name=\"lobster_rolls\", lb=0)\n\n# Auxiliary variable for total meals to linearize the 40% constraint\nt = model.addVar(name=\"total_meals\", lb=0)\n\n# Objective: minimize total unsaturated fat\n# Each crab cake: 4 units, each lobster roll: 6 units\nmodel.setObjective(4 * x + 6 * y, GRB.MINIMIZE)\n\n# Constraints\n\n# Vitamin A: at least 80 units\n# 5 units per crab cake, 8 units per lobster roll\nmodel.addConstr(5 * x + 8 * y >= 80, name=\"vitamin_A\")\n\n# Vitamin C: at least 100 units\n# 7 units per crab cake, 4 units per lobster roll\nmodel.addConstr(7 * x + 4 * y >= 100, name=\"vitamin_C\")\n\n# Define total meals\nmodel.addConstr(t == x + y, name=\"total_meals_def\")\n\n# At most 40% of meals are lobster rolls:\n# y <= 0.4 * (x + y)  ->  y <= 0.4 * t\nmodel.addConstr(y <= 0.4 * t, name=\"lobster_fraction\")\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value (minimum unsaturated fat): {model.objVal}\")\n    print(f\"Crab cakes (x): {x.X}\")\n    print(f\"Lobster rolls (y): {y.X}\")\nelse:\n    print(\"No optimal solution found\")\n```", "extracted_code": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create model\nmodel = gp.Model(\"SailorDiet\")\n\n# Decision variables\n# x: number of crab cakes\n# y: number of lobster rolls\nx = model.addVar(name=\"crab_cakes\", lb=0)\ny = model.addVar(name=\"lobster_rolls\", lb=0)\n\n# Auxiliary variable for total meals to linearize the 40% constraint\nt = model.addVar(name=\"total_meals\", lb=0)\n\n# Objective: minimize total unsaturated fat\n# Each crab cake: 4 units, each lobster roll: 6 units\nmodel.setObjective(4 * x + 6 * y, GRB.MINIMIZE)\n\n# Constraints\n\n# Vitamin A: at least 80 units\n# 5 units per crab cake, 8 units per lobster roll\nmodel.addConstr(5 * x + 8 * y >= 80, name=\"vitamin_A\")\n\n# Vitamin C: at least 100 units\n# 7 units per crab cake, 4 units per lobster roll\nmodel.addConstr(7 * x + 4 * y >= 100, name=\"vitamin_C\")\n\n# Define total meals\nmodel.addConstr(t == x + y, name=\"total_meals_def\")\n\n# At most 40% of meals are lobster rolls:\n# y <= 0.4 * (x + y)  ->  y <= 0.4 * t\nmodel.addConstr(y <= 0.4 * t, name=\"lobster_fraction\")\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value (minimum unsaturated fat): {model.objVal}\")\n    print(f\"Crab cakes (x): {x.X}\")\n    print(f\"Lobster rolls (y): {y.X}\")\nelse:\n    print(\"No optimal solution found\")", "execution_success": true, "mathematical_accuracy": true, "execution_result": "Execution Successful", "execution_best_solution": 63.33333333333333, "execution_state": "Execution Successful"}
{"task_id": "A059", "description": "A crepe store sells chocolate and peanut butter crepes. A chocolate crepe requires 3 units of chocolate spread and 6 units of crepe mix. A peanut butter crepe requires 4 units of peanut butter spread and 7 units of crepe mix. Recently, the peanut butter crepe has been more popular and therefore the number of peanut butter crepes made must exceed the number of chocolate crepes made. However at least 25% of the crepes made should be chocolate. The store has available 400 units of chocolate spread and 450 units of peanut butter spread. How many of each should the store make to minimize the total amount of crepe mix needed?", "ground_truth": 20.0, "formulation": null, "correct_program": "def optimize_crepe_production():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"Crepe_Production\")\n\n    # Decision variables: number of chocolate and peanut butter crepes\n    C = m.addVar(name=\"Chocolate_Crepes\", vtype=GRB.INTEGER, lb=0)\n    P = m.addVar(name=\"Peanut_Butter_Crepes\", vtype=GRB.INTEGER, lb=0)\n\n    # Set objective: minimize total crepe mix\n    m.setObjective(6 * C + 7 * P, GRB.MINIMIZE)\n\n    # Add constraints\n    m.addConstr(3 * C <= 400, name=\"Chocolate_Spread_Limit\")\n    m.addConstr(4 * P <= 450, name=\"Peanut_Butter_Spread_Limit\")\n    m.addConstr(P >= C + 1, name=\"Popularity_Preference\")\n    m.addConstr(P <= 3 * C, name=\"Percentage_Constraint\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the optimal total crepe mix used\n        return m.objVal\n    else:\n        # No feasible solution found\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    min_crepe_mix = optimize_crepe_production()\n    if min_crepe_mix is not None:\n        print(f\"Minimum Total Crepe Mix Used: {min_crepe_mix}\")\n    else:\n        print(\"No feasible solution found.\")", "output_status": [], "success_count": 0, "success_confidence": 0, "fail_to_diagnose": 0, "fail_to_verify": 0, "retrieved_insights": [], "tag": [{"problem_domain": "Production Planning", "modeling_type": "MILP", "industry_sector": "Retail", "reason": "The problem involves determining the optimal quantities of two products (crepes) to produce given resource constraints and demand preferences, which is a classic production planning scenario. The solver uses integer variables and linear constraints with a linear objective function, classifying it as a Mixed-Integer Linear Program. The application is for a crepe store, which falls under the retail sector."}], "cluster": null, "prompt": "Below is an operations research question. First formulate the problem as an optimization problem. Then according to the formulated problem, write python code that uses 'gurobipy' to solve the optimization problem. You should write a complete python code that can be executed to solve the optimization problem.\n\nIMPORTANT: Your code should follow these requirements:\n1. Create a Gurobi model variable named 'model' (not 'm' or other names)\n2. Include all necessary imports and data setup\n3. Write the complete optimization code that can run independently\n4. Do NOT wrap everything in a function - write the code directly\n5. Make sure the model is created and optimized in the main execution flow\n6. The code should print the optimal objective value when solved successfully\n\nExample format:\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Data setup\ndata = {...}\n\n# Create model\nmodel = gp.Model(\"ProblemName\")\n\n# Decision variables\nx = model.addVars(...)\n\n# Objective\nmodel.setObjective(...)\n\n# Constraints\nmodel.addConstr(...)\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\nelse:\n    print(\"No optimal solution found\")\n```\n\n# Question:\nA crepe store sells chocolate and peanut butter crepes. A chocolate crepe requires 3 units of chocolate spread and 6 units of crepe mix. A peanut butter crepe requires 4 units of peanut butter spread and 7 units of crepe mix. Recently, the peanut butter crepe has been more popular and therefore the number of peanut butter crepes made must exceed the number of chocolate crepes made. However at least 25% of the crepes made should be chocolate. The store has available 400 units of chocolate spread and 450 units of peanut butter spread. How many of each should the store make to minimize the total amount of crepe mix needed?\n\n# Response:", "generated_output": "Below is the formulation and then the complete Python code using `gurobipy`.\n\n---\n\n## Optimization Formulation\n\nDecision variables  \n- \\( x \\): number of chocolate crepes  \n- \\( y \\): number of peanut butter crepes  \n\nObjective (minimize total crepe mix used)  \n- Each chocolate crepe uses 6 units of mix  \n- Each peanut butter crepe uses 7 units of mix  \n\n\\[\n\\min \\; Z = 6x + 7y\n\\]\n\nConstraints  \n\n1. Chocolate spread availability (3 units per chocolate crepe, 400 units available):\n\\[\n3x \\le 400\n\\]\n\n2. Peanut butter spread availability (4 units per peanut butter crepe, 450 units available):\n\\[\n4y \\le 450\n\\]\n\n3. Peanut butter crepes must exceed chocolate crepes:\n\\[\ny \\ge x + 1\n\\]\n\n4. At least 25% of crepes made should be chocolate:\n\\[\nx \\ge 0.25(x + y)\n\\]\nThis simplifies to:\n\\[\n3x \\ge y\n\\]\n\n5. Non-negativity:\n\\[\nx \\ge 0,\\quad y \\ge 0\n\\]\n\n(If crepes must be whole numbers, we model \\(x, y\\) as integers.)\n\n---\n\n## Complete Python Code (Gurobi)\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Create model\nmodel = gp.Model(\"CrepeMixMinimization\")\n\n# Decision variables\n# Assuming crepes must be made in whole numbers (integers)\nx = model.addVar(vtype=GRB.INTEGER, name=\"chocolate_crepes\")\ny = model.addVar(vtype=GRB.INTEGER, name=\"peanut_butter_crepes\")\n\n# Objective: minimize total crepe mix used\n# 6 units per chocolate crepe, 7 units per peanut butter crepe\nmodel.setObjective(6 * x + 7 * y, GRB.MINIMIZE)\n\n# Constraints\n\n# 1) Chocolate spread availability: 3 units per chocolate crepe, 400 units available\nmodel.addConstr(3 * x <= 400, name=\"chocolate_spread_limit\")\n\n# 2) Peanut butter spread availability: 4 units per peanut butter crepe, 450 units available\nmodel.addConstr(4 * y <= 450, name=\"peanut_butter_spread_limit\")\n\n# 3) Peanut butter crepes must exceed chocolate crepes: y >= x + 1\nmodel.addConstr(y >= x + 1, name=\"pb_exceeds_chocolate\")\n\n# 4) At least 25% of crepes made should be chocolate:\n#    x >= 0.25 * (x + y)  ->  3x >= y\nmodel.addConstr(3 * x >= y, name=\"chocolate_at_least_25_percent\")\n\n# 5) Non-negativity (implicitly enforced by default lower bound 0)\nx.lb = 0\ny.lb = 0\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value (minimum total crepe mix): {model.objVal}\")\n    print(f\"Chocolate crepes (x): {x.X}\")\n    print(f\"Peanut butter crepes (y): {y.X}\")\nelse:\n    print(\"No optimal solution found\")\n```", "extracted_code": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create model\nmodel = gp.Model(\"CrepeMixMinimization\")\n\n# Decision variables\n# Assuming crepes must be made in whole numbers (integers)\nx = model.addVar(vtype=GRB.INTEGER, name=\"chocolate_crepes\")\ny = model.addVar(vtype=GRB.INTEGER, name=\"peanut_butter_crepes\")\n\n# Objective: minimize total crepe mix used\n# 6 units per chocolate crepe, 7 units per peanut butter crepe\nmodel.setObjective(6 * x + 7 * y, GRB.MINIMIZE)\n\n# Constraints\n\n# 1) Chocolate spread availability: 3 units per chocolate crepe, 400 units available\nmodel.addConstr(3 * x <= 400, name=\"chocolate_spread_limit\")\n\n# 2) Peanut butter spread availability: 4 units per peanut butter crepe, 450 units available\nmodel.addConstr(4 * y <= 450, name=\"peanut_butter_spread_limit\")\n\n# 3) Peanut butter crepes must exceed chocolate crepes: y >= x + 1\nmodel.addConstr(y >= x + 1, name=\"pb_exceeds_chocolate\")\n\n# 4) At least 25% of crepes made should be chocolate:\n#    x >= 0.25 * (x + y)  ->  3x >= y\nmodel.addConstr(3 * x >= y, name=\"chocolate_at_least_25_percent\")\n\n# 5) Non-negativity (implicitly enforced by default lower bound 0)\nx.lb = 0\ny.lb = 0\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value (minimum total crepe mix): {model.objVal}\")\n    print(f\"Chocolate crepes (x): {x.X}\")\n    print(f\"Peanut butter crepes (y): {y.X}\")\nelse:\n    print(\"No optimal solution found\")", "execution_success": true, "mathematical_accuracy": true, "execution_result": "Execution Successful", "execution_best_solution": 20.0, "execution_state": "Execution Successful"}
{"task_id": "A045", "description": "A city employs seasonal and permanent snow removers. A seasonal snow remover works 6 hours per shift and gets paid $120. A permanent snow remover works 10 hours per shift and gets paid $250. Currently the city needs 300 hours of snow remover labor after a heavy snowfall. If the city has a budget of $6500, how many of each type of worker should be hired to minimize the total number of snow removers?", "ground_truth": 44.0, "formulation": null, "correct_program": "def optimize_snow_removers():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"SnowRemovers\")\n\n    # Decision variables: number of seasonal and permanent workers\n    x = m.addVar(vtype=GRB.INTEGER, name=\"Seasonal\")\n    y = m.addVar(vtype=GRB.INTEGER, name=\"Permanent\")\n\n    # Set the objective: minimize total number of workers\n    m.setObjective(x + y, GRB.MINIMIZE)\n\n    # Add constraints\n    # Labor hours constraint\n    m.addConstr(6 * x + 10 * y >= 300, name=\"LaborHours\")\n    # Budget constraint\n    m.addConstr(120 * x + 250 * y <= 6500, name=\"Budget\")\n    # Non-negativity constraints are implicit for integer variables in Gurobi\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the optimal total number of workers\n        return m.objVal\n    else:\n        # No feasible solution\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    min_workers = optimize_snow_removers()\n    if min_workers is not None:\n        print(f\"Minimum Total Number of Workers: {min_workers}\")\n    else:\n        print(\"No feasible solution found.\")", "output_status": [], "success_count": 0, "success_confidence": 0, "fail_to_diagnose": 0, "fail_to_verify": 0, "retrieved_insights": [], "tag": [{"problem_domain": "Resource Allocation", "modeling_type": "IP", "industry_sector": "Public Services", "reason": "The problem involves allocating two types of snow removers (resources) to meet labor hour demands within a budget, aiming to minimize the total number of workers. The decision variables are integers, and the objective and constraints are linear, fitting an Integer Programming model. The application is clearly within city operations for snow removal, which falls under public services."}], "cluster": null, "prompt": "Below is an operations research question. First formulate the problem as an optimization problem. Then according to the formulated problem, write python code that uses 'gurobipy' to solve the optimization problem. You should write a complete python code that can be executed to solve the optimization problem.\n\nIMPORTANT: Your code should follow these requirements:\n1. Create a Gurobi model variable named 'model' (not 'm' or other names)\n2. Include all necessary imports and data setup\n3. Write the complete optimization code that can run independently\n4. Do NOT wrap everything in a function - write the code directly\n5. Make sure the model is created and optimized in the main execution flow\n6. The code should print the optimal objective value when solved successfully\n\nExample format:\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Data setup\ndata = {...}\n\n# Create model\nmodel = gp.Model(\"ProblemName\")\n\n# Decision variables\nx = model.addVars(...)\n\n# Objective\nmodel.setObjective(...)\n\n# Constraints\nmodel.addConstr(...)\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\nelse:\n    print(\"No optimal solution found\")\n```\n\n# Question:\nA city employs seasonal and permanent snow removers. A seasonal snow remover works 6 hours per shift and gets paid $120. A permanent snow remover works 10 hours per shift and gets paid $250. Currently the city needs 300 hours of snow remover labor after a heavy snowfall. If the city has a budget of $6500, how many of each type of worker should be hired to minimize the total number of snow removers?\n\n# Response:", "generated_output": "Below is the formulation and then the complete Python code using `gurobipy`.\n\n---\n\n## Optimization Formulation\n\n**Decision variables**\n\n- \\( x \\): number of seasonal snow removers (integer, \\( x \\ge 0 \\))\n- \\( y \\): number of permanent snow removers (integer, \\( y \\ge 0 \\))\n\n**Objective**\n\nMinimize the total number of snow removers:\n\\[\n\\min \\; x + y\n\\]\n\n**Constraints**\n\n1. Labor hours requirement (at least 300 hours):\n\\[\n6x + 10y \\ge 300\n\\]\n\n2. Budget constraint (at most \\$6500):\n\\[\n120x + 250y \\le 6500\n\\]\n\n3. Non-negativity and integrality:\n\\[\nx, y \\in \\mathbb{Z}_{\\ge 0}\n\\]\n\n---\n\n## Python Code (Gurobi)\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Data setup\nhours_seasonal = 6\nhours_permanent = 10\ncost_seasonal = 120\ncost_permanent = 250\nrequired_hours = 300\nbudget = 6500\n\n# Create model\nmodel = gp.Model(\"SnowRemovers\")\n\n# Decision variables: number of seasonal (x) and permanent (y) workers\nx = model.addVar(vtype=GRB.INTEGER, name=\"Seasonal\")\ny = model.addVar(vtype=GRB.INTEGER, name=\"Permanent\")\n\n# Objective: minimize total number of workers\nmodel.setObjective(x + y, GRB.MINIMIZE)\n\n# Constraints\n\n# 1. Labor hours requirement\nmodel.addConstr(hours_seasonal * x + hours_permanent * y >= required_hours,\n                name=\"LaborRequirement\")\n\n# 2. Budget constraint\nmodel.addConstr(cost_seasonal * x + cost_permanent * y <= budget,\n                name=\"BudgetConstraint\")\n\n# 3. Non-negativity is already enforced by default lower bound 0 for variables\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value (minimum number of workers): {model.objVal}\")\n    print(f\"Seasonal workers (x): {x.X}\")\n    print(f\"Permanent workers (y): {y.X}\")\nelse:\n    print(\"No optimal solution found\")\n```", "extracted_code": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Data setup\nhours_seasonal = 6\nhours_permanent = 10\ncost_seasonal = 120\ncost_permanent = 250\nrequired_hours = 300\nbudget = 6500\n\n# Create model\nmodel = gp.Model(\"SnowRemovers\")\n\n# Decision variables: number of seasonal (x) and permanent (y) workers\nx = model.addVar(vtype=GRB.INTEGER, name=\"Seasonal\")\ny = model.addVar(vtype=GRB.INTEGER, name=\"Permanent\")\n\n# Objective: minimize total number of workers\nmodel.setObjective(x + y, GRB.MINIMIZE)\n\n# Constraints\n\n# 1. Labor hours requirement\nmodel.addConstr(hours_seasonal * x + hours_permanent * y >= required_hours,\n                name=\"LaborRequirement\")\n\n# 2. Budget constraint\nmodel.addConstr(cost_seasonal * x + cost_permanent * y <= budget,\n                name=\"BudgetConstraint\")\n\n# 3. Non-negativity is already enforced by default lower bound 0 for variables\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value (minimum number of workers): {model.objVal}\")\n    print(f\"Seasonal workers (x): {x.X}\")\n    print(f\"Permanent workers (y): {y.X}\")\nelse:\n    print(\"No optimal solution found\")", "execution_success": true, "mathematical_accuracy": true, "execution_result": "Execution Successful", "execution_best_solution": 44.0, "execution_state": "Execution Successful"}
{"task_id": "A187", "description": "A repairman fixes washing machines and freezers. Each washing machine takes 30 minutes of inspection and 90 minutes of fixing time. Each freezer takes 20 minutes of inspection and 125 minutes of fixing time. The repairman has 5000 minutes available for inspection and 20000 minutes available in his schedule. If each washing machine repaired earns him $250 and each freezer repaired earns his $375, how many of each appliance should he fix to maximize his earnings?", "ground_truth": 60000.0, "formulation": null, "correct_program": "def optimize_repair_schedule(\n    max_inspection_time=5000,\n    max_fixing_time=20000,\n    profit_washing=250,\n    profit_freezer=375,\n    inspection_time_washing=30,\n    inspection_time_freezer=20,\n    fixing_time_washing=90,\n    fixing_time_freezer=125\n):\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"ApplianceRepairOptimization\")\n    \n    # Decision variables: number of washing machines and freezers repaired\n    x = m.addVar(vtype=GRB.INTEGER, name=\"WashingMachines\", lb=0)\n    y = m.addVar(vtype=GRB.INTEGER, name=\"Freezers\", lb=0)\n    \n    # Set the objective: maximize profit\n    m.setObjective(profit_washing * x + profit_freezer * y, GRB.MAXIMIZE)\n    \n    # Add constraints\n    # Inspection time constraint\n    m.addConstr(inspection_time_washing * x + inspection_time_freezer * y <= max_inspection_time, \"InspectionTime\")\n    # Fixing time constraint\n    m.addConstr(fixing_time_washing * x + fixing_time_freezer * y <= max_fixing_time, \"FixingTime\")\n    \n    # Optimize the model\n    m.optimize()\n    \n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the maximum profit\n        return m.objVal\n    else:\n        # No feasible solution found\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    max_profit = optimize_repair_schedule()\n    if max_profit is not None:\n        print(f\"Maximum Profit: ${max_profit}\")\n    else:\n        print(\"No feasible solution found.\")", "output_status": [], "success_count": 0, "success_confidence": 0, "fail_to_diagnose": 0, "fail_to_verify": 0, "retrieved_insights": [], "tag": [{"problem_domain": "Resource Allocation", "modeling_type": "IP", "industry_sector": "Services", "reason": "The problem involves allocating limited resources (inspection and fixing time) to different activities (repairing washing machines and freezers) to maximize an objective (profit). The decision variables (number of appliances) must be integers, making it an Integer Programming problem. The application is a repairman's service business."}], "cluster": null, "prompt": "Below is an operations research question. First formulate the problem as an optimization problem. Then according to the formulated problem, write python code that uses 'gurobipy' to solve the optimization problem. You should write a complete python code that can be executed to solve the optimization problem.\n\nIMPORTANT: Your code should follow these requirements:\n1. Create a Gurobi model variable named 'model' (not 'm' or other names)\n2. Include all necessary imports and data setup\n3. Write the complete optimization code that can run independently\n4. Do NOT wrap everything in a function - write the code directly\n5. Make sure the model is created and optimized in the main execution flow\n6. The code should print the optimal objective value when solved successfully\n\nExample format:\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Data setup\ndata = {...}\n\n# Create model\nmodel = gp.Model(\"ProblemName\")\n\n# Decision variables\nx = model.addVars(...)\n\n# Objective\nmodel.setObjective(...)\n\n# Constraints\nmodel.addConstr(...)\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\nelse:\n    print(\"No optimal solution found\")\n```\n\n# Question:\nA repairman fixes washing machines and freezers. Each washing machine takes 30 minutes of inspection and 90 minutes of fixing time. Each freezer takes 20 minutes of inspection and 125 minutes of fixing time. The repairman has 5000 minutes available for inspection and 20000 minutes available in his schedule. If each washing machine repaired earns him $250 and each freezer repaired earns his $375, how many of each appliance should he fix to maximize his earnings?\n\n# Response:", "generated_output": "Below is the mathematical formulation followed by complete Python code using `gurobipy`.\n\n---\n\n## Optimization Model Formulation\n\nDecision variables  \n- \\( x \\): number of washing machines to repair (nonnegative, continuous or integer)  \n- \\( y \\): number of freezers to repair (nonnegative, continuous or integer)\n\nObjective (maximize earnings)  \n\\[\n\\max \\; Z = 250x + 375y\n\\]\n\nConstraints  \n\n1. Inspection time (minutes):\n\\[\n30x + 20y \\le 5000\n\\]\n\n2. Total schedule time (inspection + fixing, minutes):\n\\[\n(30 + 90)x + (20 + 125)y = 120x + 145y \\le 20000\n\\]\n\n3. Nonnegativity:\n\\[\nx \\ge 0,\\quad y \\ge 0\n\\]\n\n---\n\n## Python Code (Gurobi)\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Create model\nmodel = gp.Model(\"RepairmanScheduling\")\n\n# Decision variables\n# Assuming continuous variables; change vtype=GRB.INTEGER if integer solutions are required\nx = model.addVar(name=\"washing_machines\", lb=0, vtype=GRB.CONTINUOUS)\ny = model.addVar(name=\"freezers\", lb=0, vtype=GRB.CONTINUOUS)\n\n# Update model to integrate new variables\nmodel.update()\n\n# Objective: Maximize earnings = 250x + 375y\nmodel.setObjective(250 * x + 375 * y, GRB.MAXIMIZE)\n\n# Constraints\n\n# 1) Inspection time: 30x + 20y <= 5000\nmodel.addConstr(30 * x + 20 * y <= 5000, name=\"inspection_time\")\n\n# 2) Total schedule time (inspection + fixing):\n# Washing machine: 30 + 90 = 120 minutes\n# Freezer: 20 + 125 = 145 minutes\n# 120x + 145y <= 20000\nmodel.addConstr(120 * x + 145 * y <= 20000, name=\"total_schedule_time\")\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\n    print(f\"Optimal number of washing machines: {x.X}\")\n    print(f\"Optimal number of freezers: {y.X}\")\nelse:\n    print(\"No optimal solution found\")\n```", "extracted_code": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create model\nmodel = gp.Model(\"RepairmanScheduling\")\n\n# Decision variables\n# Assuming continuous variables; change vtype=GRB.INTEGER if integer solutions are required\nx = model.addVar(name=\"washing_machines\", lb=0, vtype=GRB.CONTINUOUS)\ny = model.addVar(name=\"freezers\", lb=0, vtype=GRB.CONTINUOUS)\n\n# Update model to integrate new variables\nmodel.update()\n\n# Objective: Maximize earnings = 250x + 375y\nmodel.setObjective(250 * x + 375 * y, GRB.MAXIMIZE)\n\n# Constraints\n\n# 1) Inspection time: 30x + 20y <= 5000\nmodel.addConstr(30 * x + 20 * y <= 5000, name=\"inspection_time\")\n\n# 2) Total schedule time (inspection + fixing):\n# Washing machine: 30 + 90 = 120 minutes\n# Freezer: 20 + 125 = 145 minutes\n# 120x + 145y <= 20000\nmodel.addConstr(120 * x + 145 * y <= 20000, name=\"total_schedule_time\")\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\n    print(f\"Optimal number of washing machines: {x.X}\")\n    print(f\"Optimal number of freezers: {y.X}\")\nelse:\n    print(\"No optimal solution found\")", "execution_success": true, "mathematical_accuracy": false, "execution_result": "Execution Successful", "execution_best_solution": 51724.137931034486, "execution_state": "Execution Successful"}
{"task_id": "A231", "description": "A smoothie shop has a promotion for their two smoothies; an acai berry smoothie and a banana chocolate smoothie. It takes 7 units of acai berries and 3 units of water to make the acai berry smoothie. It takes 6 units of banana chocolate and 4 units of water to make the banana chocolate smoothie. Banana chocolate smoothies are more popular and thus the number of banana chocolate smoothies made must be more than the number of acai berry smoothies made. However, the acai berry smoothies have a loyal customer base, and at least 35% of the smoothies made must be acai berry smoothies. If the smoothie shop has 3500 units of acai berries and 3200 units of banana chocolate, to reduce the total amount of water, how many of each smoothie type should be made?", "ground_truth": 0.0001216666666666, "formulation": null, "correct_program": "def optimize_smoothies(\n    acai_berries=3500,\n    banana_chocolate=3200,\n    water_limit=None  # Not explicitly given, so we omit this constraint\n):\n    import gurobipy as gp\n    from gurobipy import GRB\n\n    # Create a new model\n    model = gp.Model(\"Smoothie_Production_MinWater\")\n\n    # Decision variables\n    x = model.addVar(name=\"acai_smoothies\", lb=0)\n    y = model.addVar(name=\"banana_smoothies\", lb=0)\n\n    # Set the objective: minimize total water used\n    model.setObjective(3 * x + 4 * y, GRB.MINIMIZE)\n\n    # Add resource constraints\n    model.addConstr(7 * x <= acai_berries, name=\"Acai_Berries_Limit\")\n    model.addConstr(6 * y <= banana_chocolate, name=\"Banana_Choco_Limit\")\n\n    # Add popularity constraint: y > x\n    # Since Gurobi does not handle strict inequalities directly,\n    # we can approximate y >= x + epsilon, with epsilon > 0\n    epsilon = 1e-5\n    model.addConstr(y >= x + epsilon, name=\"Popularity_Constraint\")\n\n    # Add loyalty constraint: (13/7) * x >= y\n    model.addConstr((13/7) * x >= y, name=\"Loyalty_Constraint\")\n\n    # Optimize the model\n    model.optimize()\n\n    # Check if a feasible solution was found\n    if model.status == GRB.OPTIMAL:\n        total_water = model.objVal\n        return total_water\n    else:\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    min_water = optimize_smoothies()\n    if min_water is not None:\n        print(f\"Minimum Total Water Used: {min_water}\")\n    else:\n        print(\"No feasible solution found.\")", "output_status": [], "success_count": 0, "success_confidence": 0, "fail_to_diagnose": 0, "fail_to_verify": 0, "retrieved_insights": [], "tag": [{"problem_domain": "Resource Allocation", "modeling_type": "LP", "industry_sector": "Retail", "reason": "The problem involves allocating limited ingredients (acai berries, banana chocolate) to produce two types of smoothies while minimizing water usage and satisfying production constraints. The solver uses linear programming to find the optimal continuous quantities of smoothies."}], "cluster": null, "prompt": "Below is an operations research question. First formulate the problem as an optimization problem. Then according to the formulated problem, write python code that uses 'gurobipy' to solve the optimization problem. You should write a complete python code that can be executed to solve the optimization problem.\n\nIMPORTANT: Your code should follow these requirements:\n1. Create a Gurobi model variable named 'model' (not 'm' or other names)\n2. Include all necessary imports and data setup\n3. Write the complete optimization code that can run independently\n4. Do NOT wrap everything in a function - write the code directly\n5. Make sure the model is created and optimized in the main execution flow\n6. The code should print the optimal objective value when solved successfully\n\nExample format:\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Data setup\ndata = {...}\n\n# Create model\nmodel = gp.Model(\"ProblemName\")\n\n# Decision variables\nx = model.addVars(...)\n\n# Objective\nmodel.setObjective(...)\n\n# Constraints\nmodel.addConstr(...)\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\nelse:\n    print(\"No optimal solution found\")\n```\n\n# Question:\nA smoothie shop has a promotion for their two smoothies; an acai berry smoothie and a banana chocolate smoothie. It takes 7 units of acai berries and 3 units of water to make the acai berry smoothie. It takes 6 units of banana chocolate and 4 units of water to make the banana chocolate smoothie. Banana chocolate smoothies are more popular and thus the number of banana chocolate smoothies made must be more than the number of acai berry smoothies made. However, the acai berry smoothies have a loyal customer base, and at least 35% of the smoothies made must be acai berry smoothies. If the smoothie shop has 3500 units of acai berries and 3200 units of banana chocolate, to reduce the total amount of water, how many of each smoothie type should be made?\n\n# Response:", "generated_output": "Below is the formulation and then the complete Python code using `gurobipy`.\n\n---\n\n## Optimization Model Formulation\n\n**Decision variables**\n\n- \\( x \\): number of acai berry smoothies to make  \n- \\( y \\): number of banana chocolate smoothies to make  \n\nBoth are nonnegative:\n\\[\nx \\ge 0,\\quad y \\ge 0\n\\]\n\n**Objective**\n\nMinimize total water used:\n\n- Each acai smoothie uses 3 units of water\n- Each banana chocolate smoothie uses 4 units of water\n\n\\[\n\\min \\; 3x + 4y\n\\]\n\n**Constraints**\n\n1. **Acai berries availability**  \n   Each acai smoothie uses 7 units of acai berries, and there are 3500 units available:\n   \\[\n   7x \\le 3500\n   \\]\n\n2. **Banana chocolate availability**  \n   Each banana chocolate smoothie uses 6 units of banana chocolate, and there are 3200 units available:\n   \\[\n   6y \\le 3200\n   \\]\n\n3. **Popularity constraint**  \n   Banana chocolate smoothies must be more than acai smoothies:\n   \\[\n   y \\ge x + \\epsilon\n   \\]\n   In practice, we can model this as:\n   \\[\n   y \\ge x\n   \\]\n   if we allow equality as an approximation (or if we treat more than as at least as many in a linear model).\n\n4. **Loyal customer base (at least 35% acai)**  \n   At least 35% of all smoothies must be acai:\n   \\[\n   \\frac{x}{x + y} \\ge 0.35,\\quad x + y > 0\n   \\]\n   This can be linearized (for \\(x + y > 0\\)) as:\n   \\[\n   x \\ge 0.35(x + y)\n   \\]\n   \\[\n   x \\ge 0.35x + 0.35y\n   \\]\n   \\[\n   0.65x \\ge 0.35y\n   \\]\n   \\[\n   13x \\ge 7y\n   \\]\n\nSo the final linear model is:\n\n\\[\n\\begin{aligned}\n\\min \\quad & 3x + 4y \\\\\n\\text{s.t.} \\quad\n& 7x \\le 3500 \\\\\n& 6y \\le 3200 \\\\\n& y \\ge x \\\\\n& 13x \\ge 7y \\\\\n& x \\ge 0,\\; y \\ge 0\n\\end{aligned}\n\\]\n\n---\n\n## Complete Python Code (Gurobi)\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Create model\nmodel = gp.Model(\"SmoothieWaterMinimization\")\n\n# Decision variables: number of acai (x) and banana chocolate (y) smoothies\n# Assume they can be fractional; use vtype=GRB.CONTINUOUS\nx = model.addVar(name=\"acai_smoothies\", vtype=GRB.CONTINUOUS, lb=0.0)\ny = model.addVar(name=\"banana_smoothies\", vtype=GRB.CONTINUOUS, lb=0.0)\n\n# Update model to integrate new variables\nmodel.update()\n\n# Objective: minimize total water usage = 3x + 4y\nmodel.setObjective(3 * x + 4 * y, GRB.MINIMIZE)\n\n# Constraints\n\n# 1) Acai berries availability: 7x <= 3500\nmodel.addConstr(7 * x <= 3500, name=\"acai_supply\")\n\n# 2) Banana chocolate availability: 6y <= 3200\nmodel.addConstr(6 * y <= 3200, name=\"banana_supply\")\n\n# 3) Popularity: banana smoothies at least as many as acai smoothies: y >= x\nmodel.addConstr(y >= x, name=\"popularity\")\n\n# 4) At least 35% of smoothies are acai: 13x >= 7y\nmodel.addConstr(13 * x >= 7 * y, name=\"loyal_customers\")\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value (minimum total water): {model.objVal}\")\n    print(f\"Optimal number of acai smoothies (x): {x.X}\")\n    print(f\"Optimal number of banana smoothies (y): {y.X}\")\nelse:\n    print(\"No optimal solution found\")\n```", "extracted_code": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create model\nmodel = gp.Model(\"SmoothieWaterMinimization\")\n\n# Decision variables: number of acai (x) and banana chocolate (y) smoothies\n# Assume they can be fractional; use vtype=GRB.CONTINUOUS\nx = model.addVar(name=\"acai_smoothies\", vtype=GRB.CONTINUOUS, lb=0.0)\ny = model.addVar(name=\"banana_smoothies\", vtype=GRB.CONTINUOUS, lb=0.0)\n\n# Update model to integrate new variables\nmodel.update()\n\n# Objective: minimize total water usage = 3x + 4y\nmodel.setObjective(3 * x + 4 * y, GRB.MINIMIZE)\n\n# Constraints\n\n# 1) Acai berries availability: 7x <= 3500\nmodel.addConstr(7 * x <= 3500, name=\"acai_supply\")\n\n# 2) Banana chocolate availability: 6y <= 3200\nmodel.addConstr(6 * y <= 3200, name=\"banana_supply\")\n\n# 3) Popularity: banana smoothies at least as many as acai smoothies: y >= x\nmodel.addConstr(y >= x, name=\"popularity\")\n\n# 4) At least 35% of smoothies are acai: 13x >= 7y\nmodel.addConstr(13 * x >= 7 * y, name=\"loyal_customers\")\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value (minimum total water): {model.objVal}\")\n    print(f\"Optimal number of acai smoothies (x): {x.X}\")\n    print(f\"Optimal number of banana smoothies (y): {y.X}\")\nelse:\n    print(\"No optimal solution found\")", "execution_success": true, "mathematical_accuracy": false, "execution_result": "Execution Successful", "execution_best_solution": 0.0, "execution_state": "Execution Successful"}
{"task_id": "A154", "description": "A water salesman collects water from a glacier and transports it in either small or large kegs. A small keg can hold 40 liters of water while a large keg can hold 100 liters of water. The salesman has available at most 30 small kegs and 10 large kegs. Since small kegs are easier to carry, at least twice as may small kegs must be used than large kegs. If he can transport at most 25 kegs total and at least 5 kegs must be large, how many of each should he use to maximize the total amount of glacial water he can transport?", "ground_truth": 1480.0, "formulation": null, "correct_program": "def optimize_water_transport():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"Water_Transport_Maximize\")\n\n    # Decision variables\n    # x: number of small kegs\n    # y: number of large kegs\n    x = m.addVar(vtype=GRB.INTEGER, name=\"small_kegs\")\n    y = m.addVar(vtype=GRB.INTEGER, name=\"large_kegs\")\n\n    # Set objective: maximize total liters of water transported\n    m.setObjective(40 * x + 100 * y, GRB.MAXIMIZE)\n\n    # Add constraints\n    m.addConstr(x <= 30, \"max_small_kegs\")\n    m.addConstr(y <= 10, \"max_large_kegs\")\n    m.addConstr(x >= 2 * y, \"small_at_least_twice_large\")\n    m.addConstr(x + y <= 25, \"total_kegs_limit\")\n    m.addConstr(y >= 5, \"min_large_kegs\")\n    m.addConstr(x >= 0, \"non_negative_small\")\n    m.addConstr(y >= 0, \"non_negative_large\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the maximum total water transported\n        return m.objVal\n    else:\n        # No feasible solution\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    max_water = optimize_water_transport()\n    if max_water is not None:\n        print(f\"Maximum Total Water Transported: {max_water} liters\")\n    else:\n        print(\"No feasible solution found.\")", "output_status": [], "success_count": 0, "success_confidence": 0, "fail_to_diagnose": 0, "fail_to_verify": 0, "retrieved_insights": [], "tag": [{"problem_domain": "Resource Allocation", "modeling_type": "IP", "industry_sector": "Logistics", "reason": "The problem involves allocating a limited number of small and large kegs to maximize the total volume of water transported, which is a classic resource allocation scenario. The decision variables (number of kegs) must be integers, and the objective and constraints are linear, making it an Integer Program. The context of transporting goods (water) falls under logistics."}], "cluster": null, "prompt": "Below is an operations research question. First formulate the problem as an optimization problem. Then according to the formulated problem, write python code that uses 'gurobipy' to solve the optimization problem. You should write a complete python code that can be executed to solve the optimization problem.\n\nIMPORTANT: Your code should follow these requirements:\n1. Create a Gurobi model variable named 'model' (not 'm' or other names)\n2. Include all necessary imports and data setup\n3. Write the complete optimization code that can run independently\n4. Do NOT wrap everything in a function - write the code directly\n5. Make sure the model is created and optimized in the main execution flow\n6. The code should print the optimal objective value when solved successfully\n\nExample format:\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Data setup\ndata = {...}\n\n# Create model\nmodel = gp.Model(\"ProblemName\")\n\n# Decision variables\nx = model.addVars(...)\n\n# Objective\nmodel.setObjective(...)\n\n# Constraints\nmodel.addConstr(...)\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\nelse:\n    print(\"No optimal solution found\")\n```\n\n# Question:\nA water salesman collects water from a glacier and transports it in either small or large kegs. A small keg can hold 40 liters of water while a large keg can hold 100 liters of water. The salesman has available at most 30 small kegs and 10 large kegs. Since small kegs are easier to carry, at least twice as may small kegs must be used than large kegs. If he can transport at most 25 kegs total and at least 5 kegs must be large, how many of each should he use to maximize the total amount of glacial water he can transport?\n\n# Response:", "generated_output": "Below is the formulation and then the complete Python code using `gurobipy`.\n\n---\n\n## Optimization Model Formulation\n\n**Decision variables**\n\n- \\( x_s \\): number of small kegs used (integer, \\( x_s \\ge 0 \\))\n- \\( x_l \\): number of large kegs used (integer, \\( x_l \\ge 0 \\))\n\n**Objective**\n\nMaximize total transported water (in liters):\n\n\\[\n\\max \\; Z = 40 x_s + 100 x_l\n\\]\n\n**Constraints**\n\n1. Availability of small kegs:\n   \\[\n   x_s \\le 30\n   \\]\n\n2. Availability of large kegs:\n   \\[\n   x_l \\le 10\n   \\]\n\n3. At least twice as many small kegs as large kegs:\n   \\[\n   x_s \\ge 2 x_l\n   \\]\n\n4. Total number of kegs at most 25:\n   \\[\n   x_s + x_l \\le 25\n   \\]\n\n5. At least 5 large kegs:\n   \\[\n   x_l \\ge 5\n   \\]\n\n6. Integrality:\n   \\[\n   x_s, x_l \\in \\mathbb{Z}_{\\ge 0}\n   \\]\n\n---\n\n## Complete Python Code (Gurobi)\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Create model\nmodel = gp.Model(\"WaterKegTransport\")\n\n# Decision variables\n# x_s: number of small kegs\n# x_l: number of large kegs\nx_s = model.addVar(vtype=GRB.INTEGER, name=\"x_s\")\nx_l = model.addVar(vtype=GRB.INTEGER, name=\"x_l\")\n\n# Objective: maximize total liters transported\n# Small keg: 40 liters, Large keg: 100 liters\nmodel.setObjective(40 * x_s + 100 * x_l, GRB.MAXIMIZE)\n\n# Constraints\n\n# 1. Availability of small kegs: at most 30\nmodel.addConstr(x_s <= 30, name=\"SmallKegAvailability\")\n\n# 2. Availability of large kegs: at most 10\nmodel.addConstr(x_l <= 10, name=\"LargeKegAvailability\")\n\n# 3. At least twice as many small kegs as large kegs: x_s >= 2 * x_l\nmodel.addConstr(x_s >= 2 * x_l, name=\"TwiceAsManySmall\")\n\n# 4. Total number of kegs at most 25: x_s + x_l <= 25\nmodel.addConstr(x_s + x_l <= 25, name=\"TotalKegsLimit\")\n\n# 5. At least 5 large kegs: x_l >= 5\nmodel.addConstr(x_l >= 5, name=\"MinLargeKegs\")\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value (total liters): {model.objVal}\")\n    print(f\"Small kegs used (x_s): {x_s.X}\")\n    print(f\"Large kegs used (x_l): {x_l.X}\")\nelse:\n    print(\"No optimal solution found\")\n```", "extracted_code": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create model\nmodel = gp.Model(\"WaterKegTransport\")\n\n# Decision variables\n# x_s: number of small kegs\n# x_l: number of large kegs\nx_s = model.addVar(vtype=GRB.INTEGER, name=\"x_s\")\nx_l = model.addVar(vtype=GRB.INTEGER, name=\"x_l\")\n\n# Objective: maximize total liters transported\n# Small keg: 40 liters, Large keg: 100 liters\nmodel.setObjective(40 * x_s + 100 * x_l, GRB.MAXIMIZE)\n\n# Constraints\n\n# 1. Availability of small kegs: at most 30\nmodel.addConstr(x_s <= 30, name=\"SmallKegAvailability\")\n\n# 2. Availability of large kegs: at most 10\nmodel.addConstr(x_l <= 10, name=\"LargeKegAvailability\")\n\n# 3. At least twice as many small kegs as large kegs: x_s >= 2 * x_l\nmodel.addConstr(x_s >= 2 * x_l, name=\"TwiceAsManySmall\")\n\n# 4. Total number of kegs at most 25: x_s + x_l <= 25\nmodel.addConstr(x_s + x_l <= 25, name=\"TotalKegsLimit\")\n\n# 5. At least 5 large kegs: x_l >= 5\nmodel.addConstr(x_l >= 5, name=\"MinLargeKegs\")\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value (total liters): {model.objVal}\")\n    print(f\"Small kegs used (x_s): {x_s.X}\")\n    print(f\"Large kegs used (x_l): {x_l.X}\")\nelse:\n    print(\"No optimal solution found\")", "execution_success": true, "mathematical_accuracy": true, "execution_result": "Execution Successful", "execution_best_solution": 1480.0, "execution_state": "Execution Successful"}
{"task_id": "A238", "description": "A company in the desert can transport goods to rural cities either by camel caravans or desert trucks. A camel caravan can deliver 50 units of goods per trip and takes 12 hours. A desert truck can deliver 150 units of goods per trip and takes 5 hours. However, due to the cost of fuel, the company prefers to have more camel caravans than desert trucks.  If the company needs to deliver 1500 units of goods, how many of each method of transportation should the company organize to minimize the total number of hours required?", "ground_truth": 108.0, "formulation": null, "correct_program": "def optimize_transportation():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"desert_transportation\")\n\n    # Decision variables: number of trips\n    x = m.addVar(vtype=GRB.INTEGER, name=\"camel_trips\", lb=0)\n    y = m.addVar(vtype=GRB.INTEGER, name=\"truck_trips\", lb=0)\n    max_hour = m.addVar(vtype=GRB.INTEGER, name=\"max_hours\", lb=0)\n\n    # Set objective: minimize total hours\n    m.setObjective(max_hour, GRB.MINIMIZE)\n    # m.setObjective(12 * x + 5 * y, GRB.MINIMIZE)\n\n    # Add constraints\n    # Delivery constraint\n    m.addConstr(50 * x + 150 * y >= 1500, name=\"delivery_requirement\")\n    # Preference constraint\n    m.addConstr(x >= y + 1, name=\"more_camel_trips\")\n    # Maximum hours constraint\n    m.addConstr(12 * x <= max_hour, name=\"max_hours_camel\")\n    m.addConstr(5 * y <= max_hour, name=\"max_hours_truck\")\n    \n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the optimal total hours\n        return m.objVal\n    else:\n        # No feasible solution\n        return None\n\n# Example usage\nprint(optimize_transportation())", "output_status": [], "success_count": 0, "success_confidence": 0, "fail_to_diagnose": 0, "fail_to_verify": 0, "retrieved_insights": [], "tag": [{"problem_domain": "Resource Allocation", "modeling_type": "MILP", "industry_sector": "Logistics", "reason": "The problem involves allocating transportation resources (camel caravans and desert trucks) to meet a delivery requirement while minimizing total time and satisfying preference constraints. The solver uses integer variables and linear constraints, making it a Mixed-Integer Linear Program."}], "cluster": null, "prompt": "Below is an operations research question. First formulate the problem as an optimization problem. Then according to the formulated problem, write python code that uses 'gurobipy' to solve the optimization problem. You should write a complete python code that can be executed to solve the optimization problem.\n\nIMPORTANT: Your code should follow these requirements:\n1. Create a Gurobi model variable named 'model' (not 'm' or other names)\n2. Include all necessary imports and data setup\n3. Write the complete optimization code that can run independently\n4. Do NOT wrap everything in a function - write the code directly\n5. Make sure the model is created and optimized in the main execution flow\n6. The code should print the optimal objective value when solved successfully\n\nExample format:\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Data setup\ndata = {...}\n\n# Create model\nmodel = gp.Model(\"ProblemName\")\n\n# Decision variables\nx = model.addVars(...)\n\n# Objective\nmodel.setObjective(...)\n\n# Constraints\nmodel.addConstr(...)\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\nelse:\n    print(\"No optimal solution found\")\n```\n\n# Question:\nA company in the desert can transport goods to rural cities either by camel caravans or desert trucks. A camel caravan can deliver 50 units of goods per trip and takes 12 hours. A desert truck can deliver 150 units of goods per trip and takes 5 hours. However, due to the cost of fuel, the company prefers to have more camel caravans than desert trucks.  If the company needs to deliver 1500 units of goods, how many of each method of transportation should the company organize to minimize the total number of hours required?\n\n# Response:", "generated_output": "Below is the formulation and then the complete Python code using `gurobipy`.\n\n---\n\n## Optimization Model Formulation\n\n**Decision variables**\n\n- \\( x \\): number of camel caravan trips (integer, \\( x \\ge 0 \\))\n- \\( y \\): number of desert truck trips (integer, \\( y \\ge 0 \\))\n\n**Parameters**\n\n- Camel capacity: 50 units/trip  \n- Camel time: 12 hours/trip  \n- Truck capacity: 150 units/trip  \n- Truck time: 5 hours/trip  \n- Demand: 1500 units  \n- Preference: more camel caravans than desert trucks: \\( x \\ge y \\)\n\n**Objective**\n\nMinimize total hours of transportation:\n\\[\n\\min \\; 12x + 5y\n\\]\n\n**Constraints**\n\n1. Demand satisfaction:\n\\[\n50x + 150y \\ge 1500\n\\]\n\n2. Preference for more camels than trucks:\n\\[\nx \\ge y\n\\]\n\n3. Non-negativity and integrality:\n\\[\nx, y \\in \\mathbb{Z}_{\\ge 0}\n\\]\n\n---\n\n## Complete Python Code (Gurobi)\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Data setup\ndemand = 1500\ncamel_capacity = 50\ntruck_capacity = 150\ncamel_time = 12\ntruck_time = 5\n\n# Create model\nmodel = gp.Model(\"DesertTransport\")\n\n# Decision variables\n# x: number of camel caravan trips\n# y: number of desert truck trips\nx = model.addVar(vtype=GRB.INTEGER, name=\"camels\")\ny = model.addVar(vtype=GRB.INTEGER, name=\"trucks\")\n\n# Objective: minimize total hours = 12x + 5y\nmodel.setObjective(camel_time * x + truck_time * y, GRB.MINIMIZE)\n\n# Constraints\n\n# Demand satisfaction: 50x + 150y >= 1500\nmodel.addConstr(camel_capacity * x + truck_capacity * y >= demand, name=\"demand\")\n\n# Preference: more camel caravans than desert trucks: x >= y\nmodel.addConstr(x >= y, name=\"preference\")\n\n# Non-negativity is already enforced by default lower bound 0 for variables\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\n    print(f\"Number of camel caravan trips (x): {x.X}\")\n    print(f\"Number of desert truck trips (y): {y.X}\")\nelse:\n    print(\"No optimal solution found\")\n```", "extracted_code": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Data setup\ndemand = 1500\ncamel_capacity = 50\ntruck_capacity = 150\ncamel_time = 12\ntruck_time = 5\n\n# Create model\nmodel = gp.Model(\"DesertTransport\")\n\n# Decision variables\n# x: number of camel caravan trips\n# y: number of desert truck trips\nx = model.addVar(vtype=GRB.INTEGER, name=\"camels\")\ny = model.addVar(vtype=GRB.INTEGER, name=\"trucks\")\n\n# Objective: minimize total hours = 12x + 5y\nmodel.setObjective(camel_time * x + truck_time * y, GRB.MINIMIZE)\n\n# Constraints\n\n# Demand satisfaction: 50x + 150y >= 1500\nmodel.addConstr(camel_capacity * x + truck_capacity * y >= demand, name=\"demand\")\n\n# Preference: more camel caravans than desert trucks: x >= y\nmodel.addConstr(x >= y, name=\"preference\")\n\n# Non-negativity is already enforced by default lower bound 0 for variables\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\n    print(f\"Number of camel caravan trips (x): {x.X}\")\n    print(f\"Number of desert truck trips (y): {y.X}\")\nelse:\n    print(\"No optimal solution found\")", "execution_success": true, "mathematical_accuracy": false, "execution_result": "Execution Successful", "execution_best_solution": 136.0, "execution_state": "Execution Successful"}
{"task_id": "A096", "description": "A clinic makes batches of vitamin shots and pills. Each batch of vitamin shots requires 30 units of vitamin C and 40 units of vitamin D. Each batch of vitamin pills requires 50 units of vitamin C and 30 units of vitamin D. Since pills are more popular, the number of batches of vitamin pills must be larger than the number of batches of vitamin shots. Further, the clinic can make at most 10 batches of vitamin shots. The clinic has available 1200 units of vitamin C and 1500 units of vitamin D. If each batch of vitamin shots can supply 10 people and each batch of vitamin pills can supply 7 people, how many batches of each should be made to maximize the number of people that can be supplied?", "ground_truth": 226.0, "formulation": null, "correct_program": "def optimize_vitamin_batches():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"Vitamin_Batches\")\n\n    # Decision variables\n    # x: batches of vitamin shots\n    # y: batches of vitamin pills\n    x = m.addVar(vtype=GRB.INTEGER, name=\"x\", lb=0)\n    y = m.addVar(vtype=GRB.INTEGER, name=\"y\", lb=0)\n\n    # Set the objective: maximize total people served\n    m.setObjective(10 * x + 7 * y, GRB.MAXIMIZE)\n\n    # Add constraints\n    m.addConstr(30 * x + 50 * y <= 1200, \"VitaminC\")\n    m.addConstr(40 * x + 30 * y <= 1500, \"VitaminD\")\n    # Replace the strict inequality y > x with y >= x + 1\n    m.addConstr(y >= x + 1, \"BatchSizeRelation\")\n    m.addConstr(x <= 10, \"MaxShots\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the maximum number of people served\n        return m.objVal\n    else:\n        # No feasible solution\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    max_people_served = optimize_vitamin_batches()\n    if max_people_served is not None:\n        print(f\"Maximum People Served: {max_people_served}\")\n    else:\n        print(\"No feasible solution found.\")", "output_status": [], "success_count": 0, "success_confidence": 0, "fail_to_diagnose": 0, "fail_to_verify": 0, "retrieved_insights": [], "tag": [{"problem_domain": "Resource Allocation", "modeling_type": "MILP", "industry_sector": "Health", "reason": "The problem involves allocating limited resources (vitamin C and D) to produce different products (vitamin shots and pills) to maximize an objective (people served). The decision variables are integers, and the objective and constraints are linear, making it a Mixed-Integer Linear Program. The context of a clinic making vitamin products places it in the health sector."}], "cluster": null, "prompt": "Below is an operations research question. First formulate the problem as an optimization problem. Then according to the formulated problem, write python code that uses 'gurobipy' to solve the optimization problem. You should write a complete python code that can be executed to solve the optimization problem.\n\nIMPORTANT: Your code should follow these requirements:\n1. Create a Gurobi model variable named 'model' (not 'm' or other names)\n2. Include all necessary imports and data setup\n3. Write the complete optimization code that can run independently\n4. Do NOT wrap everything in a function - write the code directly\n5. Make sure the model is created and optimized in the main execution flow\n6. The code should print the optimal objective value when solved successfully\n\nExample format:\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Data setup\ndata = {...}\n\n# Create model\nmodel = gp.Model(\"ProblemName\")\n\n# Decision variables\nx = model.addVars(...)\n\n# Objective\nmodel.setObjective(...)\n\n# Constraints\nmodel.addConstr(...)\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\nelse:\n    print(\"No optimal solution found\")\n```\n\n# Question:\nA clinic makes batches of vitamin shots and pills. Each batch of vitamin shots requires 30 units of vitamin C and 40 units of vitamin D. Each batch of vitamin pills requires 50 units of vitamin C and 30 units of vitamin D. Since pills are more popular, the number of batches of vitamin pills must be larger than the number of batches of vitamin shots. Further, the clinic can make at most 10 batches of vitamin shots. The clinic has available 1200 units of vitamin C and 1500 units of vitamin D. If each batch of vitamin shots can supply 10 people and each batch of vitamin pills can supply 7 people, how many batches of each should be made to maximize the number of people that can be supplied?\n\n# Response:", "generated_output": "```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Create model\nmodel = gp.Model(\"Vitamin_Clinic_Production\")\n\n# Decision variables\n# x: number of batches of vitamin shots\n# y: number of batches of vitamin pills\nx = model.addVar(vtype=GRB.CONTINUOUS, name=\"shots\", lb=0)\ny = model.addVar(vtype=GRB.CONTINUOUS, name=\"pills\", lb=0)\n\n# Objective: maximize number of people supplied\n# Each batch of shots supplies 10 people, each batch of pills supplies 7 people\nmodel.setObjective(10 * x + 7 * y, GRB.MAXIMIZE)\n\n# Constraints\n\n# Vitamin C constraint: 30x + 50y <= 1200\nmodel.addConstr(30 * x + 50 * y <= 1200, name=\"vitamin_C\")\n\n# Vitamin D constraint: 40x + 30y <= 1500\nmodel.addConstr(40 * x + 30 * y <= 1500, name=\"vitamin_D\")\n\n# Popularity constraint: number of pill batches > number of shot batches\n# In linear form: y >= x + epsilon (use a small epsilon, e.g., 1e-5)\nepsilon = 1e-5\nmodel.addConstr(y >= x + epsilon, name=\"popularity\")\n\n# At most 10 batches of vitamin shots\nmodel.addConstr(x <= 10, name=\"max_shots\")\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value (max people supplied): {model.objVal}\")\n    print(f\"Optimal batches of shots (x): {x.X}\")\n    print(f\"Optimal batches of pills (y): {y.X}\")\nelse:\n    print(\"No optimal solution found\")\n```", "extracted_code": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create model\nmodel = gp.Model(\"Vitamin_Clinic_Production\")\n\n# Decision variables\n# x: number of batches of vitamin shots\n# y: number of batches of vitamin pills\nx = model.addVar(vtype=GRB.CONTINUOUS, name=\"shots\", lb=0)\ny = model.addVar(vtype=GRB.CONTINUOUS, name=\"pills\", lb=0)\n\n# Objective: maximize number of people supplied\n# Each batch of shots supplies 10 people, each batch of pills supplies 7 people\nmodel.setObjective(10 * x + 7 * y, GRB.MAXIMIZE)\n\n# Constraints\n\n# Vitamin C constraint: 30x + 50y <= 1200\nmodel.addConstr(30 * x + 50 * y <= 1200, name=\"vitamin_C\")\n\n# Vitamin D constraint: 40x + 30y <= 1500\nmodel.addConstr(40 * x + 30 * y <= 1500, name=\"vitamin_D\")\n\n# Popularity constraint: number of pill batches > number of shot batches\n# In linear form: y >= x + epsilon (use a small epsilon, e.g., 1e-5)\nepsilon = 1e-5\nmodel.addConstr(y >= x + epsilon, name=\"popularity\")\n\n# At most 10 batches of vitamin shots\nmodel.addConstr(x <= 10, name=\"max_shots\")\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value (max people supplied): {model.objVal}\")\n    print(f\"Optimal batches of shots (x): {x.X}\")\n    print(f\"Optimal batches of pills (y): {y.X}\")\nelse:\n    print(\"No optimal solution found\")", "execution_success": true, "mathematical_accuracy": true, "execution_result": "Execution Successful", "execution_best_solution": 226.0, "execution_state": "Execution Successful"}
{"task_id": "A065", "description": "A man fishes in a 250 acre lake and can catch fish either using a net or fishing line. For each acre of the lake, using a net will catch 8 fish and requires 4 units of bait but also causes 2 units of pain for the fisherman. For each acre of the lake, using a fishing line will catch 5 fish and requires 3 units of bait but also causes 1 unit of pain for the fisherman. The fisherman has available 800 units of bait and can tolerate at most 350 units of pain. For how many acres each should he use each fishing method to maximize the amount of fish he can catch?", "ground_truth": 1500.0, "formulation": null, "correct_program": "def optimize_fishing():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"FishingOptimization\")\n\n    # Decision variables: acres fished with net (x) and line (y)\n    x = m.addVar(name=\"Net_Acres\", lb=0)\n    y = m.addVar(name=\"Line_Acres\", lb=0)\n\n    # Set the objective: maximize total fish caught\n    m.setObjective(8 * x + 5 * y, GRB.MAXIMIZE)\n\n    # Add constraints\n    m.addConstr(x + y <= 250, name=\"LakeArea\")\n    m.addConstr(4 * x + 3 * y <= 800, name=\"Bait\")\n    m.addConstr(2 * x + y <= 350, name=\"Pain\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the maximum number of fish caught\n        return m.objVal\n    else:\n        # No feasible solution found\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    max_fish = optimize_fishing()\n    if max_fish is not None:\n        print(f\"Maximum Fish Caught: {max_fish}\")\n    else:\n        print(\"No feasible solution found.\")", "output_status": [], "success_count": 0, "success_confidence": 0, "fail_to_diagnose": 0, "fail_to_verify": 0, "retrieved_insights": [], "tag": [{"problem_domain": "Resource Allocation", "modeling_type": "LP", "industry_sector": "Environment", "reason": "The problem involves allocating limited resources (lake area, bait, pain tolerance) between two activities (net fishing, line fishing) to maximize a single objective (total fish caught). The relationships are linear, and variables are continuous, making it a Linear Programming problem. The application is related to fishing, which falls under environmental resource management."}], "cluster": null, "prompt": "Below is an operations research question. First formulate the problem as an optimization problem. Then according to the formulated problem, write python code that uses 'gurobipy' to solve the optimization problem. You should write a complete python code that can be executed to solve the optimization problem.\n\nIMPORTANT: Your code should follow these requirements:\n1. Create a Gurobi model variable named 'model' (not 'm' or other names)\n2. Include all necessary imports and data setup\n3. Write the complete optimization code that can run independently\n4. Do NOT wrap everything in a function - write the code directly\n5. Make sure the model is created and optimized in the main execution flow\n6. The code should print the optimal objective value when solved successfully\n\nExample format:\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Data setup\ndata = {...}\n\n# Create model\nmodel = gp.Model(\"ProblemName\")\n\n# Decision variables\nx = model.addVars(...)\n\n# Objective\nmodel.setObjective(...)\n\n# Constraints\nmodel.addConstr(...)\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\nelse:\n    print(\"No optimal solution found\")\n```\n\n# Question:\nA man fishes in a 250 acre lake and can catch fish either using a net or fishing line. For each acre of the lake, using a net will catch 8 fish and requires 4 units of bait but also causes 2 units of pain for the fisherman. For each acre of the lake, using a fishing line will catch 5 fish and requires 3 units of bait but also causes 1 unit of pain for the fisherman. The fisherman has available 800 units of bait and can tolerate at most 350 units of pain. For how many acres each should he use each fishing method to maximize the amount of fish he can catch?\n\n# Response:", "generated_output": "Below is the formulation and then the complete Python code using `gurobipy`.\n\n---\n\n## Optimization Formulation\n\nDecision variables  \n- Let \\( x \\) = acres fished using a net  \n- Let \\( y \\) = acres fished using a fishing line  \n\nObjective (maximize total fish caught):  \n\\[\n\\max \\; Z = 8x + 5y\n\\]\n\nSubject to:\n\n1. Lake size (total acres cannot exceed 250):  \n\\[\nx + y \\le 250\n\\]\n\n2. Bait availability (800 units):  \n\\[\n4x + 3y \\le 800\n\\]\n\n3. Pain tolerance (at most 350 units):  \n\\[\n2x + y \\le 350\n\\]\n\n4. Non-negativity:  \n\\[\nx \\ge 0,\\quad y \\ge 0\n\\]\n\n---\n\n## Gurobi Python Code\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Data setup\ntotal_acres = 250\nbait_available = 800\npain_limit = 350\n\nfish_net = 8      # fish per acre with net\nbait_net = 4      # bait units per acre with net\npain_net = 2      # pain units per acre with net\n\nfish_line = 5     # fish per acre with line\nbait_line = 3     # bait units per acre with line\npain_line = 1     # pain units per acre with line\n\n# Create model\nmodel = gp.Model(\"FishingProblem\")\n\n# Decision variables\n# x: acres using net\n# y: acres using fishing line\nx = model.addVar(name=\"Acres_Net\", lb=0)\ny = model.addVar(name=\"Acres_Line\", lb=0)\n\n# Objective: maximize total fish caught\nmodel.setObjective(fish_net * x + fish_line * y, GRB.MAXIMIZE)\n\n# Constraints\n\n# 1) Total acres cannot exceed lake size\nmodel.addConstr(x + y <= total_acres, name=\"LakeSize\")\n\n# 2) Bait availability\nmodel.addConstr(bait_net * x + bait_line * y <= bait_available, name=\"Bait\")\n\n# 3) Pain tolerance\nmodel.addConstr(pain_net * x + pain_line * y <= pain_limit, name=\"Pain\")\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value (maximum fish caught): {model.objVal}\")\n    print(f\"Acres using net (x): {x.X}\")\n    print(f\"Acres using line (y): {y.X}\")\nelse:\n    print(\"No optimal solution found\")\n```", "extracted_code": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Data setup\ntotal_acres = 250\nbait_available = 800\npain_limit = 350\n\nfish_net = 8      # fish per acre with net\nbait_net = 4      # bait units per acre with net\npain_net = 2      # pain units per acre with net\n\nfish_line = 5     # fish per acre with line\nbait_line = 3     # bait units per acre with line\npain_line = 1     # pain units per acre with line\n\n# Create model\nmodel = gp.Model(\"FishingProblem\")\n\n# Decision variables\n# x: acres using net\n# y: acres using fishing line\nx = model.addVar(name=\"Acres_Net\", lb=0)\ny = model.addVar(name=\"Acres_Line\", lb=0)\n\n# Objective: maximize total fish caught\nmodel.setObjective(fish_net * x + fish_line * y, GRB.MAXIMIZE)\n\n# Constraints\n\n# 1) Total acres cannot exceed lake size\nmodel.addConstr(x + y <= total_acres, name=\"LakeSize\")\n\n# 2) Bait availability\nmodel.addConstr(bait_net * x + bait_line * y <= bait_available, name=\"Bait\")\n\n# 3) Pain tolerance\nmodel.addConstr(pain_net * x + pain_line * y <= pain_limit, name=\"Pain\")\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value (maximum fish caught): {model.objVal}\")\n    print(f\"Acres using net (x): {x.X}\")\n    print(f\"Acres using line (y): {y.X}\")\nelse:\n    print(\"No optimal solution found\")", "execution_success": true, "mathematical_accuracy": true, "execution_result": "Execution Successful", "execution_best_solution": 1500.0, "execution_state": "Execution Successful"}
{"task_id": "A237", "description": "A hospital prepares batches of medication patches and anti-biotic creams. Each medication patch requires 3 minutes to prepare and 5 units of materials. Each anti-biotic cream requires 5 minutes to prepare and 6 units of materials. Since anti-biotic creams are used more often, there must be at least twice as many anti-biotic creams as medication patches. Due to storage reasons, the hospital can make at most 100 batches of medication patches and anti-biotic creams in total. The hospital has available 400 minutes of staff to spare and 530 units of materials. If each batch of medication patches can treat 3 people and each batch of anti-biotic cream can treat 2 people, how many batches of each should be made to maximize the number of people that can be treated?", "ground_truth": 214.0, "formulation": null, "correct_program": "def optimize_medication_batches():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"Hospital_Medication_Production\")\n    \n    # Decision variables: number of batches of medication patches and anti-biotic creams\n    x = m.addVar(vtype=GRB.INTEGER, name=\"Medication_Patches\")\n    y = m.addVar(vtype=GRB.INTEGER, name=\"AntiBiotic_Creams\")\n    \n    # Set the objective: maximize total number of people treated\n    m.setObjective(3 * x + 2 * y, GRB.MAXIMIZE)\n    \n    # Add constraints\n    m.addConstr(3 * x + 5 * y <= 400, \"Time_Constraint\")\n    m.addConstr(5 * x + 6 * y <= 530, \"Material_Constraint\")\n    m.addConstr(x + y <= 100, \"Batch_Limit\")\n    m.addConstr(y >= 2 * x, \"Creams_at_least_twice_patches\")\n    m.addConstr(x >= 0, \"NonNeg_x\")\n    m.addConstr(y >= 0, \"NonNeg_y\")\n    \n    # Optimize the model\n    m.optimize()\n    \n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the maximum number of people treated\n        return m.objVal\n    else:\n        # No feasible solution\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    max_people_treated = optimize_medication_batches()\n    if max_people_treated is not None:\n        print(f\"Maximum People Treated: {max_people_treated}\")\n    else:\n        print(\"No feasible solution found.\")", "output_status": [], "success_count": 0, "success_confidence": 0, "fail_to_diagnose": 0, "fail_to_verify": 0, "retrieved_insights": [], "tag": [{"problem_domain": "Resource Allocation", "modeling_type": "MILP", "industry_sector": "Health", "reason": "The problem involves allocating limited resources (time, materials, storage) to produce different types of medication batches to maximize a specific objective (people treated). The solver uses integer variables and linear constraints, making it a Mixed-Integer Linear Program."}], "cluster": null, "prompt": "Below is an operations research question. First formulate the problem as an optimization problem. Then according to the formulated problem, write python code that uses 'gurobipy' to solve the optimization problem. You should write a complete python code that can be executed to solve the optimization problem.\n\nIMPORTANT: Your code should follow these requirements:\n1. Create a Gurobi model variable named 'model' (not 'm' or other names)\n2. Include all necessary imports and data setup\n3. Write the complete optimization code that can run independently\n4. Do NOT wrap everything in a function - write the code directly\n5. Make sure the model is created and optimized in the main execution flow\n6. The code should print the optimal objective value when solved successfully\n\nExample format:\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Data setup\ndata = {...}\n\n# Create model\nmodel = gp.Model(\"ProblemName\")\n\n# Decision variables\nx = model.addVars(...)\n\n# Objective\nmodel.setObjective(...)\n\n# Constraints\nmodel.addConstr(...)\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\nelse:\n    print(\"No optimal solution found\")\n```\n\n# Question:\nA hospital prepares batches of medication patches and anti-biotic creams. Each medication patch requires 3 minutes to prepare and 5 units of materials. Each anti-biotic cream requires 5 minutes to prepare and 6 units of materials. Since anti-biotic creams are used more often, there must be at least twice as many anti-biotic creams as medication patches. Due to storage reasons, the hospital can make at most 100 batches of medication patches and anti-biotic creams in total. The hospital has available 400 minutes of staff to spare and 530 units of materials. If each batch of medication patches can treat 3 people and each batch of anti-biotic cream can treat 2 people, how many batches of each should be made to maximize the number of people that can be treated?\n\n# Response:", "generated_output": "**Formulation**\n\nLet  \n- \\(x\\) = number of batches of medication patches  \n- \\(y\\) = number of batches of anti-biotic creams  \n\nMaximize the total number of people treated:\n\\[\n\\max \\; 3x + 2y\n\\]\n\nSubject to:\n\n1. Time (minutes):  \n\\[\n3x + 5y \\le 400\n\\]\n\n2. Materials (units):  \n\\[\n5x + 6y \\le 530\n\\]\n\n3. Demand relationship (at least twice as many creams as patches):  \n\\[\ny \\ge 2x\n\\]\n\n4. Storage (total batches at most 100):  \n\\[\nx + y \\le 100\n\\]\n\n5. Non-negativity:  \n\\[\nx \\ge 0,\\; y \\ge 0\n\\]\n\n(We will treat \\(x, y\\) as continuous; if integer batches are required, we can set them as integer variables.)\n\n---\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Create model\nmodel = gp.Model(\"HospitalMedicationPlanning\")\n\n# Decision variables\n# If batches must be integer, use vtype=GRB.INTEGER\nx = model.addVar(lb=0, vtype=GRB.CONTINUOUS, name=\"patch_batches\")\ny = model.addVar(lb=0, vtype=GRB.CONTINUOUS, name=\"cream_batches\")\n\n# Objective: maximize number of people treated = 3x + 2y\nmodel.setObjective(3 * x + 2 * y, GRB.MAXIMIZE)\n\n# Constraints\n\n# Time constraint: 3x + 5y <= 400\nmodel.addConstr(3 * x + 5 * y <= 400, name=\"time\")\n\n# Material constraint: 5x + 6y <= 530\nmodel.addConstr(5 * x + 6 * y <= 530, name=\"materials\")\n\n# At least twice as many creams as patches: y >= 2x\nmodel.addConstr(y >= 2 * x, name=\"demand_ratio\")\n\n# Storage constraint: x + y <= 100\nmodel.addConstr(x + y <= 100, name=\"storage\")\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value (max people treated): {model.objVal}\")\n    print(f\"Optimal batches of medication patches (x): {x.X}\")\n    print(f\"Optimal batches of anti-biotic creams (y): {y.X}\")\nelse:\n    print(\"No optimal solution found\")\n```", "extracted_code": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create model\nmodel = gp.Model(\"HospitalMedicationPlanning\")\n\n# Decision variables\n# If batches must be integer, use vtype=GRB.INTEGER\nx = model.addVar(lb=0, vtype=GRB.CONTINUOUS, name=\"patch_batches\")\ny = model.addVar(lb=0, vtype=GRB.CONTINUOUS, name=\"cream_batches\")\n\n# Objective: maximize number of people treated = 3x + 2y\nmodel.setObjective(3 * x + 2 * y, GRB.MAXIMIZE)\n\n# Constraints\n\n# Time constraint: 3x + 5y <= 400\nmodel.addConstr(3 * x + 5 * y <= 400, name=\"time\")\n\n# Material constraint: 5x + 6y <= 530\nmodel.addConstr(5 * x + 6 * y <= 530, name=\"materials\")\n\n# At least twice as many creams as patches: y >= 2x\nmodel.addConstr(y >= 2 * x, name=\"demand_ratio\")\n\n# Storage constraint: x + y <= 100\nmodel.addConstr(x + y <= 100, name=\"storage\")\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value (max people treated): {model.objVal}\")\n    print(f\"Optimal batches of medication patches (x): {x.X}\")\n    print(f\"Optimal batches of anti-biotic creams (y): {y.X}\")\nelse:\n    print(\"No optimal solution found\")", "execution_success": true, "mathematical_accuracy": true, "execution_result": "Execution Successful", "execution_best_solution": 215.3846153846154, "execution_state": "Execution Successful"}
{"task_id": "A049", "description": "An oil and gas company operates on 300 acres of land where they use oil wells of small and large size. Per acre of land, a small oil well can produce 2 barrels of oil. Per acre of land, a large oil well can produce 5 barrels of oil. However, a small oil well produces 10 units of pollution and requires 5 drill bits per acre and a large oil well produces 20 units of pollution and requires 10 drill bits per acre. The company has available 2500 drill bits and due to strict environmental laws can produce at most 4500 units of pollution. For how many acres should each oil well be used to maximize the total production of oil?", "ground_truth": 1125.0, "formulation": null, "correct_program": "def optimize_oil_production(\n    total_land=300,\n    max_drill_bits=2500,\n    max_pollution=4500\n):\n    import gurobipy as gp\n    from gurobipy import GRB\n\n    # Create a new model\n    model = gp.Model(\"Oil_Well_Allocation\")\n\n    # Decision variables: acres for small and large wells\n    x = model.addVar(name=\"small_wells_acres\", lb=0)\n    y = model.addVar(name=\"large_wells_acres\", lb=0)\n\n    # Set objective: maximize total oil production\n    model.setObjective(2 * x + 5 * y, GRB.MAXIMIZE)\n\n    # Add constraints\n    # Land constraint\n    model.addConstr(x + y <= total_land, name=\"land_constraint\")\n    # Drill bits constraint\n    model.addConstr(5 * x + 10 * y <= max_drill_bits, name=\"drill_bits_constraint\")\n    # Pollution constraint\n    model.addConstr(10 * x + 20 * y <= max_pollution, name=\"pollution_constraint\")\n\n    # Optimize the model\n    model.optimize()\n\n    # Check if a feasible solution was found\n    if model.status == GRB.OPTIMAL:\n        # Return the optimal total oil production\n        return model.objVal\n    else:\n        # No feasible solution found\n        return None\n\n# Example usage\nif __name__ == \"__main__\":\n    max_oil_production = optimize_oil_production()\n    if max_oil_production is not None:\n        print(f\"Maximum Total Oil Production: {max_oil_production}\")\n    else:\n        print(\"No feasible solution found.\")", "output_status": [], "success_count": 0, "success_confidence": 0, "fail_to_diagnose": 0, "fail_to_verify": 0, "retrieved_insights": [], "tag": [{"problem_domain": "Resource Allocation", "modeling_type": "LP", "industry_sector": "Oil and Gas", "reason": "The problem involves allocating limited resources (land, drill bits, pollution capacity) to different activities (small and large oil wells) to maximize a single objective (oil production). The solver uses linear equations for the objective and constraints, and decision variables are continuous, fitting the characteristics of a Linear Program."}], "cluster": null, "prompt": "Below is an operations research question. First formulate the problem as an optimization problem. Then according to the formulated problem, write python code that uses 'gurobipy' to solve the optimization problem. You should write a complete python code that can be executed to solve the optimization problem.\n\nIMPORTANT: Your code should follow these requirements:\n1. Create a Gurobi model variable named 'model' (not 'm' or other names)\n2. Include all necessary imports and data setup\n3. Write the complete optimization code that can run independently\n4. Do NOT wrap everything in a function - write the code directly\n5. Make sure the model is created and optimized in the main execution flow\n6. The code should print the optimal objective value when solved successfully\n\nExample format:\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Data setup\ndata = {...}\n\n# Create model\nmodel = gp.Model(\"ProblemName\")\n\n# Decision variables\nx = model.addVars(...)\n\n# Objective\nmodel.setObjective(...)\n\n# Constraints\nmodel.addConstr(...)\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\nelse:\n    print(\"No optimal solution found\")\n```\n\n# Question:\nAn oil and gas company operates on 300 acres of land where they use oil wells of small and large size. Per acre of land, a small oil well can produce 2 barrels of oil. Per acre of land, a large oil well can produce 5 barrels of oil. However, a small oil well produces 10 units of pollution and requires 5 drill bits per acre and a large oil well produces 20 units of pollution and requires 10 drill bits per acre. The company has available 2500 drill bits and due to strict environmental laws can produce at most 4500 units of pollution. For how many acres should each oil well be used to maximize the total production of oil?\n\n# Response:", "generated_output": "Below is the formulation and then the complete Python code using `gurobipy`.\n\n---\n\n## Optimization Model Formulation\n\n**Decision variables**\n\n- \\( x_s \\ge 0 \\): acres of land used for small oil wells  \n- \\( x_l \\ge 0 \\): acres of land used for large oil wells  \n\n**Objective**\n\nMaximize total oil production (barrels):\n\n\\[\n\\max \\; Z = 2x_s + 5x_l\n\\]\n\n**Constraints**\n\n1. Land availability (300 acres total):\n\\[\nx_s + x_l \\le 300\n\\]\n\n2. Drill bits availability (2500 drill bits total):  \nSmall: 5 bits/acre, Large: 10 bits/acre\n\\[\n5x_s + 10x_l \\le 2500\n\\]\n\n3. Pollution limit (4500 units total):  \nSmall: 10 units/acre, Large: 20 units/acre\n\\[\n10x_s + 20x_l \\le 4500\n\\]\n\n4. Non-negativity:\n\\[\nx_s \\ge 0,\\quad x_l \\ge 0\n\\]\n\n---\n\n## Complete Python Code (Gurobi)\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Data setup\ntotal_land = 300          # acres\ndrill_bits_available = 2500\npollution_limit = 4500\n\n# Per-acre parameters\nprod_small = 2            # barrels per acre (small well)\nprod_large = 5            # barrels per acre (large well)\n\nbits_small = 5            # drill bits per acre (small well)\nbits_large = 10           # drill bits per acre (large well)\n\npoll_small = 10           # pollution units per acre (small well)\npoll_large = 20           # pollution units per acre (large well)\n\n# Create model\nmodel = gp.Model(\"Oil_Well_Planning\")\n\n# Decision variables: acres of land for small and large wells\nx_small = model.addVar(lb=0, vtype=GRB.CONTINUOUS, name=\"x_small\")\nx_large = model.addVar(lb=0, vtype=GRB.CONTINUOUS, name=\"x_large\")\n\n# Objective: maximize total oil production\nmodel.setObjective(\n    prod_small * x_small + prod_large * x_large,\n    GRB.MAXIMIZE\n)\n\n# Constraints\n\n# 1. Land availability\nmodel.addConstr(x_small + x_large <= total_land, name=\"Land\")\n\n# 2. Drill bits availability\nmodel.addConstr(\n    bits_small * x_small + bits_large * x_large <= drill_bits_available,\n    name=\"DrillBits\"\n)\n\n# 3. Pollution limit\nmodel.addConstr(\n    poll_small * x_small + poll_large * x_large <= pollution_limit,\n    name=\"Pollution\"\n)\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value (max barrels of oil): {model.objVal}\")\n    print(f\"Acres for small wells (x_small): {x_small.X}\")\n    print(f\"Acres for large wells (x_large): {x_large.X}\")\nelse:\n    print(\"No optimal solution found\")\n```", "extracted_code": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Data setup\ntotal_land = 300          # acres\ndrill_bits_available = 2500\npollution_limit = 4500\n\n# Per-acre parameters\nprod_small = 2            # barrels per acre (small well)\nprod_large = 5            # barrels per acre (large well)\n\nbits_small = 5            # drill bits per acre (small well)\nbits_large = 10           # drill bits per acre (large well)\n\npoll_small = 10           # pollution units per acre (small well)\npoll_large = 20           # pollution units per acre (large well)\n\n# Create model\nmodel = gp.Model(\"Oil_Well_Planning\")\n\n# Decision variables: acres of land for small and large wells\nx_small = model.addVar(lb=0, vtype=GRB.CONTINUOUS, name=\"x_small\")\nx_large = model.addVar(lb=0, vtype=GRB.CONTINUOUS, name=\"x_large\")\n\n# Objective: maximize total oil production\nmodel.setObjective(\n    prod_small * x_small + prod_large * x_large,\n    GRB.MAXIMIZE\n)\n\n# Constraints\n\n# 1. Land availability\nmodel.addConstr(x_small + x_large <= total_land, name=\"Land\")\n\n# 2. Drill bits availability\nmodel.addConstr(\n    bits_small * x_small + bits_large * x_large <= drill_bits_available,\n    name=\"DrillBits\"\n)\n\n# 3. Pollution limit\nmodel.addConstr(\n    poll_small * x_small + poll_large * x_large <= pollution_limit,\n    name=\"Pollution\"\n)\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value (max barrels of oil): {model.objVal}\")\n    print(f\"Acres for small wells (x_small): {x_small.X}\")\n    print(f\"Acres for large wells (x_large): {x_large.X}\")\nelse:\n    print(\"No optimal solution found\")", "execution_success": true, "mathematical_accuracy": true, "execution_result": "Execution Successful", "execution_best_solution": 1125.0, "execution_state": "Execution Successful"}
{"task_id": "A233", "description": "A researcher must perform two types of experiments, in-vivo and ex-vivo. In-vivo experiments requires 30 minutes to prepare and 60 minutes to execute. Ex-vivo experiments require 45 minutes to prepare and 30 minutes to execute. In addition, in-vivo experiments gives the researcher 2 units of radiation while ex-vivo experiments give the researcher 3 unites of radiation. At most 400 minutes can be used for preparation and 500 minutes for execution of the experiment. How many of each experiment should be scheduled by the researcher to minimize the total radiation received by the researcher?", "ground_truth": 0.0, "formulation": null, "correct_program": "def minimize_radiation(prep_time_limit=400, exec_time_limit=500):\n    import gurobipy as gp\n    from gurobipy import GRB\n\n    # Create a new model\n    model = gp.Model(\"Minimize_Radiation\")\n\n    # Decision variables: number of experiments\n    x = model.addVar(vtype=GRB.INTEGER, name=\"InVivo\")\n    y = model.addVar(vtype=GRB.INTEGER, name=\"ExVivo\")\n\n    # Set objective: minimize total radiation\n    model.setObjective(2 * x + 3 * y, GRB.MINIMIZE)\n\n    # Add preparation time constraint\n    model.addConstr(30 * x + 45 * y <= prep_time_limit, \"PrepTimeLimit\")\n\n    # Add execution time constraint\n    model.addConstr(60 * x + 30 * y <= exec_time_limit, \"ExecTimeLimit\")\n\n    # Optimize the model\n    model.optimize()\n\n    # Check if a feasible solution was found\n    if model.status == GRB.OPTIMAL:\n        return model.objVal\n    else:\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    min_radiation = minimize_radiation()\n    if min_radiation is not None:\n        print(f\"Minimum Total Radiation: {min_radiation}\")\n    else:\n        print(\"No feasible solution found.\")", "output_status": [], "success_count": 0, "success_confidence": 0, "fail_to_diagnose": 0, "fail_to_verify": 0, "retrieved_insights": [], "tag": [{"problem_domain": "Resource Allocation", "modeling_type": "IP", "industry_sector": "Health", "reason": "The problem involves allocating limited preparation and execution time resources to two types of experiments to minimize radiation exposure. Since the decision variables (number of experiments) must be integers, it falls under Integer Programming. The context of experiments and radiation relates to the health sector."}], "cluster": null, "prompt": "Below is an operations research question. First formulate the problem as an optimization problem. Then according to the formulated problem, write python code that uses 'gurobipy' to solve the optimization problem. You should write a complete python code that can be executed to solve the optimization problem.\n\nIMPORTANT: Your code should follow these requirements:\n1. Create a Gurobi model variable named 'model' (not 'm' or other names)\n2. Include all necessary imports and data setup\n3. Write the complete optimization code that can run independently\n4. Do NOT wrap everything in a function - write the code directly\n5. Make sure the model is created and optimized in the main execution flow\n6. The code should print the optimal objective value when solved successfully\n\nExample format:\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Data setup\ndata = {...}\n\n# Create model\nmodel = gp.Model(\"ProblemName\")\n\n# Decision variables\nx = model.addVars(...)\n\n# Objective\nmodel.setObjective(...)\n\n# Constraints\nmodel.addConstr(...)\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\nelse:\n    print(\"No optimal solution found\")\n```\n\n# Question:\nA researcher must perform two types of experiments, in-vivo and ex-vivo. In-vivo experiments requires 30 minutes to prepare and 60 minutes to execute. Ex-vivo experiments require 45 minutes to prepare and 30 minutes to execute. In addition, in-vivo experiments gives the researcher 2 units of radiation while ex-vivo experiments give the researcher 3 unites of radiation. At most 400 minutes can be used for preparation and 500 minutes for execution of the experiment. How many of each experiment should be scheduled by the researcher to minimize the total radiation received by the researcher?\n\n# Response:", "generated_output": "Below is the formulation and then the complete Python code using `gurobipy`.\n\n---\n\n## Optimization Model Formulation\n\nDecision variables  \n- \\( x \\): number of in-vivo experiments (nonnegative)  \n- \\( y \\): number of ex-vivo experiments (nonnegative)\n\nObjective (minimize total radiation):\n\\[\n\\min \\; Z = 2x + 3y\n\\]\n\nConstraints:\n\n1. Preparation time (minutes):\n\\[\n30x + 45y \\le 400\n\\]\n\n2. Execution time (minutes):\n\\[\n60x + 30y \\le 500\n\\]\n\n3. Nonnegativity:\n\\[\nx \\ge 0,\\quad y \\ge 0\n\\]\n\n(If experiments must be whole numbers, we treat \\(x, y\\) as integers; the code below uses integer variables.)\n\n---\n\n## Python Code (Gurobi)\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Create model\nmodel = gp.Model(\"Radiation_Minimization\")\n\n# Decision variables\n# Assuming the number of experiments must be integer and nonnegative\nx = model.addVar(vtype=GRB.INTEGER, name=\"in_vivo\", lb=0)\ny = model.addVar(vtype=GRB.INTEGER, name=\"ex_vivo\", lb=0)\n\n# Update model to integrate new variables\nmodel.update()\n\n# Objective: minimize total radiation 2x + 3y\nmodel.setObjective(2 * x + 3 * y, GRB.MINIMIZE)\n\n# Constraints\n\n# Preparation time: 30x + 45y <= 400\nmodel.addConstr(30 * x + 45 * y <= 400, name=\"prep_time\")\n\n# Execution time: 60x + 30y <= 500\nmodel.addConstr(60 * x + 30 * y <= 500, name=\"exec_time\")\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\n    print(f\"Number of in-vivo experiments (x): {x.X}\")\n    print(f\"Number of ex-vivo experiments (y): {y.X}\")\nelse:\n    print(\"No optimal solution found\")\n```", "extracted_code": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create model\nmodel = gp.Model(\"Radiation_Minimization\")\n\n# Decision variables\n# Assuming the number of experiments must be integer and nonnegative\nx = model.addVar(vtype=GRB.INTEGER, name=\"in_vivo\", lb=0)\ny = model.addVar(vtype=GRB.INTEGER, name=\"ex_vivo\", lb=0)\n\n# Update model to integrate new variables\nmodel.update()\n\n# Objective: minimize total radiation 2x + 3y\nmodel.setObjective(2 * x + 3 * y, GRB.MINIMIZE)\n\n# Constraints\n\n# Preparation time: 30x + 45y <= 400\nmodel.addConstr(30 * x + 45 * y <= 400, name=\"prep_time\")\n\n# Execution time: 60x + 30y <= 500\nmodel.addConstr(60 * x + 30 * y <= 500, name=\"exec_time\")\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\n    print(f\"Number of in-vivo experiments (x): {x.X}\")\n    print(f\"Number of ex-vivo experiments (y): {y.X}\")\nelse:\n    print(\"No optimal solution found\")", "execution_success": true, "mathematical_accuracy": true, "execution_result": "Execution Successful", "execution_best_solution": 0.0, "execution_state": "Execution Successful"}
{"task_id": "A064", "description": "A scientist is conducting two experiments to produce electricity, experiment alpha and experiment beta. In experiment alpha, 3 units of metal and 5 units of acid are required to produce 8 units of electricity. In experiment beta, 5 units of metal and 4 units of acid are required to produced 10 units of electricity. The lab has 800 units of metal and 750 units of acid available. How many of each experiment should the scientist conduct to maximize the total amount of electricity produced?", "ground_truth": 1684.6153846153848, "formulation": null, "correct_program": "def optimize_experiments(metal_available=800, acid_available=750):\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"Electricity_Production\")\n\n    # Decision variables: number of experiments for alpha and beta\n    x = m.addVar(name=\"alpha_experiments\", lb=0)\n    y = m.addVar(name=\"beta_experiments\", lb=0)\n\n    # Set the objective: maximize total electricity\n    m.setObjective(8 * x + 10 * y, GRB.MAXIMIZE)\n\n    # Add constraints\n    m.addConstr(3 * x + 5 * y <= metal_available, name=\"metal_constraint\")\n    m.addConstr(5 * x + 4 * y <= acid_available, name=\"acid_constraint\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the maximum total electricity produced\n        return m.objVal\n    else:\n        # No feasible solution found\n        return None\n\n# Example usage\nif __name__ == \"__main__\":\n    max_electricity = optimize_experiments()\n    if max_electricity is not None:\n        print(f\"Maximum Total Electricity Produced: {max_electricity}\")\n    else:\n        print(\"No feasible solution found.\")", "output_status": [], "success_count": 0, "success_confidence": 0, "fail_to_diagnose": 0, "fail_to_verify": 0, "retrieved_insights": [], "tag": [{"problem_domain": "Resource Allocation", "modeling_type": "LP", "industry_sector": "Research & Development", "reason": "The problem involves allocating limited resources (metal and acid) to different activities (experiments alpha and beta) to maximize an objective (total electricity produced). The decision variables are continuous (number of experiments can be fractional), and the objective and constraints are linear, fitting the characteristics of a Linear Program. The context of conducting experiments to produce electricity falls under Research & Development."}], "cluster": null, "prompt": "Below is an operations research question. First formulate the problem as an optimization problem. Then according to the formulated problem, write python code that uses 'gurobipy' to solve the optimization problem. You should write a complete python code that can be executed to solve the optimization problem.\n\nIMPORTANT: Your code should follow these requirements:\n1. Create a Gurobi model variable named 'model' (not 'm' or other names)\n2. Include all necessary imports and data setup\n3. Write the complete optimization code that can run independently\n4. Do NOT wrap everything in a function - write the code directly\n5. Make sure the model is created and optimized in the main execution flow\n6. The code should print the optimal objective value when solved successfully\n\nExample format:\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Data setup\ndata = {...}\n\n# Create model\nmodel = gp.Model(\"ProblemName\")\n\n# Decision variables\nx = model.addVars(...)\n\n# Objective\nmodel.setObjective(...)\n\n# Constraints\nmodel.addConstr(...)\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\nelse:\n    print(\"No optimal solution found\")\n```\n\n# Question:\nA scientist is conducting two experiments to produce electricity, experiment alpha and experiment beta. In experiment alpha, 3 units of metal and 5 units of acid are required to produce 8 units of electricity. In experiment beta, 5 units of metal and 4 units of acid are required to produced 10 units of electricity. The lab has 800 units of metal and 750 units of acid available. How many of each experiment should the scientist conduct to maximize the total amount of electricity produced?\n\n# Response:", "generated_output": "```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# =========================\n# Data setup\n# =========================\n# Resources\nmetal_available = 800\nacid_available = 750\n\n# Resource usage per experiment\nmetal_alpha = 3\nacid_alpha = 5\nelectricity_alpha = 8\n\nmetal_beta = 5\nacid_beta = 4\nelectricity_beta = 10\n\n# =========================\n# Create model\n# =========================\nmodel = gp.Model(\"Electricity_Production\")\n\n# =========================\n# Decision variables\n# =========================\n# x_alpha: number of times experiment alpha is conducted\n# x_beta: number of times experiment beta is conducted\nx_alpha = model.addVar(name=\"x_alpha\", lb=0, vtype=GRB.CONTINUOUS)\nx_beta = model.addVar(name=\"x_beta\", lb=0, vtype=GRB.CONTINUOUS)\n\n# =========================\n# Objective: maximize total electricity\n# =========================\nmodel.setObjective(\n    electricity_alpha * x_alpha + electricity_beta * x_beta,\n    GRB.MAXIMIZE\n)\n\n# =========================\n# Constraints\n# =========================\n# Metal constraint\nmodel.addConstr(\n    metal_alpha * x_alpha + metal_beta * x_beta <= metal_available,\n    name=\"Metal_Constraint\"\n)\n\n# Acid constraint\nmodel.addConstr(\n    acid_alpha * x_alpha + acid_beta * x_beta <= acid_available,\n    name=\"Acid_Constraint\"\n)\n\n# =========================\n# Optimize\n# =========================\nmodel.optimize()\n\n# =========================\n# Results\n# =========================\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value (total electricity): {model.objVal}\")\n    print(f\"Optimal x_alpha (experiment alpha): {x_alpha.X}\")\n    print(f\"Optimal x_beta (experiment beta): {x_beta.X}\")\nelse:\n    print(\"No optimal solution found\")\n```", "extracted_code": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# =========================\n# Data setup\n# =========================\n# Resources\nmetal_available = 800\nacid_available = 750\n\n# Resource usage per experiment\nmetal_alpha = 3\nacid_alpha = 5\nelectricity_alpha = 8\n\nmetal_beta = 5\nacid_beta = 4\nelectricity_beta = 10\n\n# =========================\n# Create model\n# =========================\nmodel = gp.Model(\"Electricity_Production\")\n\n# =========================\n# Decision variables\n# =========================\n# x_alpha: number of times experiment alpha is conducted\n# x_beta: number of times experiment beta is conducted\nx_alpha = model.addVar(name=\"x_alpha\", lb=0, vtype=GRB.CONTINUOUS)\nx_beta = model.addVar(name=\"x_beta\", lb=0, vtype=GRB.CONTINUOUS)\n\n# =========================\n# Objective: maximize total electricity\n# =========================\nmodel.setObjective(\n    electricity_alpha * x_alpha + electricity_beta * x_beta,\n    GRB.MAXIMIZE\n)\n\n# =========================\n# Constraints\n# =========================\n# Metal constraint\nmodel.addConstr(\n    metal_alpha * x_alpha + metal_beta * x_beta <= metal_available,\n    name=\"Metal_Constraint\"\n)\n\n# Acid constraint\nmodel.addConstr(\n    acid_alpha * x_alpha + acid_beta * x_beta <= acid_available,\n    name=\"Acid_Constraint\"\n)\n\n# =========================\n# Optimize\n# =========================\nmodel.optimize()\n\n# =========================\n# Results\n# =========================\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value (total electricity): {model.objVal}\")\n    print(f\"Optimal x_alpha (experiment alpha): {x_alpha.X}\")\n    print(f\"Optimal x_beta (experiment beta): {x_beta.X}\")\nelse:\n    print(\"No optimal solution found\")", "execution_success": true, "mathematical_accuracy": true, "execution_result": "Execution Successful", "execution_best_solution": 1684.6153846153848, "execution_state": "Execution Successful"}
{"task_id": "A177", "description": "Bob wants to design a diet consisting of protein bars and noodles. Assume that each serving of noodles costs $5 and contains 600 calories and 1.5 grams of protein. Assume that each serving of protein bar costs $2.5 and contains 250 calories and 5 grams of protein. He's interested in spending as little money as possible but he wants to ensure that his meals have at least 2000 calories and at least 16 grams of protein per day. Formulate a linear programming problem that will help minimize the cost of the diet.", "ground_truth": 17.71428571428571, "formulation": null, "correct_program": "def optimize_diet():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"DietOptimization\")\n\n    # Decision variables: servings of noodles (x) and protein bars (y)\n    x = m.addVar(name=\"noodles\", lb=0)\n    y = m.addVar(name=\"protein_bars\", lb=0)\n\n    # Set the objective: minimize total cost\n    m.setObjective(5 * x + 2.5 * y, GRB.MINIMIZE)\n\n    # Add calorie constraint\n    m.addConstr(600 * x + 250 * y >= 2000, name=\"calories\")\n    # Add protein constraint\n    m.addConstr(1.5 * x + 5 * y >= 16, name=\"protein\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the optimal cost\n        return m.objVal\n    else:\n        # No feasible solution found\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    min_cost = optimize_diet()\n    if min_cost is not None:\n        print(f\"Minimum Cost: {min_cost}\")\n    else:\n        print(\"No feasible solution found.\")", "output_status": [], "success_count": 0, "success_confidence": 0, "fail_to_diagnose": 0, "fail_to_verify": 0, "retrieved_insights": [], "tag": [{"problem_domain": "Resource Allocation", "modeling_type": "LP", "industry_sector": "Health", "reason": "The problem involves allocating resources (servings of noodles and protein bars) to meet nutritional requirements at minimum cost, which is a classic resource allocation problem. The model uses continuous variables and linear objective/constraints, making it a Linear Program. The application directly relates to dietary planning and nutritional intake, falling under the health sector."}], "cluster": null, "prompt": "Below is an operations research question. First formulate the problem as an optimization problem. Then according to the formulated problem, write python code that uses 'gurobipy' to solve the optimization problem. You should write a complete python code that can be executed to solve the optimization problem.\n\nIMPORTANT: Your code should follow these requirements:\n1. Create a Gurobi model variable named 'model' (not 'm' or other names)\n2. Include all necessary imports and data setup\n3. Write the complete optimization code that can run independently\n4. Do NOT wrap everything in a function - write the code directly\n5. Make sure the model is created and optimized in the main execution flow\n6. The code should print the optimal objective value when solved successfully\n\nExample format:\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Data setup\ndata = {...}\n\n# Create model\nmodel = gp.Model(\"ProblemName\")\n\n# Decision variables\nx = model.addVars(...)\n\n# Objective\nmodel.setObjective(...)\n\n# Constraints\nmodel.addConstr(...)\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\nelse:\n    print(\"No optimal solution found\")\n```\n\n# Question:\nBob wants to design a diet consisting of protein bars and noodles. Assume that each serving of noodles costs $5 and contains 600 calories and 1.5 grams of protein. Assume that each serving of protein bar costs $2.5 and contains 250 calories and 5 grams of protein. He's interested in spending as little money as possible but he wants to ensure that his meals have at least 2000 calories and at least 16 grams of protein per day. Formulate a linear programming problem that will help minimize the cost of the diet.\n\n# Response:", "generated_output": "**Formulation**\n\nLet  \n- \\(x_1\\) = number of servings of noodles per day  \n- \\(x_2\\) = number of servings of protein bars per day  \n\nObjective: minimize total daily cost  \n\\[\n\\min \\; Z = 5x_1 + 2.5x_2\n\\]\n\nSubject to calorie requirement (at least 2000 calories):  \n\\[\n600x_1 + 250x_2 \\ge 2000\n\\]\n\nSubject to protein requirement (at least 16 grams):  \n\\[\n1.5x_1 + 5x_2 \\ge 16\n\\]\n\nNon-negativity:  \n\\[\nx_1 \\ge 0,\\quad x_2 \\ge 0\n\\]\n\n---\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Create model\nmodel = gp.Model(\"DietProblem\")\n\n# Decision variables\n# x1: servings of noodles\n# x2: servings of protein bars\nx1 = model.addVar(name=\"noodles\", lb=0.0)\nx2 = model.addVar(name=\"protein_bars\", lb=0.0)\n\nmodel.update()\n\n# Objective: minimize total cost\n# Cost: $5 per serving of noodles, $2.5 per serving of protein bar\nmodel.setObjective(5 * x1 + 2.5 * x2, GRB.MINIMIZE)\n\n# Constraints\n\n# Calorie constraint: at least 2000 calories\n# Noodles: 600 cal/serving, Protein bar: 250 cal/serving\nmodel.addConstr(600 * x1 + 250 * x2 >= 2000, name=\"calories_min\")\n\n# Protein constraint: at least 16 grams\n# Noodles: 1.5 g/serving, Protein bar: 5 g/serving\nmodel.addConstr(1.5 * x1 + 5 * x2 >= 16, name=\"protein_min\")\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\n    print(f\"Optimal servings of noodles: {x1.X}\")\n    print(f\"Optimal servings of protein bars: {x2.X}\")\nelse:\n    print(\"No optimal solution found\")\n```", "extracted_code": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create model\nmodel = gp.Model(\"DietProblem\")\n\n# Decision variables\n# x1: servings of noodles\n# x2: servings of protein bars\nx1 = model.addVar(name=\"noodles\", lb=0.0)\nx2 = model.addVar(name=\"protein_bars\", lb=0.0)\n\nmodel.update()\n\n# Objective: minimize total cost\n# Cost: $5 per serving of noodles, $2.5 per serving of protein bar\nmodel.setObjective(5 * x1 + 2.5 * x2, GRB.MINIMIZE)\n\n# Constraints\n\n# Calorie constraint: at least 2000 calories\n# Noodles: 600 cal/serving, Protein bar: 250 cal/serving\nmodel.addConstr(600 * x1 + 250 * x2 >= 2000, name=\"calories_min\")\n\n# Protein constraint: at least 16 grams\n# Noodles: 1.5 g/serving, Protein bar: 5 g/serving\nmodel.addConstr(1.5 * x1 + 5 * x2 >= 16, name=\"protein_min\")\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\n    print(f\"Optimal servings of noodles: {x1.X}\")\n    print(f\"Optimal servings of protein bars: {x2.X}\")\nelse:\n    print(\"No optimal solution found\")", "execution_success": true, "mathematical_accuracy": true, "execution_result": "Execution Successful", "execution_best_solution": 17.71428571428571, "execution_state": "Execution Successful"}
{"task_id": "A008", "description": "A grocery store wants to liquidate its stock of 10 apples, 20 bananas, and 80 grapes. Given past experience, the store knows that they can propose a banana-haters package with 6 apples and 30 grapes and that this package will bring a profit of six euros. Similarly, they can prepare a combo package with 5 apples, 6 bananas, and 20 grapes, yielding a profit of seven euros. They know they can sell any quantity of these two packages within the availability of its stock. What quantity of each package, banana-haters packages and combo packages, should the store prepare to maximize net profit?", "ground_truth": 14.0, "formulation": null, "correct_program": "def optimize_package_production():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"Grocery_Packages\")\n\n    # Decision variables: number of packages (integer,  0)\n    x = m.addVar(vtype=GRB.INTEGER, name=\"banana_haters\")\n    y = m.addVar(vtype=GRB.INTEGER, name=\"combo\")\n\n    # Set objective: maximize total profit\n    m.setObjective(6 * x + 7 * y, GRB.MAXIMIZE)\n\n    # Add constraints\n    # Apples constraint\n    m.addConstr(6 * x + 5 * y <= 10, \"apple_limit\")\n    # Grapes constraint\n    m.addConstr(30 * x + 20 * y <= 80, \"grape_limit\")\n    # Bananas constraint\n    m.addConstr(6 * y <= 20, \"banana_limit\")\n    # Non-negativity is implicit in variable definition\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        return m.objVal\n    else:\n        return None\n\n# Example usage\nif __name__ == \"__main__\":\n    max_profit = optimize_package_production()\n    if max_profit is not None:\n        print(f\"Maximum Profit: {max_profit}\")\n    else:\n        print(\"No feasible solution found.\")", "output_status": [], "success_count": 0, "success_confidence": 0, "fail_to_diagnose": 0, "fail_to_verify": 0, "retrieved_insights": [], "tag": [{"problem_domain": "Resource Allocation", "modeling_type": "IP", "industry_sector": "Retail", "reason": "The problem involves allocating limited resources (apples, bananas, grapes) to produce different packages to maximize profit, which is a classic resource allocation problem. The decision variables (number of packages) must be integers, leading to an Integer Programming (IP) model. The application is clearly within a grocery store setting, which falls under the retail sector."}], "cluster": null, "prompt": "Below is an operations research question. First formulate the problem as an optimization problem. Then according to the formulated problem, write python code that uses 'gurobipy' to solve the optimization problem. You should write a complete python code that can be executed to solve the optimization problem.\n\nIMPORTANT: Your code should follow these requirements:\n1. Create a Gurobi model variable named 'model' (not 'm' or other names)\n2. Include all necessary imports and data setup\n3. Write the complete optimization code that can run independently\n4. Do NOT wrap everything in a function - write the code directly\n5. Make sure the model is created and optimized in the main execution flow\n6. The code should print the optimal objective value when solved successfully\n\nExample format:\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Data setup\ndata = {...}\n\n# Create model\nmodel = gp.Model(\"ProblemName\")\n\n# Decision variables\nx = model.addVars(...)\n\n# Objective\nmodel.setObjective(...)\n\n# Constraints\nmodel.addConstr(...)\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\nelse:\n    print(\"No optimal solution found\")\n```\n\n# Question:\nA grocery store wants to liquidate its stock of 10 apples, 20 bananas, and 80 grapes. Given past experience, the store knows that they can propose a banana-haters package with 6 apples and 30 grapes and that this package will bring a profit of six euros. Similarly, they can prepare a combo package with 5 apples, 6 bananas, and 20 grapes, yielding a profit of seven euros. They know they can sell any quantity of these two packages within the availability of its stock. What quantity of each package, banana-haters packages and combo packages, should the store prepare to maximize net profit?\n\n# Response:", "generated_output": "Below is the formulation and then the complete Python code using `gurobipy`.\n\n---\n\n## Optimization Model Formulation\n\n**Decision variables**\n\n- \\( x_1 \\ge 0 \\): number of banana-haters packages to prepare  \n- \\( x_2 \\ge 0 \\): number of combo packages to prepare  \n\n(We will treat them as continuous and nonnegative; if they must be integer, we can set them as integer variables.)\n\n**Objective**\n\nMaximize total profit:\n\n\\[\n\\max \\; Z = 6x_1 + 7x_2\n\\]\n\n**Constraints**\n\nStock limits:\n\n- Apples: each banana-haters package uses 6 apples, each combo package uses 5 apples, and there are 10 apples:\n  \\[\n  6x_1 + 5x_2 \\le 10\n  \\]\n\n- Bananas: each combo package uses 6 bananas, and there are 20 bananas:\n  \\[\n  6x_2 \\le 20\n  \\]\n\n- Grapes: each banana-haters package uses 30 grapes, each combo package uses 20 grapes, and there are 80 grapes:\n  \\[\n  30x_1 + 20x_2 \\le 80\n  \\]\n\nNonnegativity:\n\n\\[\nx_1 \\ge 0,\\quad x_2 \\ge 0\n\\]\n\n---\n\n## Complete Python Code (Gurobi)\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Data setup\napples = 10\nbananas = 20\ngrapes = 80\n\n# Resource usage per package\n# Banana-haters package (index 1): 6 apples, 0 bananas, 30 grapes, profit 6\n# Combo package        (index 2): 5 apples, 6 bananas, 20 grapes, profit 7\napple_use = {1: 6, 2: 5}\nbanana_use = {1: 0, 2: 6}\ngrape_use = {1: 30, 2: 20}\nprofit = {1: 6, 2: 7}\n\n# Create model\nmodel = gp.Model(\"Grocery_Packages\")\n\n# Decision variables: number of each package type\n# If you want integer solutions, change vtype=GRB.INTEGER\nx = model.addVars([1, 2], name=\"x\", lb=0.0, vtype=GRB.CONTINUOUS)\n\n# Objective: maximize total profit\nmodel.setObjective(\n    gp.quicksum(profit[i] * x[i] for i in [1, 2]),\n    GRB.MAXIMIZE\n)\n\n# Constraints\n\n# Apples constraint\nmodel.addConstr(\n    gp.quicksum(apple_use[i] * x[i] for i in [1, 2]) <= apples,\n    name=\"Apples\"\n)\n\n# Bananas constraint\nmodel.addConstr(\n    gp.quicksum(banana_use[i] * x[i] for i in [1, 2]) <= bananas,\n    name=\"Bananas\"\n)\n\n# Grapes constraint\nmodel.addConstr(\n    gp.quicksum(grape_use[i] * x[i] for i in [1, 2]) <= grapes,\n    name=\"Grapes\"\n)\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\n    for i in [1, 2]:\n        print(f\"x[{i}] (package {i}) = {x[i].X}\")\nelse:\n    print(\"No optimal solution found\")\n```", "extracted_code": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Data setup\napples = 10\nbananas = 20\ngrapes = 80\n\n# Resource usage per package\n# Banana-haters package (index 1): 6 apples, 0 bananas, 30 grapes, profit 6\n# Combo package        (index 2): 5 apples, 6 bananas, 20 grapes, profit 7\napple_use = {1: 6, 2: 5}\nbanana_use = {1: 0, 2: 6}\ngrape_use = {1: 30, 2: 20}\nprofit = {1: 6, 2: 7}\n\n# Create model\nmodel = gp.Model(\"Grocery_Packages\")\n\n# Decision variables: number of each package type\n# If you want integer solutions, change vtype=GRB.INTEGER\nx = model.addVars([1, 2], name=\"x\", lb=0.0, vtype=GRB.CONTINUOUS)\n\n# Objective: maximize total profit\nmodel.setObjective(\n    gp.quicksum(profit[i] * x[i] for i in [1, 2]),\n    GRB.MAXIMIZE\n)\n\n# Constraints\n\n# Apples constraint\nmodel.addConstr(\n    gp.quicksum(apple_use[i] * x[i] for i in [1, 2]) <= apples,\n    name=\"Apples\"\n)\n\n# Bananas constraint\nmodel.addConstr(\n    gp.quicksum(banana_use[i] * x[i] for i in [1, 2]) <= bananas,\n    name=\"Bananas\"\n)\n\n# Grapes constraint\nmodel.addConstr(\n    gp.quicksum(grape_use[i] * x[i] for i in [1, 2]) <= grapes,\n    name=\"Grapes\"\n)\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\n    for i in [1, 2]:\n        print(f\"x[{i}] (package {i}) = {x[i].X}\")\nelse:\n    print(\"No optimal solution found\")", "execution_success": true, "mathematical_accuracy": true, "execution_result": "Execution Successful", "execution_best_solution": 14.0, "execution_state": "Execution Successful"}
{"task_id": "A098", "description": "A patient can be hooked up to two machines to have medicine delivered, machine 1 and machine 2. Machine 1 delivers 0.5 units of medicine to the heart per minute and 0.8 units of medicine per minute to the brain. Machine 2 delivers 0.3 units of medicine per minute to the heart and 1 unit of medicine per minute to the brain. In addition however, machine 1 creates 0.3 units of waste per minute while machine 2 creates 0.5 units of waste per minute. If at most 8 units of medicine can be received by the heart and at least 4 units of medicine should be received by the brain, how many minutes should each machine be used to minimize the total amount of waste produced?", "ground_truth": 1.5, "formulation": null, "correct_program": "def optimize_machine_usage():\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"MedicineDeliveryWasteMinimization\")\n\n    # Decision variables: usage time of each machine\n    t1 = m.addVar(name=\"t1\", lb=0)  # Machine 1 usage time\n    t2 = m.addVar(name=\"t2\", lb=0)  # Machine 2 usage time\n\n    # Set objective: minimize total waste\n    m.setObjective(0.3 * t1 + 0.5 * t2, GRB.MINIMIZE)\n\n    # Add constraints\n    # Medicine delivered to the heart\n    m.addConstr(0.5 * t1 + 0.3 * t2 <= 8, name=\"HeartDelivery\")\n    # Medicine delivered to the brain\n    m.addConstr(0.8 * t1 + 1.0 * t2 >= 4, name=\"BrainDelivery\")\n\n    # Optimize the model\n    m.optimize()\n\n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the optimal total waste\n        return m.objVal\n    else:\n        # No feasible solution\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    min_waste = optimize_machine_usage()\n    if min_waste is not None:\n        print(f\"Minimum Total Waste: {min_waste}\")\n    else:\n        print(\"No feasible solution found.\")", "output_status": [], "success_count": 0, "success_confidence": 0, "fail_to_diagnose": 0, "fail_to_verify": 0, "retrieved_insights": [], "tag": [{"problem_domain": "Resource Allocation", "modeling_type": "LP", "industry_sector": "Health", "reason": "The problem involves allocating the usage time of two machines (resources) to deliver medicine while satisfying dosage constraints and minimizing waste. The solver program uses linear objective and constraints with continuous variables, characteristic of a Linear Program (LP)."}], "cluster": null, "prompt": "Below is an operations research question. First formulate the problem as an optimization problem. Then according to the formulated problem, write python code that uses 'gurobipy' to solve the optimization problem. You should write a complete python code that can be executed to solve the optimization problem.\n\nIMPORTANT: Your code should follow these requirements:\n1. Create a Gurobi model variable named 'model' (not 'm' or other names)\n2. Include all necessary imports and data setup\n3. Write the complete optimization code that can run independently\n4. Do NOT wrap everything in a function - write the code directly\n5. Make sure the model is created and optimized in the main execution flow\n6. The code should print the optimal objective value when solved successfully\n\nExample format:\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Data setup\ndata = {...}\n\n# Create model\nmodel = gp.Model(\"ProblemName\")\n\n# Decision variables\nx = model.addVars(...)\n\n# Objective\nmodel.setObjective(...)\n\n# Constraints\nmodel.addConstr(...)\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\nelse:\n    print(\"No optimal solution found\")\n```\n\n# Question:\nA patient can be hooked up to two machines to have medicine delivered, machine 1 and machine 2. Machine 1 delivers 0.5 units of medicine to the heart per minute and 0.8 units of medicine per minute to the brain. Machine 2 delivers 0.3 units of medicine per minute to the heart and 1 unit of medicine per minute to the brain. In addition however, machine 1 creates 0.3 units of waste per minute while machine 2 creates 0.5 units of waste per minute. If at most 8 units of medicine can be received by the heart and at least 4 units of medicine should be received by the brain, how many minutes should each machine be used to minimize the total amount of waste produced?\n\n# Response:", "generated_output": "Below is the formulation and then the complete Python code using `gurobipy`.\n\n---\n\n## Optimization Model Formulation\n\n**Decision variables**\n\n- \\( x_1 \\ge 0 \\): minutes machine 1 is used  \n- \\( x_2 \\ge 0 \\): minutes machine 2 is used  \n\n**Objective**\n\nMinimize total waste:\n\\[\n\\min \\; Z = 0.3 x_1 + 0.5 x_2\n\\]\n\n**Constraints**\n\n1. Heart medicine limit (at most 8 units):\n\\[\n0.5 x_1 + 0.3 x_2 \\le 8\n\\]\n\n2. Brain medicine requirement (at least 4 units):\n\\[\n0.8 x_1 + 1.0 x_2 \\ge 4\n\\]\n\n3. Non-negativity:\n\\[\nx_1 \\ge 0,\\quad x_2 \\ge 0\n\\]\n\n---\n\n## Complete Python Code (Gurobi)\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Create model\nmodel = gp.Model(\"MedicineDelivery\")\n\n# Decision variables: minutes of use for each machine\nx1 = model.addVar(lb=0.0, vtype=GRB.CONTINUOUS, name=\"x1\")  # minutes machine 1\nx2 = model.addVar(lb=0.0, vtype=GRB.CONTINUOUS, name=\"x2\")  # minutes machine 2\n\n# Objective: minimize total waste\n# Machine 1: 0.3 units waste per minute\n# Machine 2: 0.5 units waste per minute\nmodel.setObjective(0.3 * x1 + 0.5 * x2, GRB.MINIMIZE)\n\n# Constraints\n\n# Heart medicine: at most 8 units\n# 0.5 units/min from machine 1, 0.3 units/min from machine 2\nmodel.addConstr(0.5 * x1 + 0.3 * x2 <= 8, name=\"HeartLimit\")\n\n# Brain medicine: at least 4 units\n# 0.8 units/min from machine 1, 1.0 units/min from machine 2\nmodel.addConstr(0.8 * x1 + 1.0 * x2 >= 4, name=\"BrainRequirement\")\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value (minimum total waste): {model.objVal}\")\n    print(f\"Optimal minutes for machine 1 (x1): {x1.X}\")\n    print(f\"Optimal minutes for machine 2 (x2): {x2.X}\")\nelse:\n    print(\"No optimal solution found\")\n```", "extracted_code": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create model\nmodel = gp.Model(\"MedicineDelivery\")\n\n# Decision variables: minutes of use for each machine\nx1 = model.addVar(lb=0.0, vtype=GRB.CONTINUOUS, name=\"x1\")  # minutes machine 1\nx2 = model.addVar(lb=0.0, vtype=GRB.CONTINUOUS, name=\"x2\")  # minutes machine 2\n\n# Objective: minimize total waste\n# Machine 1: 0.3 units waste per minute\n# Machine 2: 0.5 units waste per minute\nmodel.setObjective(0.3 * x1 + 0.5 * x2, GRB.MINIMIZE)\n\n# Constraints\n\n# Heart medicine: at most 8 units\n# 0.5 units/min from machine 1, 0.3 units/min from machine 2\nmodel.addConstr(0.5 * x1 + 0.3 * x2 <= 8, name=\"HeartLimit\")\n\n# Brain medicine: at least 4 units\n# 0.8 units/min from machine 1, 1.0 units/min from machine 2\nmodel.addConstr(0.8 * x1 + 1.0 * x2 >= 4, name=\"BrainRequirement\")\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value (minimum total waste): {model.objVal}\")\n    print(f\"Optimal minutes for machine 1 (x1): {x1.X}\")\n    print(f\"Optimal minutes for machine 2 (x2): {x2.X}\")\nelse:\n    print(\"No optimal solution found\")", "execution_success": true, "mathematical_accuracy": true, "execution_result": "Execution Successful", "execution_best_solution": 1.5, "execution_state": "Execution Successful"}
{"task_id": "A199", "description": "Both subsoil and topsoil need to be added to a garden bed. One bag of subsoil requires 10 units of water to hydrate while one bag of topsoil requires 6 units of water to hydrate every day. The truck used to transport the dirt has limited capacity and therefore, the farmer has available 150 bags of topsoil and subsoil combined. In addition, at least 10 bags of topsoil must be used. Since the topsoil is more expensive, at most 30% of all bags of soil can be topsoil. How many bags of each should be bought to minimize the total amount of water required to hydrate the garden bed?", "ground_truth": 300.0, "formulation": null, "correct_program": "def optimize_soil_bags(total_bags=150, min_topsoil=10, max_topsoil_ratio=0.3):\n    from gurobipy import Model, GRB\n\n    # Create a new model\n    m = Model(\"Soil_Bag_Optimization\")\n    \n    # Decision variables: number of subsoil and topsoil bags\n    x = m.addVar(vtype=GRB.INTEGER, name=\"subsoil_bags\", lb=0)\n    y = m.addVar(vtype=GRB.INTEGER, name=\"topsoil_bags\", lb=min_topsoil)\n    \n    # Set the objective: minimize total water\n    m.setObjective(10 * x + 6 * y, GRB.MINIMIZE)\n    \n    # Add constraints\n    # Total bags constraint\n    m.addConstr(x + y <= total_bags, \"total_bags_limit\")\n    # Topsoil proportion constraint\n    m.addConstr(y <= max_topsoil_ratio * (x + y), \"topsoil_ratio\")\n    # Since y >= 10 is already set as lb, no need to add separately\n    \n    # Optimize the model\n    m.optimize()\n    \n    # Check if a feasible solution was found\n    if m.status == GRB.OPTIMAL:\n        # Return the optimal total water consumption\n        return m.objVal\n    else:\n        # No feasible solution\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    min_water = optimize_soil_bags()\n    if min_water is not None:\n        print(f\"Minimum Total Water Consumption: {min_water}\")\n    else:\n        print(\"No feasible solution found.\")", "output_status": [], "success_count": 0, "success_confidence": 0, "fail_to_diagnose": 0, "fail_to_verify": 0, "retrieved_insights": [], "tag": [{"problem_domain": "Resource Allocation", "modeling_type": "MILP", "industry_sector": "Agriculture", "reason": "The problem involves allocating a limited resource (total bags, water, and topsoil proportion) to minimize an objective (total water consumption). The solver uses integer variables and linear constraints, making it a Mixed-Integer Linear Program. The context of adding soil to a garden bed clearly places it within the agriculture sector."}], "cluster": null, "prompt": "Below is an operations research question. First formulate the problem as an optimization problem. Then according to the formulated problem, write python code that uses 'gurobipy' to solve the optimization problem. You should write a complete python code that can be executed to solve the optimization problem.\n\nIMPORTANT: Your code should follow these requirements:\n1. Create a Gurobi model variable named 'model' (not 'm' or other names)\n2. Include all necessary imports and data setup\n3. Write the complete optimization code that can run independently\n4. Do NOT wrap everything in a function - write the code directly\n5. Make sure the model is created and optimized in the main execution flow\n6. The code should print the optimal objective value when solved successfully\n\nExample format:\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Data setup\ndata = {...}\n\n# Create model\nmodel = gp.Model(\"ProblemName\")\n\n# Decision variables\nx = model.addVars(...)\n\n# Objective\nmodel.setObjective(...)\n\n# Constraints\nmodel.addConstr(...)\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\nelse:\n    print(\"No optimal solution found\")\n```\n\n# Question:\nBoth subsoil and topsoil need to be added to a garden bed. One bag of subsoil requires 10 units of water to hydrate while one bag of topsoil requires 6 units of water to hydrate every day. The truck used to transport the dirt has limited capacity and therefore, the farmer has available 150 bags of topsoil and subsoil combined. In addition, at least 10 bags of topsoil must be used. Since the topsoil is more expensive, at most 30% of all bags of soil can be topsoil. How many bags of each should be bought to minimize the total amount of water required to hydrate the garden bed?\n\n# Response:", "generated_output": "Below is the formulation and then the complete Python code using `gurobipy`.\n\n---\n\n## Optimization Model Formulation\n\nDecision variables  \n- \\( x_s \\): number of bags of subsoil  \n- \\( x_t \\): number of bags of topsoil  \n\nObjective (minimize total water used per day)  \n\\[\n\\min \\; 10x_s + 6x_t\n\\]\n\nConstraints  \n\n1. Total number of bags cannot exceed 150:\n\\[\nx_s + x_t \\le 150\n\\]\n\n2. At least 10 bags of topsoil:\n\\[\nx_t \\ge 10\n\\]\n\n3. At most 30% of all bags can be topsoil:\n\\[\nx_t \\le 0.3(x_s + x_t)\n\\]\n\n4. Non-negativity and integrality (bags are discrete):\n\\[\nx_s \\ge 0,\\; x_t \\ge 0,\\; x_s, x_t \\in \\mathbb{Z}\n\\]\n\n---\n\n## Complete Python Code (Gurobi)\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Create model\nmodel = gp.Model(\"SoilWaterMinimization\")\n\n# Decision variables: number of bags of subsoil (xs) and topsoil (xt)\n# Bags must be integers and non-negative\nxs = model.addVar(vtype=GRB.INTEGER, name=\"subsoil_bags\", lb=0)\nxt = model.addVar(vtype=GRB.INTEGER, name=\"topsoil_bags\", lb=0)\n\n# Objective: minimize total water usage\n# 10 units per bag of subsoil, 6 units per bag of topsoil\nmodel.setObjective(10 * xs + 6 * xt, GRB.MINIMIZE)\n\n# Constraints\n\n# 1) Total number of bags cannot exceed 150\nmodel.addConstr(xs + xt <= 150, name=\"total_bags_limit\")\n\n# 2) At least 10 bags of topsoil\nmodel.addConstr(xt >= 10, name=\"min_topsoil\")\n\n# 3) At most 30% of all bags can be topsoil:\n#    xt <= 0.3 * (xs + xt)\n# Rearranged: 0.7 * xt <= 0.3 * xs  ->  7*xt <= 3*xs (to avoid decimals)\nmodel.addConstr(7 * xt <= 3 * xs, name=\"topsoil_fraction_limit\")\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value (minimum total water): {model.objVal}\")\n    print(f\"Optimal number of subsoil bags (xs): {xs.X}\")\n    print(f\"Optimal number of topsoil bags (xt): {xt.X}\")\nelse:\n    print(\"No optimal solution found\")\n```", "extracted_code": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create model\nmodel = gp.Model(\"SoilWaterMinimization\")\n\n# Decision variables: number of bags of subsoil (xs) and topsoil (xt)\n# Bags must be integers and non-negative\nxs = model.addVar(vtype=GRB.INTEGER, name=\"subsoil_bags\", lb=0)\nxt = model.addVar(vtype=GRB.INTEGER, name=\"topsoil_bags\", lb=0)\n\n# Objective: minimize total water usage\n# 10 units per bag of subsoil, 6 units per bag of topsoil\nmodel.setObjective(10 * xs + 6 * xt, GRB.MINIMIZE)\n\n# Constraints\n\n# 1) Total number of bags cannot exceed 150\nmodel.addConstr(xs + xt <= 150, name=\"total_bags_limit\")\n\n# 2) At least 10 bags of topsoil\nmodel.addConstr(xt >= 10, name=\"min_topsoil\")\n\n# 3) At most 30% of all bags can be topsoil:\n#    xt <= 0.3 * (xs + xt)\n# Rearranged: 0.7 * xt <= 0.3 * xs  ->  7*xt <= 3*xs (to avoid decimals)\nmodel.addConstr(7 * xt <= 3 * xs, name=\"topsoil_fraction_limit\")\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value (minimum total water): {model.objVal}\")\n    print(f\"Optimal number of subsoil bags (xs): {xs.X}\")\n    print(f\"Optimal number of topsoil bags (xt): {xt.X}\")\nelse:\n    print(\"No optimal solution found\")", "execution_success": true, "mathematical_accuracy": true, "execution_result": "Execution Successful", "execution_best_solution": 300.0, "execution_state": "Execution Successful"}
{"task_id": "A076", "description": "A vine company sells vine in vintage and regular bottles. A vintage bottle can hold 500 ml of vine while a regular bottle can hold 750 ml of vine. The company has available 100000 ml of vine. Because vintage bottles are mostly bought by collectors, the number of regular bottles must be at least 4 times as much as the number of vintage bottles. However, at least 10 vintage bottles must be made. How many of each should be made to maximize the total number of bottles produced?", "ground_truth": 142.0, "formulation": null, "correct_program": "def optimize_bottle_production(\n    total_vine_ml=100000,\n    vintage_volume_ml=500,\n    regular_volume_ml=750,\n    min_vintage_bottles=10,\n    ratio_regular_to_vintage=4\n):\n    import gurobipy as gp\n    from gurobipy import GRB\n\n    # Create a new model\n    model = gp.Model(\"Vine_Bottles_Production\")\n\n    # Decision variables: number of vintage and regular bottles\n    V = model.addVar(vtype=GRB.INTEGER, name=\"Vintage\", lb=min_vintage_bottles)\n    R = model.addVar(vtype=GRB.INTEGER, name=\"Regular\", lb=0)\n\n    # Set the objective: maximize total number of bottles\n    model.setObjective(V + R, GRB.MAXIMIZE)\n\n    # Add volume constraint\n    model.addConstr(\n        vintage_volume_ml * V + regular_volume_ml * R <= total_vine_ml,\n        name=\"VolumeConstraint\"\n    )\n\n    # Add ratio constraint: R >= 4V\n    model.addConstr(\n        R >= ratio_regular_to_vintage * V,\n        name=\"RatioConstraint\"\n    )\n\n    # Optimize the model\n    model.optimize()\n\n    # Check if a feasible solution was found\n    if model.status == GRB.OPTIMAL:\n        total_bottles = V.X + R.X\n        return total_bottles\n    else:\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    max_bottles = optimize_bottle_production()\n    if max_bottles is not None:\n        print(f\"Maximum Total Number of Bottles: {max_bottles}\")\n    else:\n        print(\"No feasible solution found.\")", "output_status": [], "success_count": 0, "success_confidence": 0, "fail_to_diagnose": 0, "fail_to_verify": 0, "retrieved_insights": [], "tag": [{"problem_domain": "Resource Allocation", "modeling_type": "MILP", "industry_sector": "Manufacturing", "reason": "The problem involves allocating a limited resource (vine) to produce different products (vintage and regular bottles) to maximize an objective (total bottles). The decision variables are integers, and the constraints and objective function are linear, making it a Mixed-Integer Linear Program. The context of producing bottles of vine falls under the manufacturing sector."}], "cluster": null, "prompt": "Below is an operations research question. First formulate the problem as an optimization problem. Then according to the formulated problem, write python code that uses 'gurobipy' to solve the optimization problem. You should write a complete python code that can be executed to solve the optimization problem.\n\nIMPORTANT: Your code should follow these requirements:\n1. Create a Gurobi model variable named 'model' (not 'm' or other names)\n2. Include all necessary imports and data setup\n3. Write the complete optimization code that can run independently\n4. Do NOT wrap everything in a function - write the code directly\n5. Make sure the model is created and optimized in the main execution flow\n6. The code should print the optimal objective value when solved successfully\n\nExample format:\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Data setup\ndata = {...}\n\n# Create model\nmodel = gp.Model(\"ProblemName\")\n\n# Decision variables\nx = model.addVars(...)\n\n# Objective\nmodel.setObjective(...)\n\n# Constraints\nmodel.addConstr(...)\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\nelse:\n    print(\"No optimal solution found\")\n```\n\n# Question:\nA vine company sells vine in vintage and regular bottles. A vintage bottle can hold 500 ml of vine while a regular bottle can hold 750 ml of vine. The company has available 100000 ml of vine. Because vintage bottles are mostly bought by collectors, the number of regular bottles must be at least 4 times as much as the number of vintage bottles. However, at least 10 vintage bottles must be made. How many of each should be made to maximize the total number of bottles produced?\n\n# Response:", "generated_output": "**Formulation**\n\nLet  \n- \\(x\\) = number of vintage bottles  \n- \\(y\\) = number of regular bottles  \n\nMaximize total number of bottles:\n\\[\n\\max \\; x + y\n\\]\n\nSubject to:\n1. Wine availability (in ml):\n\\[\n500x + 750y \\le 100000\n\\]\n2. Regular bottles at least 4 times vintage:\n\\[\ny \\ge 4x\n\\]\n3. At least 10 vintage bottles:\n\\[\nx \\ge 10\n\\]\n4. Non-negativity:\n\\[\nx \\ge 0,\\; y \\ge 0\n\\]\n\n(We will treat \\(x\\) and \\(y\\) as continuous; if integer bottles are required, we can set them as integer variables.)\n\n---\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Create model\nmodel = gp.Model(\"VineBottling\")\n\n# Decision variables\n# If integer bottles are required, use vtype=GRB.INTEGER\nx = model.addVar(name=\"vintage\", vtype=GRB.CONTINUOUS, lb=0)\ny = model.addVar(name=\"regular\", vtype=GRB.CONTINUOUS, lb=0)\n\n# Update model to integrate new variables\nmodel.update()\n\n# Objective: maximize total number of bottles\nmodel.setObjective(x + y, GRB.MAXIMIZE)\n\n# Constraints\n\n# Wine availability: 500x + 750y <= 100000\nmodel.addConstr(500 * x + 750 * y <= 100000, name=\"wine_capacity\")\n\n# Regular bottles at least 4 times vintage: y >= 4x\nmodel.addConstr(y >= 4 * x, name=\"regular_at_least_4x_vintage\")\n\n# At least 10 vintage bottles: x >= 10\nmodel.addConstr(x >= 10, name=\"min_vintage\")\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value (max total bottles): {model.objVal}\")\n    print(f\"Vintage bottles (x): {x.X}\")\n    print(f\"Regular bottles (y): {y.X}\")\nelse:\n    print(\"No optimal solution found\")\n```", "extracted_code": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create model\nmodel = gp.Model(\"VineBottling\")\n\n# Decision variables\n# If integer bottles are required, use vtype=GRB.INTEGER\nx = model.addVar(name=\"vintage\", vtype=GRB.CONTINUOUS, lb=0)\ny = model.addVar(name=\"regular\", vtype=GRB.CONTINUOUS, lb=0)\n\n# Update model to integrate new variables\nmodel.update()\n\n# Objective: maximize total number of bottles\nmodel.setObjective(x + y, GRB.MAXIMIZE)\n\n# Constraints\n\n# Wine availability: 500x + 750y <= 100000\nmodel.addConstr(500 * x + 750 * y <= 100000, name=\"wine_capacity\")\n\n# Regular bottles at least 4 times vintage: y >= 4x\nmodel.addConstr(y >= 4 * x, name=\"regular_at_least_4x_vintage\")\n\n# At least 10 vintage bottles: x >= 10\nmodel.addConstr(x >= 10, name=\"min_vintage\")\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value (max total bottles): {model.objVal}\")\n    print(f\"Vintage bottles (x): {x.X}\")\n    print(f\"Regular bottles (y): {y.X}\")\nelse:\n    print(\"No optimal solution found\")", "execution_success": true, "mathematical_accuracy": true, "execution_result": "Execution Successful", "execution_best_solution": 142.85714285714286, "execution_state": "Execution Successful"}
{"task_id": "A151", "description": "A corn farmer sends his corn to the city by either tractor or car.  A tractor can carry 40 kg of corn while a car can carry 20 kg of corn. Since tractors are very slow, the number of cars used has to be at least twice the number of tractors used. If at least 500 kg of corn need to be sent to the city, minimize the total number of tractors and cars needed.", "ground_truth": 19.0, "formulation": null, "correct_program": "import gurobipy as gp\nfrom gurobipy import GRB\n\ndef optimize_transportation(\n    capacity_truck=40,     # capacity of a tractor in kg\n    capacity_car=20,       # capacity of a car in kg\n    min_corn=500,          # minimum kg of corn to send\n    ratio_cars_to_tractors=2  # cars >= 2 * tractors\n):\n    # Create a new model\n    model = gp.Model(\"CornTransportOptimization\")\n    \n    # Decision variables: number of tractors and cars\n    x = model.addVar(vtype=GRB.INTEGER, name=\"tractors\", lb=0)\n    y = model.addVar(vtype=GRB.INTEGER, name=\"cars\", lb=0)\n    \n    # Set objective: minimize total number of vehicles\n    model.setObjective(x + y, GRB.MINIMIZE)\n    \n    # Capacity constraint: total transported >= min_corn\n    model.addConstr(capacity_truck * x + capacity_car * y >= min_corn, name=\"capacity\")\n    \n    # Ratio constraint: cars >= 2 * tractors\n    model.addConstr(y >= ratio_cars_to_tractors * x, name=\"ratio\")\n    \n    # Optimize the model\n    model.optimize()\n    \n    # Check if a feasible solution was found\n    if model.status == GRB.OPTIMAL:\n        # Return the minimal total number of vehicles\n        return model.objVal\n    else:\n        # No feasible solution\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    min_vehicles = optimize_transportation()\n    if min_vehicles is not None:\n        print(f\"Minimum Total Vehicles: {min_vehicles}\")\n    else:\n        print(\"No feasible solution found.\")", "output_status": [], "success_count": 0, "success_confidence": 0, "fail_to_diagnose": 0, "fail_to_verify": 0, "retrieved_insights": [], "tag": [{"problem_domain": "Resource Allocation", "modeling_type": "IP", "industry_sector": "Agriculture", "reason": "The problem involves allocating two types of vehicles (tractors and cars) to transport a minimum amount of corn while minimizing the total number of vehicles, which is a classic resource allocation problem. The decision variables (number of tractors and cars) must be integers, and the objective function and constraints are linear, making it an Integer Program. The context of a corn farmer transporting corn directly places it in the agriculture sector."}], "cluster": null, "prompt": "Below is an operations research question. First formulate the problem as an optimization problem. Then according to the formulated problem, write python code that uses 'gurobipy' to solve the optimization problem. You should write a complete python code that can be executed to solve the optimization problem.\n\nIMPORTANT: Your code should follow these requirements:\n1. Create a Gurobi model variable named 'model' (not 'm' or other names)\n2. Include all necessary imports and data setup\n3. Write the complete optimization code that can run independently\n4. Do NOT wrap everything in a function - write the code directly\n5. Make sure the model is created and optimized in the main execution flow\n6. The code should print the optimal objective value when solved successfully\n\nExample format:\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Data setup\ndata = {...}\n\n# Create model\nmodel = gp.Model(\"ProblemName\")\n\n# Decision variables\nx = model.addVars(...)\n\n# Objective\nmodel.setObjective(...)\n\n# Constraints\nmodel.addConstr(...)\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\nelse:\n    print(\"No optimal solution found\")\n```\n\n# Question:\nA corn farmer sends his corn to the city by either tractor or car.  A tractor can carry 40 kg of corn while a car can carry 20 kg of corn. Since tractors are very slow, the number of cars used has to be at least twice the number of tractors used. If at least 500 kg of corn need to be sent to the city, minimize the total number of tractors and cars needed.\n\n# Response:", "generated_output": "Below is the formulation and then the complete Python code using `gurobipy`.\n\n---\n\n## Optimization Formulation\n\n**Decision variables**\n\n- \\( T \\ge 0 \\): number of tractors (integer)\n- \\( C \\ge 0 \\): number of cars (integer)\n\n**Objective**\n\nMinimize the total number of vehicles:\n\\[\n\\min \\; T + C\n\\]\n\n**Constraints**\n\n1. Capacity (at least 500 kg of corn):\n\\[\n40T + 20C \\ge 500\n\\]\n\n2. Cars at least twice tractors:\n\\[\nC \\ge 2T\n\\]\n\n3. Non-negativity and integrality:\n\\[\nT, C \\in \\mathbb{Z}_{\\ge 0}\n\\]\n\n---\n\n## Gurobi Python Code\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Create model\nmodel = gp.Model(\"CornTransport\")\n\n# Decision variables: number of tractors (T) and cars (C)\nT = model.addVar(vtype=GRB.INTEGER, name=\"Tractors\", lb=0)\nC = model.addVar(vtype=GRB.INTEGER, name=\"Cars\", lb=0)\n\n# Update model to integrate new variables\nmodel.update()\n\n# Objective: minimize total number of vehicles\nmodel.setObjective(T + C, GRB.MINIMIZE)\n\n# Constraints\n\n# 1) Capacity constraint: 40T + 20C >= 500\nmodel.addConstr(40 * T + 20 * C >= 500, name=\"Capacity\")\n\n# 2) Cars at least twice tractors: C >= 2T\nmodel.addConstr(C >= 2 * T, name=\"Car_Tractor_Ratio\")\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value (minimum number of vehicles): {model.objVal}\")\n    print(f\"Number of tractors (T): {T.X}\")\n    print(f\"Number of cars (C): {C.X}\")\nelse:\n    print(\"No optimal solution found\")\n```", "extracted_code": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Create model\nmodel = gp.Model(\"CornTransport\")\n\n# Decision variables: number of tractors (T) and cars (C)\nT = model.addVar(vtype=GRB.INTEGER, name=\"Tractors\", lb=0)\nC = model.addVar(vtype=GRB.INTEGER, name=\"Cars\", lb=0)\n\n# Update model to integrate new variables\nmodel.update()\n\n# Objective: minimize total number of vehicles\nmodel.setObjective(T + C, GRB.MINIMIZE)\n\n# Constraints\n\n# 1) Capacity constraint: 40T + 20C >= 500\nmodel.addConstr(40 * T + 20 * C >= 500, name=\"Capacity\")\n\n# 2) Cars at least twice tractors: C >= 2T\nmodel.addConstr(C >= 2 * T, name=\"Car_Tractor_Ratio\")\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value (minimum number of vehicles): {model.objVal}\")\n    print(f\"Number of tractors (T): {T.X}\")\n    print(f\"Number of cars (C): {C.X}\")\nelse:\n    print(\"No optimal solution found\")", "execution_success": true, "mathematical_accuracy": true, "execution_result": "Execution Successful", "execution_best_solution": 19.0, "execution_state": "Execution Successful"}
{"task_id": "A181", "description": "Lucy has a dog and she wants his food to be mixed.  In order to keep the dog healthy but also keep the food tasty, the mix needs to have a minimum of 15 units of calcium, 20 units of vitamin mix, and 20 units of protein. A regular brand costs $20 per bag and contains 4 units of calcium, 7 units of vitamin mix, and 10 units of protein. A premium brand costs $35 per bag and contains 12 units of calcium, 10 units of vitamin mix, and 16 units of protein. How many bags of each brand should Lucy mix in order to minimize cost while also meeting the taste and health requirements.", "ground_truth": 70.0, "formulation": null, "correct_program": "def optimize_dog_food(\n    cost_regular=20,\n    cost_premium=35,\n    calcium_regular=4,\n    calcium_premium=12,\n    vitamin_regular=7,\n    vitamin_premium=10,\n    protein_regular=10,\n    protein_premium=16,\n    calcium_req=15,\n    vitamin_req=20,\n    protein_req=20\n):\n    import gurobipy as gp\n    from gurobipy import GRB\n\n    # Create a new model\n    model = gp.Model(\"DogFoodOptimization\")\n\n    # Decision variables: number of bags of each type\n    x = model.addVar(vtype=GRB.INTEGER, lb=0, name=\"Regular\")\n    y = model.addVar(vtype=GRB.INTEGER, lb=0, name=\"Premium\")\n\n    # Set objective: minimize total cost\n    model.setObjective(\n        cost_regular * x + cost_premium * y,\n        GRB.MINIMIZE\n    )\n\n    # Add constraints\n    # Calcium constraint\n    model.addConstr(\n        calcium_regular * x + calcium_premium * y >= calcium_req,\n        name=\"Calcium\"\n    )\n    # Vitamin constraint\n    model.addConstr(\n        vitamin_regular * x + vitamin_premium * y >= vitamin_req,\n        name=\"Vitamin\"\n    )\n    # Protein constraint\n    model.addConstr(\n        protein_regular * x + protein_premium * y >= protein_req,\n        name=\"Protein\"\n    )\n\n    # Optimize the model\n    model.optimize()\n\n    # Check if a feasible solution was found\n    if model.status == GRB.OPTIMAL:\n        # Return the optimal cost\n        return model.objVal\n    else:\n        # No feasible solution\n        return None\n# Example usage\nif __name__ == \"__main__\":\n    min_cost = optimize_dog_food()\n    if min_cost is not None:\n        print(f\"Minimum Cost: {min_cost}\")\n    else:\n        print(\"No feasible solution found.\")", "output_status": [], "success_count": 0, "success_confidence": 0, "fail_to_diagnose": 0, "fail_to_verify": 0, "retrieved_insights": [], "tag": [{"problem_domain": "Blending", "modeling_type": "IP", "industry_sector": "Consumer Goods", "reason": "The problem involves mixing different ingredients (dog food brands) to meet nutritional requirements at minimum cost, which is a classic blending problem. The decision variables (number of bags) must be integers, leading to an Integer Programming formulation."}], "cluster": null, "prompt": "Below is an operations research question. First formulate the problem as an optimization problem. Then according to the formulated problem, write python code that uses 'gurobipy' to solve the optimization problem. You should write a complete python code that can be executed to solve the optimization problem.\n\nIMPORTANT: Your code should follow these requirements:\n1. Create a Gurobi model variable named 'model' (not 'm' or other names)\n2. Include all necessary imports and data setup\n3. Write the complete optimization code that can run independently\n4. Do NOT wrap everything in a function - write the code directly\n5. Make sure the model is created and optimized in the main execution flow\n6. The code should print the optimal objective value when solved successfully\n\nExample format:\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Data setup\ndata = {...}\n\n# Create model\nmodel = gp.Model(\"ProblemName\")\n\n# Decision variables\nx = model.addVars(...)\n\n# Objective\nmodel.setObjective(...)\n\n# Constraints\nmodel.addConstr(...)\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\nelse:\n    print(\"No optimal solution found\")\n```\n\n# Question:\nLucy has a dog and she wants his food to be mixed.  In order to keep the dog healthy but also keep the food tasty, the mix needs to have a minimum of 15 units of calcium, 20 units of vitamin mix, and 20 units of protein. A regular brand costs $20 per bag and contains 4 units of calcium, 7 units of vitamin mix, and 10 units of protein. A premium brand costs $35 per bag and contains 12 units of calcium, 10 units of vitamin mix, and 16 units of protein. How many bags of each brand should Lucy mix in order to minimize cost while also meeting the taste and health requirements.\n\n# Response:", "generated_output": "Below is the formulation and then the complete Python code using `gurobipy`.\n\n---\n\n## Optimization Model Formulation\n\nDecision variables  \n- \\( x_R \\ge 0 \\): number of bags of Regular brand  \n- \\( x_P \\ge 0 \\): number of bags of Premium brand  \n\nObjective (minimize total cost)  \n\\[\n\\min \\; 20x_R + 35x_P\n\\]\n\nSubject to nutritional requirements:\n\nCalcium (at least 15 units):  \n\\[\n4x_R + 12x_P \\ge 15\n\\]\n\nVitamin mix (at least 20 units):  \n\\[\n7x_R + 10x_P \\ge 20\n\\]\n\nProtein (at least 20 units):  \n\\[\n10x_R + 16x_P \\ge 20\n\\]\n\nNon-negativity:  \n\\[\nx_R \\ge 0,\\quad x_P \\ge 0\n\\]\n\n---\n\n## Complete Python Code (Gurobi)\n\n```python\nimport gurobipy as gp\nfrom gurobipy import GRB\n\n# Data setup\ncost = {\n    \"Regular\": 20,\n    \"Premium\": 35\n}\n\ncalcium = {\n    \"Regular\": 4,\n    \"Premium\": 12\n}\n\nvitamin = {\n    \"Regular\": 7,\n    \"Premium\": 10\n}\n\nprotein = {\n    \"Regular\": 10,\n    \"Premium\": 16\n}\n\nmin_calcium = 15\nmin_vitamin = 20\nmin_protein = 20\n\nbrands = [\"Regular\", \"Premium\"]\n\n# Create model\nmodel = gp.Model(\"DogFoodMix\")\n\n# Decision variables: number of bags of each brand (continuous, >= 0)\nx = model.addVars(brands, name=\"bags\", lb=0.0)\n\n# Objective: minimize total cost\nmodel.setObjective(\n    gp.quicksum(cost[b] * x[b] for b in brands),\n    GRB.MINIMIZE\n)\n\n# Constraints\n\n# Calcium requirement\nmodel.addConstr(\n    gp.quicksum(calcium[b] * x[b] for b in brands) >= min_calcium,\n    name=\"CalciumReq\"\n)\n\n# Vitamin requirement\nmodel.addConstr(\n    gp.quicksum(vitamin[b] * x[b] for b in brands) >= min_vitamin,\n    name=\"VitaminReq\"\n)\n\n# Protein requirement\nmodel.addConstr(\n    gp.quicksum(protein[b] * x[b] for b in brands) >= min_protein,\n    name=\"ProteinReq\"\n)\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\n    for b in brands:\n        print(f\"{b} bags: {x[b].X}\")\nelse:\n    print(\"No optimal solution found\")\n```", "extracted_code": "import gurobipy as gp\nfrom gurobipy import GRB\n\n# Data setup\ncost = {\n    \"Regular\": 20,\n    \"Premium\": 35\n}\n\ncalcium = {\n    \"Regular\": 4,\n    \"Premium\": 12\n}\n\nvitamin = {\n    \"Regular\": 7,\n    \"Premium\": 10\n}\n\nprotein = {\n    \"Regular\": 10,\n    \"Premium\": 16\n}\n\nmin_calcium = 15\nmin_vitamin = 20\nmin_protein = 20\n\nbrands = [\"Regular\", \"Premium\"]\n\n# Create model\nmodel = gp.Model(\"DogFoodMix\")\n\n# Decision variables: number of bags of each brand (continuous, >= 0)\nx = model.addVars(brands, name=\"bags\", lb=0.0)\n\n# Objective: minimize total cost\nmodel.setObjective(\n    gp.quicksum(cost[b] * x[b] for b in brands),\n    GRB.MINIMIZE\n)\n\n# Constraints\n\n# Calcium requirement\nmodel.addConstr(\n    gp.quicksum(calcium[b] * x[b] for b in brands) >= min_calcium,\n    name=\"CalciumReq\"\n)\n\n# Vitamin requirement\nmodel.addConstr(\n    gp.quicksum(vitamin[b] * x[b] for b in brands) >= min_vitamin,\n    name=\"VitaminReq\"\n)\n\n# Protein requirement\nmodel.addConstr(\n    gp.quicksum(protein[b] * x[b] for b in brands) >= min_protein,\n    name=\"ProteinReq\"\n)\n\n# Optimize\nmodel.optimize()\n\n# Results\nif model.status == GRB.OPTIMAL:\n    print(f\"Optimal value: {model.objVal}\")\n    for b in brands:\n        print(f\"{b} bags: {x[b].X}\")\nelse:\n    print(\"No optimal solution found\")", "execution_success": true, "mathematical_accuracy": false, "execution_result": "Execution Successful", "execution_best_solution": 60.79545454545455, "execution_state": "Execution Successful"}
